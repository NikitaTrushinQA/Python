                                                                                                  Модуль re
В Python для работы с регулярными выражениями используется встроенный модуль re.
Для начала работы с ним его нужно импортировать:
import re

------------------------------------------------------------------------------------------------------Функция search()---------------------------------------------------------------------------
Функция search() сканирует строку в поисках первого совпадения с регулярным выражением и возвращает специальный объект соответствия (тип Match) или значение None,
если ни одна позиция в строке не соответствует регулярному выражению. 

Аргументы функции:

      pattern — шаблон регулярного выражения
      string — строка для поиска
      flags=0 — один или несколько флагов (необязательный аргумент)


from re import search
match1 = search('super', 'superstition')
match2 = search('super', 'insuperable')
match3 = search('super', 'without')

print(match1)                         <re.Match object; span=(0, 5), match='super'>
print(match2)                         <re.Match object; span=(2, 7), match='super'>
print(match3)                         None

---------------------------------------------------------------------------------------------Функция match()-------------------------------------------------------------------------------------------
Функция match() возвращает специальный объект соответствия (тип Match), если НАЧАЛО СТРОКИ соответствуют регулярному выражению, или значение None в противном случае.

Аргументы функции:

      pattern — шаблон регулярного выражения
      string — строка для поиска
      flags=0 — один или несколько флагов (необязательный аргумент)

from re import match
match1 = match('super', 'superstition')
match2 = match('super', 'insuperable')

print(match1)                <re.Match object; span=(0, 5), match='super'>
print(match2)                None

-----------------------------------------------------------------------------------------Функция fullmatch()------------------------------------------------------------------
Функция fullmatch() возвращает специальный объект соответствия (тип Match), если ВСЯ СТРОКА соответствует регулярному выражению, или значение None в противном случае.
Аргументы функции:

        pattern — шаблон регулярного выражения
        string — строка для поиска
        flags=0 — один или несколько флагов (необязательный аргумент)

from re import fullmatch

match1 = fullmatch('\d+', '123foo')                   
match2 = fullmatch('\d+', 'foo123')                   
match3 = fullmatch('\d+', 'foo123bar')               
match4 = fullmatch('\d+', '123')                      

print(match1)                               None
print(match2)                               None
print(match3)                               None
print(match4)                               <re.Match object; span=(0, 3), match='123'>

Функцию fullmatch() удобно использовать для валидации правильности данных.


from re import fullmatch
phone_pattern = '\d{3}-\d{3}-\d{4}'

match1 = fullmatch(phone_pattern , '777-888-1234')
match2 = fullmatch(phone_pattern , '77-89-56')
match3 = fullmatch(phone_pattern , '5555-99-1234')
match4 = fullmatch(phone_pattern , '123-000-3333ab')

проверяет соответствие строк регулярному выражению ddd-ddd-dddd (три цифры дефис три цифры дефис четыре цифры) и выводит:

print(match1)                 <re.Match object; span=(0, 12), match='777-888-1234'>
print(match2)                 None
print(match3)                 None
print(match4)                 None

----------------------------------------------------------------------------------------------------------------Объекты типа Match---------------------------------------------------------------------------------

Все три рассмотренные функции search(), match(), fullmatch() при успешном соответствии регулярному выражению возвращают объект типа Match.
Объекты такого типа приводятся к типу bool автоматически, поэтому мы можем использовать их в условном операторе.

from re import search, fullmatch

match = fullmatch('\d{3}-\d{3}-\d{4}', '777-888-1234')

if match:
    print('Строка соответствует формату.')
    print(match)
else:
    print('Строка не соответствует формату.')

выводит:
Строка соответствует формату.
<re.Match object; span=(0, 12), match='777-888-1234'>

---------------------------------------------------------------------------------------------------------------------Метод group()-------------------------------------------------------------------------------------
Метод group() возвращает одну или несколько подгрупп совпадения. Если метод вызывается без аргументов, то возвращается вся подстрока, которая совпала с шаблоном регулярного выражения.

Приведенный ниже код:

from re import search

match = search('(\w+),(\w+),(\w+)', 'foo,bar,baz')

print(match.group())                       # вся строка          foo,bar,baz
print(match.group(0))                      # вся строка          foo,bar,baz
print(match.group(1))                      # подгруппа           foo
print(match.group(2))                      # подгруппа           bar
print(match.group(3))                      # подгруппа           baz
print(match.group(1, 2, 3))                # кортеж              ('foo', 'bar', 'baz')

Если методу group() передать индекс несуществующей группы, то будет возбуждено исключение.  (IndexError: no such group)

Если мы пользуемся именованными группами, используя синтаксис (?P<name><regex>), тогда мы можем использовать название группы в качестве аргумента метода group().

from re import search
match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,bar,baz')

print(match.group())                                          foo,bar,baz
print(match.group('w1'))                                      foo
print(match.group('w2'))                                      bar
print(match.group('w3'))                                      baz
print(match.group('w1', 'w2', 'w3', 'w2', 'w3'))              ('foo', 'bar', 'baz', 'bar', 'baz')

Обратите внимание на то, что метод group() может возвращать в качестве группы значение None. Так происходит в ситуации, когда группа не участвует в сопоставлении.


from re import search
match = search('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(match.group())            foo,bar,
print(match.group(0))           foo,bar,
print(match.group(1))           foo
print(match.group(2))           bar
print(match.group(3))           None
print(match.group(1, 2, 3))     ('foo', 'bar', None)

-------------------------------------------------------------------------------------------------------Метод groupdict()--------------------------------------------------------------
Метод groupdict() возвращает словарь, содержащий все захваченные именованные группы.


from re import search
match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,bar,baz')

print(match.groupdict())

выводит:
{'w1': 'foo', 'w2': 'bar', 'w3': 'baz'}

Метод groupdict(), как и метод groups(), принимает необязательный аргумент default, который используется для указания значений групп, которые не смогли захватить какой либо результат.
По умолчанию значение данного аргумента равно None.

Приведенный ниже код:

from re import search

match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)?', 'foo,bar,')

print(match.groupdict())
print(match.groupdict(default=''))
print(match.groupdict(default='----'))

выводит:
{'w1': 'foo', 'w2': 'bar', 'w3': None}
{'w1': 'foo', 'w2': 'bar', 'w3': ''}
{'w1': 'foo', 'w2': 'bar', 'w3': '----'}

Если именованных групп в исходном регулярном выражении нет, метод groupdict() возвращает пустой словарь.

-----------------------------------------------------------------------------------------------------Методы start() и end()-------------------------------------------------------------------------

Методы start() и end() возвращают индексы начала и конца подстроки, которая совпала с регулярным выражением.

Приведенный ниже код:

from re import search

match = search('\d+', 'foo123bar456baz')

print(match)                        <re.Match object; span=(3, 6), match='123'>
print(match.start())                3
print(match.end())                  6

В методы start() и end() также можно передать номер или названия группы. В этом случае методы вернут индексы начала и конца подстроки, совпадающей с нужной группой.

Приведенный ниже код:

from re import search

text = 'foo123bar456baz'

match = search('(\d+)\D+(?P<num>\d+)', text)

print(match)
print(match.group(), match.start(), match.end())
print(match.group(1), match.start(1), match.end(1))
print(match.group('num'), match.start('num'), match.end('num'))
выводит:

<re.Match object; span=(3, 12), match='123bar456'>
123bar456 3 12
123 3 6
456 9 12

--------------------------------------------------------------------------------------------------------Метод span()-------------------------------------------------

Метод span() возвращает индексы начала и конца подстроки в виде кортежа, которая совпала с регулярным выражением.
В метод span() также можно передать номер или название группы. В этом случае метод вернет индексы начала и конца подстроки в виде кортежа, совпадающей с нужной группой.

Приведенный ниже код:

from re import search

match = search('(\d+)\D+(?P<num>\d+)', 'foo123bar456baz')

print(match)                                     <re.Match object; span=(3, 12), match='123bar456'>
print(match.span())                              (3, 12)
print(match.span(1))                             (3, 6)
print(match.span('num'))                         (9, 12)

-------------------------------------------------------------------------------------------------------Флаги------------------------------------------------------------------------------
Все три рассмотренные функции search(), match(), fullmatch() принимают необязательный аргумент flags.
Использование флагов изменяет поведение синтаксического анализа регулярных выражений, позволяя еще больше уточнить сопоставление с образцом. Функциональность регулярных выражений расширяется за счет флагов.

Короткое имя	              Полное имя	            Назначение
 re.I	                    re.IGNORECASE	            игнорирует регистр символов
 re.M	                    re.MULTILINE	            используется совместно с метасимволами ^ и $, в первом случае возвращает совпадения в начале каждой новой строки \n, во втором – в конце \n
 re.S	                    re.DOTALL	                заставляет метасимвол . возвращать совпадения по абсолютно всем символам, включая \n
 re.X	                    re.VERBOSE	              разрешает комментарии в регулярном выражении
 -	                      re.DEBUG	                показывает отладочную информацию о скомпилированном регулярном выражении
 re.A	                    re.ASCII	                указывает кодировку ASCII для классификации символов \w, \W, \b, \B, \d, \D, \s, \S
 re.U	                    re.UNICODE	              указывает кодировку Unicode для классификации символов  \w, \W, \b, \B, \d, \D, \s, \S
 re.L	                    re.LOCALE	                учитывает региональные настройки при использовании метасимволов \w, \W, \b, \B, \s, \S

Наиболее часто используемые флаги:

re.IGNORECASE
re.MULTILINE
re.DOTALL

----------------------------------------------------------------------------------------Флаг re.IGNORECASE--------------------------------------------------------------
Флаг re.IGNORECASE (re.I) выполняет сопоставление без учета регистра.
import re
match1 = re.search('a+', 'aaaAAA')
match2 = re.search('A+', 'aaaAAA')
match3 = re.search('a+', 'aaaAAA', re.IGNORECASE)
match4 = re.search('A+', 'aaaAAA', re.I)

print(match1)
print(match2)
print(match3)
print(match4)
выводит:

<re.Match object; span=(0, 3), match='aaa'>
<re.Match object; span=(3, 6), match='AAA'>
<re.Match object; span=(0, 6), match='aaaAAA'>
<re.Match object; span=(0, 6), match='aaaAAA'>

При первом поиске регулярному выражению a+ соответствует только первые три символа строки аааААА.
При втором поиске регулярному выражению A+ соответствуют три последних символа.
При третьем и четвертом поисках мы используем флаг re.IGNORECASE (re.I), поэтому синтаксический анализатор игнорирует регистр, и регулярным выражениям a+ и А+ соответствует вся строка.

import re
match1 = re.search('[a-z]+', 'aBcDeF')
match2 = re.search('[a-z]+', 'aBcDeF', re.I)

print(match1)
print(match2)
выводит:

<re.Match object; span=(0, 1), match='a'>
<re.Match object; span=(0, 6), match='aBcDeF'>

При отсутствии флага регулярному выражению [a-z]+ в строке aBcDeF соответствует только первый символ a.
Указание флага re.I делает поиск нечувствительным к регистру, поэтому регулярному выражению [a-z]+ соответствует вся строка.

----------------------------------------------------------------------------------------------Флаг re.MULTILINE----------------------------------------------------------------------

По умолчанию метасимволы ^ и $ совпадают только с началом и концом всей строки, не учитывая наличие в строке символов \n.

import re
text = 'foo\nbar\nbaz'

print(re.search('^foo', text))
print(re.search('^bar', text))
print(re.search('^baz', text))
print(re.search('foo$', text))
print(re.search('bar$', text))
print(re.search('baz$', text))
выводит:

<re.Match object; span=(0, 3), match='foo'>
None
None
None
None
<re.Match object; span=(8, 11), match='baz'>

Несмотря на то что строка  'foo\nbar\nbaz' содержит символы новой строки \n, мы получили только соответствие регулярному выражению ^foo и baz$.

Использование флага re.MULTILINE позволяет правильным образом обрабатывать символы \n, тем самым находя начала и концы всех строк с учетом символа \n.

Приведенный ниже код:

import re

text = 'foo\nbar\nbaz'

print(re.search('^foo', text, re.MULTILINE))
print(re.search('^bar', text, re.MULTILINE))
print(re.search('^baz', text, re.MULTILINE))
print(re.search('foo$', text, re.M))
print(re.search('bar$', text, re.M))
print(re.search('baz$', text, re.M))
выводит:

<re.Match object; span=(0, 3), match='foo'>
<re.Match object; span=(4, 7), match='bar'>
<re.Match object; span=(8, 11), match='baz'>
<re.Match object; span=(0, 3), match='foo'>
<re.Match object; span=(4, 7), match='bar'>
<re.Match object; span=(8, 11), match='baz'>
------------------------------------------------------------------------------------------------Флаг re.DOTALL---------------------------------------------------------------
Флаг re.DOTALL (re.S) делает так, чтобы метасимвол . соответствовал любому символу, включая символ новой строки \n. Без этого флага метасимвол . соответствует любому символу, кроме новой строки.

import re
print(re.search('foo.bar', 'foo\nbar'))
print(re.search('foo.bar', 'foo\nbar', re.DOTALL))
print(re.search('foo.bar', 'foo\nbar', re.S))
выводит:

None
<re.Match object; span=(0, 7), match='foo\nbar'>
<re.Match object; span=(0, 7), match='foo\nbar'>
Комбинация флагов
Мы можем использовать несколько флагов одновременно. Для этого нужно использовать оператор |.

Приведенный ниже код:

import re

match = re.search('^bar', 'FOO\nBAR\nBAZ', re.I | re.M)

print(match)
выводит:

<re.Match object; span=(4, 7), match='BAR'>
Оба флага IGNORECASE и MULTILINE были отработаны.

----------------------------------------------------------------------------------------------Функция escape()----------------------------------------------------------------------------
Функция escape() выполняет экранирование специальных символов в строке. Это полезно в ситуациях, когда регулярное выражение представляет из себя простую строку, которая может содержать метасимволы.

Аргументы функции:

pattern — шаблон регулярного выражения
Приведенный ниже код:

from re import escape

print(escape('http://www.stepik.org'))
выводит:

http://www\.stepik\.org
Функция escape() выполнила экранирование символа точки ..

Приведенный ниже код:

from re import escape

operators = ['+', '-', '*', '/', '**']
print(','.join(map(escape, operators)))
выводит:

\+,\-,\*,/,\*\*
Функция escape() выполнила экранирование всех арифметических операторов, кроме /.

-----------------------------------------------------------------------------------------------Функция findall()------------------------------------------------------------
Функция findall() возвращает все неперекрывающиеся совпадения с регулярным выражением в виде списка строк. Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.

Аргументы функции:

pattern — шаблон регулярного выражения
string — строка для поиска
flags=0 — один или несколько флагов (необязательный аргумент)
 Приведенный ниже код:

import re

text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = re.findall('\d+', text)

print(result)
выводит:

['25', '2', '69']
Если регулярное выражение содержит одну группу, то функция findall() вернет список соответствующих групп, а не список полных совпадений с регулярным выражением.

import re

result = re.findall('#(\w+)#', '#foo#.#bar#.#baz#')

print(result)
выводит:

['foo', 'bar', 'baz']
В этом примере регулярному выражению #(\w+)# соответствуют строки #foo#, #bar# и #baz#. Но символы решетки (#) не отображаются в возвращаемом списке, потому что они находятся за пределами групп.

Если регулярное выражение содержит несколько групп, то функция findall() вернет список кортежей, каждый из которых содержит захваченные группы. При этом длина каждого кортежа равна указанному количеству групп.

import re

result1 = re.findall('(\w+),(\w+)', 'foo,bar,baz,qux,quux,corge')
result2 = re.findall('(\w+),(\w+),(\w+)', 'foo,bar,baz,qux,quux,corge')

print(result1)
print(result2)
выводит:

[('foo', 'bar'), ('baz', 'qux'), ('quux', 'corge')]
[('foo', 'bar', 'baz'), ('qux', 'quux', 'corge')]
Обратите внимание на то, что группы, которые не смогли захватить какой-либо результат, также включаются в результирующий список.

Приведенный ниже код:

import re

result = re.findall('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(result)
выводит:

[('foo', 'bar', '')]

---------------------------------------------------------------------------------------------Функция finditer()-----------------------------------------------------------
Функция finditer() возвращает все неперекрывающиеся совпадения с регулярным выражением в виде итератора, содержащего объекты соответствия (тип Match).
Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.

Аргументы функции:

pattern — шаблон регулярного выражения
string — строка для поиска
flags=0 — один или несколько флагов (необязательный аргумент)
 Приведенный ниже код:

import re

text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = re.finditer('\d+', text)

print(type(result))
print(list(result))
выводит:

<class 'callable_iterator'>
[<re.Match object; span=(19, 21), match='25'>, <re.Match object; span=(30, 31), match='2'>, <re.Match object; span=(42, 44), match='69'>]
Приведенный ниже код:

import re

result = re.finditer('#(\w+)#', '#foo#.#bar#.#baz#')

for match in result:
    print(match)
    print(match.group(), match.group(1))
выводит:

<re.Match object; span=(0, 5), match='#foo#'>
#foo# foo
<re.Match object; span=(6, 11), match='#bar#'>
#bar# bar
<re.Match object; span=(12, 17), match='#baz#'>
#baz# baz
Функции findall() и finditer() очень похожи, но есть два отличия:

функция findall() возвращает список, в то время как функция finditer() возвращает итератор
функция findall() возвращает список, содержащий фактические строки, в то время как элементами итератора, который возвращает функция finditer(), являются объекты соответствия (тип Match)

-------------------------------------------------------------------------------------------Функция sub()--------------------------------------------------------------------------------------
Функция sub() возвращает строку, полученную путем замены всех найденных неперекрывающихся вхождений регулярного выражения pattern в строке string на строку замены repl.

Аргументы функции:

pattern — шаблон регулярного выражения
repl — строка замены
string — строка для поиска
count=0 — максимальное число замен (необязательный аргумент)
flags=0 — один или несколько флагов (необязательный аргумент)
   Если шаблон регулярного выражения не найден, строка возвращается без изменений.

Аргумент repl может быть строкой или функцией. Если repl это строка, то в ней обрабатываются все обратные слеши, то есть \n преобразуется в символ новой строки, \r преобразуется в возврат каретки и т. д.


import re
text = 'Java самый популярный язык программирования в 2022 году.'

res = re.sub(r'Java', r'Python', text)

print(res)
выводит:

Python самый популярный язык программирования в 2022 году.
Обратите внимание на то, что функция sub() создает и возвращает новую строку с указанными заменами. Исходная строка остается неизменной, ведь в Python строки неизменяемы по своей природе.

Рассмотрим подробнее ситуации, когда аргумент repl является строкой, а когда функцией.

Замена строкой
Если аргумент repl является строкой, то функция sub() вставляет ее в строку поиска string вместо любых последовательностей, соответствующих регулярному выражению regex.

Приведенный ниже код:

import re

text = 'foo.123.bar.456.baz.789.geek'

result1 = re.sub(r'\d+', r'#', text)
result2 = re.sub(r'[a-z]+', r'(*)', text)

print(result1)
print(result2)
выводит:

foo.#.bar.#.baz.#.geek
(*).123.(*).456.(*).789.(*)
Первый вызов функции sub() заменяет последовательность подряд идущих цифр на символ #. Второй вызов функции sub() заменяет последовательность подряд идущих строчных латинских букв на (*).

При использовании функции sub() мы также можем использовать пронумерованные обратные ссылки (\<n>) в аргументе repl, которым будет соответствовать текст захваченной группы. Обратные ссылки, такие как \2,
заменяются подстрокой, соответствующей группе №2 в шаблоне регулярного выражения.

Приведенный ниже код:

import re

result = re.sub(r'(\w+),bar,baz,(\w+)', r'\2,bar,baz,\1', r'foo,bar,baz,qux')

print(result)
выводит:

qux,bar,baz,foo
Захваченные группы \1 и \2 содержат foo и qux. В строке замены \2,bar,baz,\1, foo заменяет \1, а qux заменяет \2.

Мы также можем использовать именованные обратные ссылки, созданные с помощью уже знакомого нам синтаксиса (?P<name><regex>) в строке замены, используя последовательность метасимволов \g<name>.

Приведенный ниже код:

import re

result = re.sub(r'foo,(?P<w1>\w+),(?P<w2>\w+),qux', r'foo,\g<w2>,\g<w1>,qux', r'foo,bar,baz,qux')

print(result)
выводит:

foo,baz,bar,qux
Захваченные группы w1 и w2 содержат bar и baz. В строке замены foo,\g<w2>,\g<w1>,qux, bar заменяет \g<w1>, а baz заменяет \g<w2>.

Замена с помощью функции
Если в качестве аргумента repl использовать функцию, то функция sub() вызовет эту функцию для каждого найденного совпадения.
Она передает каждый соответствующий объект совпадения (тип Match) в качестве аргумента функции для предоставления информации о совпадении, при этом возвращаемое из функции значение становится строкой замены.

Приведенный ниже код:

import re
def func(match_obj):
    s = match_obj.group(0)         # строка совпадения
    if s.isdigit():
        return str(int(s) * 10)
    else:
        return s.upper()

result = re.sub(r'\w+', func, r'foo.10.bar.20.baz30.40')

print(result)
выводит:

FOO.100.BAR.200.BAZ30.400
В этом примере функция func() вызывается для каждого найденного совпадения. Таким образом, функция sub() преобразует каждую буквенно-цифровую часть строки в верхний регистр и умножает каждую числовую часть на 10.

Функция, передаваемая в качестве аргумента repl, должна принимать один аргумент — объект соответствия (тип Match) и возвращать строку замены.

Ограничение количества замен
Мы можем использовать необязательные аргументы count (количество замен) и flags для более детальной настройки замены.


import re

text = 'Java самый популярный язык программирования в 2022 году. Язык java — строго типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems.
Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация виртуальной Java-машины.'

res = re.sub(r'Java', r'Python', text, count=3, flags=re.I)

print(res)
выводит:

Python самый популярный язык программирования в 2022 году. Язык Python — строго типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems.
Приложения Python обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация виртуальной Java-машины.
Если необязательному аргументу count передать число, которое больше количества найденных вхождений в строке, то будет произведена замена всех этих вхождений.

---------------------------------------------------------------------------------------------Функция subn()---------------------------------------------------
Функция subn() идентична функции sub(), за тем исключением, что она возвращает кортеж, состоящий из измененной строки и количества сделанных замен.

Аргументы функции:

pattern — шаблон регулярного выражения
repl — строка замены
string — строка для поиска
count=0 — максимальное число замен (необязательный аргумент)
flags=0 — один или несколько флагов (необязательный аргумент)
Приведенный ниже код:

import re

text = 'foo.123.bar.456.baz.789.geek'

result1 = re.subn(r'\d+', r'#', text)
result2 = re.subn(r'[a-z]+', r'(*)', text, count=2)

print(result1)
print(result2)
выводит:

('foo.#.bar.#.baz.#.geek', 3)
('(*).123.(*).456.baz.789.geek', 2)
Приведенный ниже код:

import re
def func(match_obj):
    s = match_obj.group(0)         # строка совпадения
    if s.isdigit():
        return str(int(s) * 10)
    else:
        return s.upper()

result = re.subn(r'\w+', func, 'foo.10.bar.20.baz30.40')

print(result)
выводит:

('FOO.100.BAR.200.BAZ30.400', 6)


-----------------------------------------------------------------------------------------------------Функция split()-------------------------------------------------------------------
Как мы знаем, строковый тип данных str содержит метод split(), который разбивает строку текста на подстроки, используя в качестве разделителя переданную строку.


print('stepik beegeek       python'.split())             # по умолчанию разбиваем через пробельные символы
print('aaa,bbbb,ccccc'.split(','))
print('hello---world---from---beegeek'.split('---'))

выводит:

['stepik', 'beegeek', 'python']
['aaa', 'bbbb', 'ccccc']
['hello', 'world', 'from', 'beegeek']
В модуле re есть более мощная функция split(), работающая аналогичным образом.

Функция re.split() разбивает строку на подстроки, используя регулярное выражение в качестве разделителя, и возвращает подстроки в виде списка.

Аргументы функции:

pattern — шаблон регулярного выражения
string — строка для поиска
maxsplit=0 — максимальное количество разбиений (необязательный аргумент)
flags=0 — один или несколько флагов (необязательный аргумент)
Приведенный ниже код:

import re

result = re.split(r'[,;.]', 'foo,bar.baz;qux;stepik,beegeek')

print(result)
разбивает строку на подстроки, используя в качестве разделителя один из трех символов ,, ; или ., и выводит:

['foo', 'bar', 'baz', 'qux', 'stepik', 'beegeek']
Приведенный ниже код:

import re

result = re.split(r'\s*[,;.]\s*', 'foo,   bar. baz   ;    qux ;  stepik   ,   beegeek')

print(result)
разбивает строку на подстроки, используя в качестве разделителя один из трех символов ,, ; или ., окруженный любым количеством пробелов, и выводит:

['foo', 'bar', 'baz', 'qux', 'stepik', 'beegeek']
Если шаблон регулярного выражения содержит группы захвата, то возвращаемый список помимо подстрок также включает в себя эти группы.

Приведенный ниже код:

import re

result1 = re.split(r'\s*([,;.])\s*', 'foo,   bar. baz   ;    qux ;  stepik   ,   beegeek')
result2 = re.split(r'(\s*[,;.]\s*)', 'foo,   bar. baz   ;    qux ;  stepik   ,   beegeek')

print(result1)
print(result2)
выводит:

['foo', ',', 'bar', '.', 'baz', ';', 'qux', ';', 'stepik', ',', 'beegeek']
['foo', ',   ', 'bar', '. ', 'baz', '   ;    ', 'qux', ' ;  ', 'stepik', '   ,   ', 'beegeek']
Как мы видим, результирующий список result2 содержит не только подстроки, но и сами группы, соответствующие шаблону регулярного выражения:

',   '
'. '
'   ;    '
' ;  '
'   ,   '
Такое поведение может быть полезно, если мы хотим разделить строку на подстроки некоторыми разделителями, затем обработать все полученные подстроки,
а затем снова собрать строку вместе, используя те же разделители.


import re

string = 'foo,bar.baz;  qux;stepik,    beegeek'
regex = r'(\s*[,;.]\s*)'

result = re.split(regex, string)

for index, value in enumerate(result):
    if not re.fullmatch(regex, value):
        result[index] = f'[{value}]'

new_string = ''.join(result)

print(string)
print(new_string)
выводит:

foo,bar.baz;  qux;stepik,    beegeek
[foo],[bar].[baz];  [qux];[stepik],    [beegeek]
Если нам нужно использовать группы, но мы не хотим, чтобы разделители включались в результирующий список, то можно использовать группы без захвата, используя синтаксис (?:<regex>).

Приведенный ниже код:

import re

result = re.split(r'(?:\s*[,;.]\s*)', 'foo,   bar. baz   ;    qux ;  stepik   ,   beegeek')

print(result)
выводит:

['foo', 'bar', 'baz', 'qux', 'stepik', 'beegeek']
Ограничение количества разбиений
Мы можем использовать необязательный аргумент maxsplit для задания максимального количества разбиений строки.

Приведенный ниже код:

import re

text = 'foo; bar;   baz; qux;   stepik;    beegeek'
regex = r';\s*'

result1 = re.split(regex, text)
result2 = re.split(regex, text, maxsplit=2)
result3 = re.split(regex, text, maxsplit=4)

print(result1)
print(result2)
print(result3)
выводит:

['foo', 'bar', 'baz', 'qux', 'stepik', 'beegeek']
['foo', 'bar', 'baz; qux;   stepik;    beegeek']
['foo', 'bar', 'baz', 'qux', 'stepik;    beegeek']
Как мы видим, последний элемент в результирующем списке — это часть начальной строки, оставшаяся после того, как произошли все разбиения в заданном количестве maxsplit.

Явное указание maxsplit=0 эквивалентно его полному отсутствию. При этом если значение maxsplit является отрицательным числом, то функция re.split() возвращает исходную строку без изменений.

----------------------------------------------------------------------------------------Функция compile()------------------------------------------------------------------------------------
Модуль re поддерживает возможность предварительной компиляции регулярного выражения в специальный объект, который можно повторно использовать позже. Для этого используется функция compile().

Аргументы функции:

regex — шаблон регулярного выражения
flags=0 — один или несколько флагов (необязательный аргумент)
Существует два способа использования скомпилированного объекта регулярного выражения.

1 способ: мы можем его указать в качестве первого аргумента для функций модуля re, вместо шаблона регулярного выражения.

Приведенный ниже код:

import re

regex_obj = re.compile('\d+')
text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = re.findall(regex_obj, text)

print(result)
выводит:

['25', '2', '69']
 В общем случае:

import re

regex_obj = re.compile(<regex>, <flags>)
result = re.search(regex_obj, <string>)     # match(), fullmatch(), findall(), finditer()
2 способ: мы можем вызывать функции как методы непосредственно из объекта регулярного выражения.

Приведенный ниже код:

import re

regex_obj = re.compile('\d+')
text = 'ул. Часовая, дом № 25, корпус 2, квартира 69'
result = regex_obj.findall(text)

print(result)
выводит:

['25', '2', '69']
 В общем случае:

regex_obj = re.compile(<regex>, <flags>)
result = regex_obj.search(<string>)         # match(), fullmatch(), findall(), finditer()
Приведем пример с использованием флага.

Приведенный ниже код:

import re

regex_obj = re.compile('ba[rz]', flags=re.I)

result1 = re.search('ba[rz]', 'FOOBARBAZ', flags=re.I)
result2 = re.search(regex_obj, 'FOOBARBAZ')
result3 = regex_obj.search('FOOBARBAZ')

print(result1)
print(result2)
print(result3)
выводит:

<re.Match object; span=(3, 6), match='BAR'>
<re.Match object; span=(3, 6), match='BAR'>
<re.Match object; span=(3, 6), match='BAR'>
Как мы видим, все три объекта result1, result2 и result3 содержат одинаковые значения.

Возникает резонный вопрос: для чего нужна предварительная компиляция? Если мы часто используем одно и то же регулярное выражение,
то предварительная компиляция позволяет нам отделить определение регулярного выражения от его использования, что повышает читабельность кода.

В приведенном ниже коде:

import re

s1, s2, s3, s4 = 'foo.bar', 'foo123bar', 'baz99', 'qux & grault'

print(re.search('\d+', s1))
print(re.search('\d+', s2))
print(re.search('\d+', s3))
print(re.search('\d+', s4))
Регулярное выражение \d+ появляется несколько раз. Если в результате поддержки (изменения) кода, мы решим, что нам нужно другое регулярное выражение,
то нам нужно будет изменить его в каждом месте, что не очень удобно.

Приведенный ниже код, решает эту проблему, делая программный код более удобным в сопровождении:

import re

s1, s2, s3, s4 = 'foo.bar', 'foo123bar', 'baz99', 'qux & grault'

regex_obj = re.compile('\d+')

print(regex_obj.search(s1))
print(regex_obj.search(s2))
print(regex_obj.search(s3))
print(regex_obj.search(s4))
Методы скомпилированного объекта регулярного выражения
Скомпилированный объект регулярного выражения поддерживает следующие методы:

search(string, pos, endpos)
match(string, pos, endpos)
fullmatch(string, pos, endpos)
findall(string, pos, endpos)
finditer(string, pos, endpos)
Данные методы ведут себя так же, как соответствующие (одноименные) им функции модуля re, за исключением того, что они также поддерживают необязательные аргументы pos и endpos.

Если аргументы pos и endpos переданы, то поиск применяется только к части строки string, от pos (включительно), до endpos (не включительно), подобно индексам в срезах.

Приведенный ниже код:

import re

regex_obj = re.compile('\d+')
text = 'foo12345barbaz'

print(regex_obj.search(text))
print(regex_obj.search(text, pos=4))
print(regex_obj.search(text, endpos=7))
print(regex_obj.search(text, pos=4, endpos=7))
выводит:

<re.Match object; span=(3, 8), match='12345'>
<re.Match object; span=(4, 8), match='2345'>
<re.Match object; span=(3, 7), match='1234'>
<re.Match object; span=(4, 7), match='234'>
Если указать pos, но опустить endpos, то поиск будет применяться к подстроке от pos до конца строки. Аналогично, если указать endpos,
но опустить pos, то поиск будет применяться к подстроке от начала строки до endpos.

