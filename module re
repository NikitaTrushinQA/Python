                                                                                                  Модуль re
В Python для работы с регулярными выражениями используется встроенный модуль re.
Для начала работы с ним его нужно импортировать:
import re

------------------------------------------------------------------------------------------------------Функция search()---------------------------------------------------------------------------
Функция search() сканирует строку в поисках первого совпадения с регулярным выражением и возвращает специальный объект соответствия (тип Match) или значение None,
если ни одна позиция в строке не соответствует регулярному выражению. 

Аргументы функции:

      pattern — шаблон регулярного выражения
      string — строка для поиска
      flags=0 — один или несколько флагов (необязательный аргумент)


from re import search
match1 = search('super', 'superstition')
match2 = search('super', 'insuperable')
match3 = search('super', 'without')

print(match1)                         <re.Match object; span=(0, 5), match='super'>
print(match2)                         <re.Match object; span=(2, 7), match='super'>
print(match3)                         None

---------------------------------------------------------------------------------------------Функция match()-------------------------------------------------------------------------------------------
Функция match() возвращает специальный объект соответствия (тип Match), если НАЧАЛО СТРОКИ соответствуют регулярному выражению, или значение None в противном случае.

Аргументы функции:

      pattern — шаблон регулярного выражения
      string — строка для поиска
      flags=0 — один или несколько флагов (необязательный аргумент)

from re import match
match1 = match('super', 'superstition')
match2 = match('super', 'insuperable')

print(match1)                <re.Match object; span=(0, 5), match='super'>
print(match2)                None

-----------------------------------------------------------------------------------------Функция fullmatch()------------------------------------------------------------------
Функция fullmatch() возвращает специальный объект соответствия (тип Match), если ВСЯ СТРОКА соответствует регулярному выражению, или значение None в противном случае.
Аргументы функции:

        pattern — шаблон регулярного выражения
        string — строка для поиска
        flags=0 — один или несколько флагов (необязательный аргумент)

from re import fullmatch

match1 = fullmatch('\d+', '123foo')                   
match2 = fullmatch('\d+', 'foo123')                   
match3 = fullmatch('\d+', 'foo123bar')               
match4 = fullmatch('\d+', '123')                      

print(match1)                               None
print(match2)                               None
print(match3)                               None
print(match4)                               <re.Match object; span=(0, 3), match='123'>

Функцию fullmatch() удобно использовать для валидации правильности данных.


from re import fullmatch
phone_pattern = '\d{3}-\d{3}-\d{4}'

match1 = fullmatch(phone_pattern , '777-888-1234')
match2 = fullmatch(phone_pattern , '77-89-56')
match3 = fullmatch(phone_pattern , '5555-99-1234')
match4 = fullmatch(phone_pattern , '123-000-3333ab')

проверяет соответствие строк регулярному выражению ddd-ddd-dddd (три цифры дефис три цифры дефис четыре цифры) и выводит:

print(match1)                 <re.Match object; span=(0, 12), match='777-888-1234'>
print(match2)                 None
print(match3)                 None
print(match4)                 None

----------------------------------------------------------------------------------------------------------------Объекты типа Match---------------------------------------------------------------------------------

Все три рассмотренные функции search(), match(), fullmatch() при успешном соответствии регулярному выражению возвращают объект типа Match.
Объекты такого типа приводятся к типу bool автоматически, поэтому мы можем использовать их в условном операторе.

from re import search, fullmatch

match = fullmatch('\d{3}-\d{3}-\d{4}', '777-888-1234')

if match:
    print('Строка соответствует формату.')
    print(match)
else:
    print('Строка не соответствует формату.')

выводит:
Строка соответствует формату.
<re.Match object; span=(0, 12), match='777-888-1234'>

---------------------------------------------------------------------------------------------------------------------Метод group()-------------------------------------------------------------------------------------
Метод group() возвращает одну или несколько подгрупп совпадения. Если метод вызывается без аргументов, то возвращается вся подстрока, которая совпала с шаблоном регулярного выражения.

Приведенный ниже код:

from re import search

match = search('(\w+),(\w+),(\w+)', 'foo,bar,baz')

print(match.group())                       # вся строка          foo,bar,baz
print(match.group(0))                      # вся строка          foo,bar,baz
print(match.group(1))                      # подгруппа           foo
print(match.group(2))                      # подгруппа           bar
print(match.group(3))                      # подгруппа           baz
print(match.group(1, 2, 3))                # кортеж              ('foo', 'bar', 'baz')

Если методу group() передать индекс несуществующей группы, то будет возбуждено исключение.  (IndexError: no such group)

Если мы пользуемся именованными группами, используя синтаксис (?P<name><regex>), тогда мы можем использовать название группы в качестве аргумента метода group().

from re import search
match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,bar,baz')

print(match.group())                                          foo,bar,baz
print(match.group('w1'))                                      foo
print(match.group('w2'))                                      bar
print(match.group('w3'))                                      baz
print(match.group('w1', 'w2', 'w3', 'w2', 'w3'))              ('foo', 'bar', 'baz', 'bar', 'baz')

Обратите внимание на то, что метод group() может возвращать в качестве группы значение None. Так происходит в ситуации, когда группа не участвует в сопоставлении.


from re import search
match = search('(\w+),(\w+),(\w+)?', 'foo,bar,')

print(match.group())            foo,bar,
print(match.group(0))           foo,bar,
print(match.group(1))           foo
print(match.group(2))           bar
print(match.group(3))           None
print(match.group(1, 2, 3))     ('foo', 'bar', None)

-------------------------------------------------------------------------------------------------------Метод groupdict()--------------------------------------------------------------
Метод groupdict() возвращает словарь, содержащий все захваченные именованные группы.


from re import search
match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)', 'foo,bar,baz')

print(match.groupdict())

выводит:
{'w1': 'foo', 'w2': 'bar', 'w3': 'baz'}

Метод groupdict(), как и метод groups(), принимает необязательный аргумент default, который используется для указания значений групп, которые не смогли захватить какой либо результат.
По умолчанию значение данного аргумента равно None.

Приведенный ниже код:

from re import search

match = search('(?P<w1>\w+),(?P<w2>\w+),(?P<w3>\w+)?', 'foo,bar,')

print(match.groupdict())
print(match.groupdict(default=''))
print(match.groupdict(default='----'))

выводит:
{'w1': 'foo', 'w2': 'bar', 'w3': None}
{'w1': 'foo', 'w2': 'bar', 'w3': ''}
{'w1': 'foo', 'w2': 'bar', 'w3': '----'}

Если именованных групп в исходном регулярном выражении нет, метод groupdict() возвращает пустой словарь.

-----------------------------------------------------------------------------------------------------Методы start() и end()-------------------------------------------------------------------------

Методы start() и end() возвращают индексы начала и конца подстроки, которая совпала с регулярным выражением.

Приведенный ниже код:

from re import search

match = search('\d+', 'foo123bar456baz')

print(match)                        <re.Match object; span=(3, 6), match='123'>
print(match.start())                3
print(match.end())                  6

В методы start() и end() также можно передать номер или названия группы. В этом случае методы вернут индексы начала и конца подстроки, совпадающей с нужной группой.

Приведенный ниже код:

from re import search

text = 'foo123bar456baz'

match = search('(\d+)\D+(?P<num>\d+)', text)

print(match)
print(match.group(), match.start(), match.end())
print(match.group(1), match.start(1), match.end(1))
print(match.group('num'), match.start('num'), match.end('num'))
выводит:

<re.Match object; span=(3, 12), match='123bar456'>
123bar456 3 12
123 3 6
456 9 12

--------------------------------------------------------------------------------------------------------Метод span()-------------------------------------------------

Метод span() возвращает индексы начала и конца подстроки в виде кортежа, которая совпала с регулярным выражением.
В метод span() также можно передать номер или название группы. В этом случае метод вернет индексы начала и конца подстроки в виде кортежа, совпадающей с нужной группой.

Приведенный ниже код:

from re import search

match = search('(\d+)\D+(?P<num>\d+)', 'foo123bar456baz')

print(match)                                     <re.Match object; span=(3, 12), match='123bar456'>
print(match.span())                              (3, 12)
print(match.span(1))                             (3, 6)
print(match.span('num'))                         (9, 12)

-------------------------------------------------------------------------------------------------------Флаги------------------------------------------------------------------------------
Все три рассмотренные функции search(), match(), fullmatch() принимают необязательный аргумент flags.
Использование флагов изменяет поведение синтаксического анализа регулярных выражений, позволяя еще больше уточнить сопоставление с образцом. Функциональность регулярных выражений расширяется за счет флагов.

Короткое имя	              Полное имя	            Назначение
 re.I	                    re.IGNORECASE	            игнорирует регистр символов
 re.M	                    re.MULTILINE	            используется совместно с метасимволами ^ и $, в первом случае возвращает совпадения в начале каждой новой строки \n, во втором – в конце \n
 re.S	                    re.DOTALL	                заставляет метасимвол . возвращать совпадения по абсолютно всем символам, включая \n
 re.X	                    re.VERBOSE	              разрешает комментарии в регулярном выражении
 -	                      re.DEBUG	                показывает отладочную информацию о скомпилированном регулярном выражении
 re.A	                    re.ASCII	                указывает кодировку ASCII для классификации символов \w, \W, \b, \B, \d, \D, \s, \S
 re.U	                    re.UNICODE	              указывает кодировку Unicode для классификации символов  \w, \W, \b, \B, \d, \D, \s, \S
 re.L	                    re.LOCALE	                учитывает региональные настройки при использовании метасимволов \w, \W, \b, \B, \s, \S

Наиболее часто используемые флаги:

re.IGNORECASE
re.MULTILINE
re.DOTALL

----------------------------------------------------------------------------------------Флаг re.IGNORECASE--------------------------------------------------------------
Флаг re.IGNORECASE (re.I) выполняет сопоставление без учета регистра.
import re
match1 = re.search('a+', 'aaaAAA')
match2 = re.search('A+', 'aaaAAA')
match3 = re.search('a+', 'aaaAAA', re.IGNORECASE)
match4 = re.search('A+', 'aaaAAA', re.I)

print(match1)
print(match2)
print(match3)
print(match4)
выводит:

<re.Match object; span=(0, 3), match='aaa'>
<re.Match object; span=(3, 6), match='AAA'>
<re.Match object; span=(0, 6), match='aaaAAA'>
<re.Match object; span=(0, 6), match='aaaAAA'>

При первом поиске регулярному выражению a+ соответствует только первые три символа строки аааААА.
При втором поиске регулярному выражению A+ соответствуют три последних символа.
При третьем и четвертом поисках мы используем флаг re.IGNORECASE (re.I), поэтому синтаксический анализатор игнорирует регистр, и регулярным выражениям a+ и А+ соответствует вся строка.

import re
match1 = re.search('[a-z]+', 'aBcDeF')
match2 = re.search('[a-z]+', 'aBcDeF', re.I)

print(match1)
print(match2)
выводит:

<re.Match object; span=(0, 1), match='a'>
<re.Match object; span=(0, 6), match='aBcDeF'>

При отсутствии флага регулярному выражению [a-z]+ в строке aBcDeF соответствует только первый символ a.
Указание флага re.I делает поиск нечувствительным к регистру, поэтому регулярному выражению [a-z]+ соответствует вся строка.

----------------------------------------------------------------------------------------------Флаг re.MULTILINE----------------------------------------------------------------------

По умолчанию метасимволы ^ и $ совпадают только с началом и концом всей строки, не учитывая наличие в строке символов \n.

import re
text = 'foo\nbar\nbaz'

print(re.search('^foo', text))
print(re.search('^bar', text))
print(re.search('^baz', text))
print(re.search('foo$', text))
print(re.search('bar$', text))
print(re.search('baz$', text))
выводит:

<re.Match object; span=(0, 3), match='foo'>
None
None
None
None
<re.Match object; span=(8, 11), match='baz'>

Несмотря на то что строка  'foo\nbar\nbaz' содержит символы новой строки \n, мы получили только соответствие регулярному выражению ^foo и baz$.

Использование флага re.MULTILINE позволяет правильным образом обрабатывать символы \n, тем самым находя начала и концы всех строк с учетом символа \n.

Приведенный ниже код:

import re

text = 'foo\nbar\nbaz'

print(re.search('^foo', text, re.MULTILINE))
print(re.search('^bar', text, re.MULTILINE))
print(re.search('^baz', text, re.MULTILINE))
print(re.search('foo$', text, re.M))
print(re.search('bar$', text, re.M))
print(re.search('baz$', text, re.M))
выводит:

<re.Match object; span=(0, 3), match='foo'>
<re.Match object; span=(4, 7), match='bar'>
<re.Match object; span=(8, 11), match='baz'>
<re.Match object; span=(0, 3), match='foo'>
<re.Match object; span=(4, 7), match='bar'>
<re.Match object; span=(8, 11), match='baz'>
------------------------------------------------------------------------------------------------Флаг re.DOTALL---------------------------------------------------------------
Флаг re.DOTALL (re.S) делает так, чтобы метасимвол . соответствовал любому символу, включая символ новой строки \n. Без этого флага метасимвол . соответствует любому символу, кроме новой строки.

import re
print(re.search('foo.bar', 'foo\nbar'))
print(re.search('foo.bar', 'foo\nbar', re.DOTALL))
print(re.search('foo.bar', 'foo\nbar', re.S))
выводит:

None
<re.Match object; span=(0, 7), match='foo\nbar'>
<re.Match object; span=(0, 7), match='foo\nbar'>
Комбинация флагов
Мы можем использовать несколько флагов одновременно. Для этого нужно использовать оператор |.

Приведенный ниже код:

import re

match = re.search('^bar', 'FOO\nBAR\nBAZ', re.I | re.M)

print(match)
выводит:

<re.Match object; span=(4, 7), match='BAR'>
Оба флага IGNORECASE и MULTILINE были отработаны.

----------------------------------------------------------------------------------------------Функция escape()----------------------------------------------------------------------------
Функция escape() выполняет экранирование специальных символов в строке. Это полезно в ситуациях, когда регулярное выражение представляет из себя простую строку, которая может содержать метасимволы.

Аргументы функции:

pattern — шаблон регулярного выражения
Приведенный ниже код:

from re import escape

print(escape('http://www.stepik.org'))
выводит:

http://www\.stepik\.org
Функция escape() выполнила экранирование символа точки ..

Приведенный ниже код:

from re import escape

operators = ['+', '-', '*', '/', '**']
print(','.join(map(escape, operators)))
выводит:

\+,\-,\*,/,\*\*
Функция escape() выполнила экранирование всех арифметических операторов, кроме /.
