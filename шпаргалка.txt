                                                           "Функции и методы строк"
Функция или метод	                               
S = 'str'; S = "str"; S = '''str'''; S = """str"""	Литералы строк
S = "s\np\ta\nbbb"	Экранированные последовательности
S = r"C:\temp\new"	Неформатированные строки (подавляют экранирование)
S = b"byte"	Строка байтов
S1 + S2	Конкатенация (сложение строк)
S1 * 3	Повторение строки
S[i]	Обращение по индексу
S[i:j:step]	Извлечение среза
len(S)	Длина строки
S.find(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или -1
S.rfind(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
S.index(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
S.rindex(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
S.replace(шаблон, замена[, maxcount])	Замена шаблона на замену. maxcount ограничивает количество замен
S.split(символ)	Разбиение строки по разделителю
S.isdigit()	Состоит ли строка из цифр
S.isalpha()	Состоит ли строка из букв
S.isalnum()	Состоит ли строка из цифр или букв
S.islower()	Состоит ли строка из символов в нижнем регистре
S.isupper()	Состоит ли строка из символов в верхнем регистре
S.isspace()	Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'),
"горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
S.istitle()	Начинаются ли слова в строке с заглавной буквы
S.upper()	Преобразование строки к верхнему регистру
S.lower()	Преобразование строки к нижнему регистру
S.startswith(str)	Начинается ли строка S с шаблона str
S.endswith(str)	Заканчивается ли строка S шаблоном str
S.join(список)	Сборка строки из списка с разделителем S
ord(символ)	Символ в его код ASCII
chr(число)	Код ASCII в символ
S.capitalize()	Переводит первый символ строки в верхний регистр, а все остальные в нижний
S.center(width, [fill])	Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
S.count(str, [start],[end])	Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
S.expandtabs([tabsize])	Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца.
Если TabSize не указан, размер табуляции полагается равным 8 пробелам
S.lstrip([chars])	Удаление пробельных символов в начале строки
S.rstrip([chars])	Удаление пробельных символов в конце строки
S.strip([chars])	Удаление пробельных символов в начале и в конце строки
S.partition(шаблон)	Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
S.rpartition(sep)	Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку
S.swapcase()	Переводит символы нижнего регистра в верхний, а верхнего – в нижний
S.title()	Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
S.zfill(width)	Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
S.ljust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
S.rjust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
S.format(*args, **kwargs)	Форматирование строки                                                                       
                                                                                                                                                                        
                                                                        zfill()
Метод zfill() Метод zfill() возвращает копию строки с заполненным 0 слева. 
Длина возвращаемой строки зависит от предоставленной ширины 

str.zfill(width)

Если строка начинается с префикса знака (‘+’, ‘-‘), 0 цифр заполняется после первого символа префикса знака.
number = "-290" print(number.zfill(8))        ==> -0000290

                                                                 метод compress()
Метод compress() модуля itertools создает итератор, который фильтрует элементы из данных s,возвращая только те,
которые имеют соответствующий элемент, равный True или 1 в последовательности lst.

from itertools import compress
s = 'abcd'
lst = [1,0,1,0]
rez = compress(s, lst)
print(list(rez)  =====> ['a','c']
           
                                                                   "Функции и методы списков"
list.append(x)	Добавляет элемент в конец списка
list.extend(L)	Расширяет список list, добавляя в конец все элементы списка L
list.insert(i, x)	Вставляет на i-ый элемент значение x
list.remove(x)	Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует
list.pop([i])	Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент
list.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)
list.count(x)	Возвращает количество элементов со значением x
list.sort([key=функция])	Сортирует список на основе функции
list.reverse()	Разворачивает список
list.copy()	Поверхностная копия списка
list.clear()	Очищает список

                                                                      Методы словарей
dict.clear() - очищает словарь.

dict.copy() - возвращает копию словаря.

classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

dict.items() - возвращает пары (ключ, значение).

dict.keys() - возвращает ключи в словаре.

dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.

dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).

dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

dict.values() - возвращает значения в словаре.
                                                           операции множеств
С множествами можно выполнять множество операций: находить объединение, пересечение...

len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
И операции, непосредственно изменяющие множество:

set.update(other, ...); set |= other | ... - объединение.
set.intersection_update(other, ...); set &= other & ... - пересечение.
set.difference_update(other, ...); set -= other | ... - вычитание.
set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в множестве.
set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
set.clear() - очистка множества.

                                                      Список методов модуля random в Python:

Метод	            Описание
seed()	Инициализация генератора случайных чисел
getstate()	Возвращает текущее внутренне состояние (state) генератора случайных чисел
setstate()	Восстанавливает внутреннее состояние (state) генератора случайных чисел
getrandbits()	Возвращает число, которое представляет собой случайные биты
randrange()	Возвращает случайное число в пределах заданного промежутка
randint()	Возвращает случайное число в пределах заданного промежутка
choice()	Возвращает случайный элемент заданной последовательности
choices()	Возвращает список со случайной выборкой из заданной последовательности
shuffle()	Берет последовательность и возвращает ее в перемешанном состоянии
sample()	Возвращает заданную выборку последовательности
random()	Возвращает случайное вещественное число в промежутке от 0 до 1
uniform()	Возвращает случайное вещественное число в указанном промежутке
triangular()	Возвращает случайное вещественное число в промежутке между двумя заданными параметрами. Также можно использовать параметр mode для уточнения середины между указанными параметрами
betavariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Бета-распределении, которое используется в статистике
expovariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, или же между 0 и -1, когда параметр отрицательный. За основу берется Экспоненциальное распределение, которое используется в статистике
gammavariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Гамма-распределении, которое используется в статистике
gauss()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Гауссовом распределении, которое используется в теории вероятности
lognormvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Логнормальном распределении, которое используется в теории вероятности
normalvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Нормальном распределении, которое используется в теории вероятности
vonmisesvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении фон Мизеса, которое используется в направленной статистике
paretovariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении Парето, которое используется в теории вероятности
weibullvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении Вейбулла, которое используется в статистике
                                                  Модуль queue, очереди в Python(FIFO,LIFO)
Модуль реализует три типа очереди, которые отличаются только порядком, в котором извлекаются записи:
1)В очереди FIFO первые добавленные задачи являются первыми извлеченными.
2)В очереди LIFO самая последняя добавленная запись является первой извлеченной (работающей как стек).
3)В очереди с приоритетами записи сохраняются отсортированными с использованием модуля heapq и сначала извлекается запись с наименьшим значением.

    Очередь FIFO:
Класс queue.Queue() реализует базовый контейнер типа FIFO - "первым пришел - первым вышел".
Элементы добавляются к одному концу очереди с помощью метода put(), а удаляются с другого конца с помощью метода get().
import queue
q = queue.Queue()
for i in range(5):
    q.put(i)
while not q.empty():
    print(q.get(), end=' ')

# 0 1 2 3 4

       Очередь LIFO:
В отличие от стандартной реализации очереди FIFO, в queue.LifoQueue() используется порядок "последним пришел - первым вышел",
который обычно связан со структурой данных стека.
import queue
q = queue.LifoQueue()
for i in range(5):
    q.put(i)
while not q.empty():
    print(q.get(), end=' ')

# 4 3 2 1 0

        Очередь с приоритетом:
Иногда порядок обработки элементов в очереди должен основываться на характеристиках этих элементов, а не только на порядке их создания или добавления в очередь. Например, задания на печать из финансового отдела могут иметь приоритет над списком заданий из отдела технической поддержки.
Класс модуля queue.PriorityQueue() использует порядок сортировки содержимого очереди, чтобы решить, какой элемент получить.
import functools
import queue
import threading


@functools.total_ordering
class Job:

    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        return

    def __eq__(self, other):
        try:
            return self.priority == other.priority
        except AttributeError:
            return NotImplemented

    def __lt__(self, other):
        try:
            return self.priority < other.priority
        except AttributeError:
            return NotImplemented

def process_job(q):
    while True:
        next_job = q.get()
        print('Processing job:', next_job.description)
        q.task_done()

q = queue.PriorityQueue()
q.put(Job(3, 'Mid-level'))
q.put(Job(10, 'Low-level'))
q.put(Job(1, 'Important'))

workers = [
    threading.Thread(target=process_job, args=(q,)),
    threading.Thread(target=process_job, args=(q,)),
]
for w in workers:
    w.setDaemon(True)
    w.start()

q.join()

                                                                date и time

%a	Сокращенное название дня недели	Sun, Mon, …, Sat (en_US) Пн, Вт, ..., Вс (ru_RU)
%A	Полное название дня недели	Sunday, Monday, …, Saturday (en_US) понедельник, ..., воскресенье (ru_RU)
%w	Номер дня недели [0, …, 6]	0, 1, …, 6 (0=воскресенье, 6=суббота)
%d	День месяца [01, …, 31]	01, 02, …, 31
%b	Сокращенное название месяца	Jan, Feb, …, Dec (en_US); янв, ..., дек (ru_RU)
%B	Полное название месяца	January, February, …, December (en_US); Январь, ..., Декабрь (ru_RU)
%m	Номер месяца [01, …,12]	01, 02, …, 12
%y	Год без века [00, …, 99]	00, 01, …, 99
%Y	Год с веком	0001, 0002, …, 2013, 2014, …, 9999 В Linux год выводится без ведущих нулей: 1, 2, …, 2013, 2014, …, 9999
%H	Час (24-часовой формат) [00, …, 23]	00, 01, …, 23
%I	Час (12-часовой формат) [01, …, 12]	01, 02, …, 12
%p	До полудня или после (при 12-часовом формате)	AM, PM (en_US)
%M	Число минут [00, …, 59]	00, 01, …, 59
%S	Число секунд [00, …, 59]	00, 01, …, 59
%f	Число микросекунд	000000, 000001, …, 999999
%z	Разница с UTC в формате ±HHMM[SS[.ffffff]]	+0000, -0400, +1030, +063415, ...
%Z	Временная зона	UTC, EST, CST
%j	День года [001,366]	001, 002, …, 366
%U	Номер недели в году      (нулевая неделя начинается с воскр.) [00, …, 53]   00, 01, …, 53
%W	 Номер недели в году      (нулевая неделя начинается с пон.) [00, …, 53]    00, 01, …, 53
%c	Дата и время	Tue Aug 16 21:30:00 1988 (en_US);             03.01.2019 23:18:32 (ru_RU)
%x	Дата	08/16/88 (None); 08/16/1988 (en_US);                03.01.2019 (ru_RU)
%X	Время	21:30:00

пример:
from datetime import date, time
my_date = date(2021, 8, 10)
my_time = time(7, 18, 34)
print(my_date.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))
print(my_time.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))
выводит:
Tue Tuesday 2 10 Aug August 08 21 2021 00 12 AM 00 00 000000   222 32 32 Tue Aug 10 00:00:00 2021 08/10/21 00:00:00
Mon Monday 1 01 Jan January 01 00 1900 07 07 AM 18 34 000000   001 00 01 Mon Jan  1 07:18:34 1900 01/01/00 07:18:34

                                                              Использование локализации
Для того чтобы использовать конкретную локализацию (перевод на язык), нужно использовать модуль locale.
Приведенный ниже код устанавливает русскую локализацию:
from datetime import date
import locale

locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
my_date = date(2021, 8, 10)
print(my_date.strftime("%A %d, %B %Y"))    # форматированный вывод даты в русской локализации

и выводит:
вторник 10, Август 2021


Для установки английской локализации используется код:

import locale

locale.setlocale(locale.LC_ALL, 'en_EN.UTF-8')
                                                                    
                                         isoformat() (Для того, чтобы получить строковое представление объектов типаdate и time в ISO формате)

from datetime import date, time

my_date = date(2021, 12, 31)
my_time = time(21, 15, 17)

print('Дата: ' + my_date.isoformat())
print('Время: ' + my_time.isoformat())

выводит:
Дата: 2021-12-31
Время: 21:15:17
                                                                          Тип данных datetime
ри создании новой даты-времени (тип datetime) нужно указать год, месяц, день, часы, минуты, секунды и микросекунды. При этом год, месяц и день являются обязательными, а часы, минуты, секунды и микросекунды необязательными.
доступ:
year — год
month — месяц
day — день
hour — час
minute — минуты
second — секунды
microsecond — микросекунды
                                       Методы combine(), date(), time()
Сформировать новый объект типа datetime можно с помощью двух разных объектов, представляющих дату и время (date и time). Для этого используется метод combine().

from datetime import date, time, datetime
my_date = date(1992, 10, 6)
my_time = time(10, 45, 17)
my_datetime = datetime.combine(my_date, my_time)

print(my_datetime)
выводит:
1992-10-06 10:45:17

Если, наоборот, нужно получить из даты-времени (тип datetime) по отдельности дату (тип date) и время (тип time), то используются методы date() и time() соответственно.
Приведенный ниже код:

from datetime import date, time, datetime
my_datetime = datetime(2022, 10, 7, 14, 15, 45)
my_date = my_datetime.date()                     # получаем только дату (тип date)
my_time = my_datetime.time()                     # получаем только время (тип time)

print(my_datetime, type(my_datetime))
print(my_date, type(my_date))
print(my_time, type(my_time))
выводит:

2022-10-07 14:15:45 <class 'datetime.datetime'>
2022-10-07 <class 'datetime.date'>
14:15:45 <class 'datetime.time'>

                                                      Методы now(), utcnow(), today()
Для того, что получить текущее время на момент исполнения программы, используются методы now() и utcnow() для локального и 
UTC(Всемирное координированное время (Coordinated Universal Time, UTC) — стандарт, по которому общество регулирует часы и время. Московское время соответствует UTC+3) времени соответственно.

Приведенный ниже код:

from datetime import datetime

datetime_now = datetime.now()
datetime_utcnow = datetime.utcnow()

print(datetime_now)           # текущее локальное время (московское) на момент запуска программы
print(datetime_utcnow)        # текущее UTC время на момент запуска программы
выводит:

2021-08-13 08:03:43.224568
2021-08-13 05:03:43.224568

Метод today() аналогичен методу now(). Для получения локальной даты-времени рекомендуется использовать именно метод now().

                                     Метод timestamp(),Метод fromtimestamp()
Метод timestamp() позволяет преобразовать объект типа datetime в количество секунд, прошедших с момента начала эпохи.
Данный метод возвращает значение типа float.(Начало эпохи — это полночь 1 января 1970 года (00:00:00 UTC))

from datetime import datetime
my_datetime = datetime(2021, 10, 13, 8, 10, 23)
print(my_datetime.timestamp())

выводит:
1634101823.0

Метод fromtimestamp() позволяет преобразовать количество секунд, прошедших с момента начала эпохи, в объект типа datetime.
Данный метод является обратным по отношению к методу timestamp().

from datetime import datetime
my_datetime = datetime.fromtimestamp(1634101823.0)
print(my_datetime)
выводит:

2021-10-13 08:10:23
                                                    Форматирование даты-времени
                                                    
Чтобы преобразовать дату-время в строку нужного формата, следует воспользоваться методом strftime(), указав ему в качестве аргумента параметры форматирования.

from datetime import datetime

my_datetime = datetime(2021, 8, 10, 18, 20, 34)

print(my_datetime)                                            # вывод в ISO формате
print(my_datetime.strftime('%d.%m.%y --- %H::%M::%S'))
print(my_datetime.strftime('%d/%m/%y'))
print(my_datetime.strftime('%A %d, %B %Y'))
print(my_datetime.strftime('%H:%M:%S'))
выводит

2021-08-10 18:20:34
10.08.21 --- 18::20::34
10/08/21
Tuesday 10, August 2021
18:20:34
                                                 strptime() 
strptime(), который преобразует строку (первый аргумент) в объект datetime согласно переданному формату (второй аргумент)
Приведенный ниже код:

from datetime import datetime

datetime0 = datetime.strptime('10.08.2034 13:55:59', '%d.%m.%Y %H:%M:%S')
datetime1 = datetime.strptime('10/08/21', '%d/%m/%y')
datetime2 = datetime.strptime('Tuesday 10, August 2021', '%A %d, %B %Y')
datetime3 = datetime.strptime('18.20.34', '%H.%M.%S')
datetime4 = datetime.strptime('2021/08/10', '%Y/%m/%d')
datetime5 = datetime.strptime('10.08.2021 (Tuesday, August)', '%d.%m.%Y (%A, %B)')
datetime6 = datetime.strptime('Year: 2021, Month: 08, Day: 10, Hour: 18.', 'Year: %Y, Month: %m, Day: %d, Hour: %H.')

print(datetime0, datetime1, datetime2, datetime3, datetime4, datetime5, datetime6, sep='\n')
выводит:

2034-08-10 13:55:59
2021-08-10 00:00:00
2021-08-10 00:00:00
1900-01-01 18:20:34
2021-08-10 00:00:00
2021-08-10 00:00:00
2021-08-10 18:00:00
                                                                  Тип данных timedelta
 Тип данных timedelta представляет из себя временной интервал (разница между двумя объектами datetime или date) и используется для удобного выполнения различных манипуляций над типами datetime или date.

При создании объекта timedelta можно указать следующие аргументы:

недели (weeks)
дни (days)
часы (hours)
минуты (minutes)
секунды (seconds)
микросекунды (microseconds)
миллисекунды (milliseconds)

Мы можем выбрать любые их сочетания для задания временного интервала, при этом все аргументы являются необязательными и по умолчанию равны 0.

Аргументы могут быть целыми числами или числами с плавающей запятой, а также могут быть как положительными, так и отрицательными. Используйте именованные аргументы, вместо позиционных, чтобы избежать ошибок.

Тип timedelta внутренне хранит только сочетание days, seconds, microseconds, а остальные переданные в конструктор аргументы конвертируются в эти единицы:

millisecond преобразуется в 1000 microseconds
minutes преобразуется в 60 seconds
hours преобразуется в3600 seconds
weeks преобразуется в 7 days

В следующем примере показано, как любые аргументы, кроме days, seconds, microseconds, объединяются и нормализуются в три результирующих сочетания.

Приведенный ниже код:

from datetime import timedelta

delta1 = timedelta(days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2)  ==>64 days, 8:05:56.000010
delta2 = timedelta(weeks=1, hours=23, minutes=61)                                                          ==>8 days, 0:01:00
delta3 = timedelta(hours=25)                                                                               ==>1 day, 1:00:00
delta4 = timedelta(minutes=300)                                                                            ==>5:00:00

 у типа timedelta нет атрибутов hours и minutes, позволяющих получить количество часов и минут соответственно.
 Достать часы и минуты можно так:
 def hours_minutes(td):
    return td.seconds // 3600, (td.seconds // 60) % 60
Приведенный ниже код:

from datetime import timedelta

def hours_minutes(td):
    return td.seconds // 3600, (td.seconds // 60) % 60

delta = timedelta(days=7, seconds=125, minutes=10, hours=8, weeks=2)

hours, minutes = hours_minutes(delta)

print(delta)
print(hours)
print(minutes)
выводит:

21 days, 8:12:05
8
12
                   Сравнение временных интервалов
Временные интервалы (тип timedelta) можно сравнивать (==, !=, <, >, <=, >=), как и любые другие типы данных.
from datetime import timedelta

delta1 = timedelta(weeks=1)
delta2 = timedelta(hours=24*7)
delta3 = timedelta(minutes=24*7*59)

print(delta1 == delta2)         #True
print(delta1 != delta3)        #True
print(delta1 < delta3)         #False

               Сумма и разность временных интервалов
from datetime import timedelta

delta1 = timedelta(days=5) + timedelta(seconds=3600)  # 5 дней + 1 час
delta2 = timedelta(days=5) - timedelta(seconds=3600)  # 5 дней - 1 час

print(delta1)                      5 days, 1:00:00
print(delta2)                      4 days, 23:00:00

            Умножение временного интервала на число
 from datetime import timedelta

delta1 = 48 * timedelta(hours=1)
delta2 = timedelta(weeks=1) * (3/7)

print(delta1)                 2 days, 0:00:00
print(delta2)                 3 days, 0:00:00

            Деление временных интервалов на число
from datetime import timedelta

delta = timedelta(hours=1, minutes=6)
delta1 = delta / 2
delta2 = delta // 5

print(delta1)             0:33:00
print(delta2)             0:13:12

          Деление временного интервала на временной интервал
 помощью операторов / и // мы также можем делить один временной интервал (тип timedelta) на другой. По сути происходит деление общей длительности одного интервала на общую длительность другого интервала.

Приведенный ниже код:

from datetime import timedelta

delta1 = timedelta(weeks=1) / timedelta(hours=5)       # обычное деление, результат float
delta2 = timedelta(weeks=1) // timedelta(hours=5)      # целочисленное деление, результат int

print(delta1)                     33.6
print(delta2)                     33

Мы также можем использовать оператор нахождения остатка от деления %, при этом остаток вычисляется как объект timedelta.
from datetime import timedelta

delta1 = timedelta(weeks=1) % timedelta(hours=5)         # 3 часа
delta2 = timedelta(hours=1) % timedelta(minutes=7)       # 4 минуты

print(delta1)                       3:00:00
print(delta2)                       0:04:00

Рассмотрим следующую задачу: рабочая смена длится 7 часов 30 минут, сколько полных смен в 3-х сутках?
from datetime import timedelta

all_time = timedelta(days=3)
smena = timedelta(hours=7, minutes=30)

print(all_time // smena)           #9
print(all_time % smena)           #4:30:00

                                                                   Модуль time
Для того чтобы получить количество секунд, прошедших с момента начала эпохи, необходимо использовать одноименную функцию time() из модуля time.

import time
seconds = time.time()    # получаем количество прошедших секунд в виде float числа
print('Количество секунд с начала эпохи =', seconds)

                Функция ctime()
Функция ctime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает строку, представляющую собой местное (локальное) время.
import time

seconds = 1630387918.354396
local_time = time.ctime(seconds)
print('Местное время:', local_time)          #Tue Aug 31 08:31:58 2021

Таким образом, функция ctime() возвращает строковое представление о местном (локальном) времени, которое включает в себя:
день недели: Tue (Tuesday)
название месяца: Aug (August)
число месяца: 31
часы, минуты, секунды: 08:31:58
                Функция sleep()
Функция sleep() используется для добавления задержки в выполнении программы.
Эта функция принимает в качестве аргумента количество секунд (secs) и добавляет задержку в выполнении программы на указанное количество секунд.
Аргумент secs может быть числом с плавающей точкой (float), для указания более точного времени приостановки.
Например,мы можем сделать задержку на 700 миллисекунд, что составляет 0.7 секунды, как показано ниже:

import time 

print('Before the sleep statement')
time.sleep(0.7)
print('After the sleep statement')
год: 2021
                  Функция monotonic()       monotonic_ns()
Используемый таймер в функции monotonic() никогда не вернет при повторном вызове значение, которое будет меньше значения, полученного при предыдущем вызове. 
Это позволяет избежать многих ошибок, а также неожиданного поведения.
import time

start_time = time.monotonic()
for i in range(5): 
    print(i)
    time.sleep(0.5)
end_time = time.monotonic()
elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')

выводит (время работы программы может незначительно отличаться):
0
1
2
3
4
Время работы программы = 2.547000000020489
