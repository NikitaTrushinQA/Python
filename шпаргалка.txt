                                                           "Функции и методы строк"
Функция или метод	                               
S = 'str'; S = "str"; S = '''str'''; S = """str"""	Литералы строк
S = "s\np\ta\nbbb"	Экранированные последовательности
S = r"C:\temp\new"	Неформатированные строки (подавляют экранирование)
S = b"byte"	Строка байтов
S1 + S2	Конкатенация (сложение строк)
S1 * 3	Повторение строки
S[i]	Обращение по индексу
S[i:j:step]	Извлечение среза
len(S)	Длина строки
S.find(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или -1
S.rfind(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
S.index(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
S.rindex(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
S.replace(шаблон, замена[, maxcount])	Замена шаблона на замену. maxcount ограничивает количество замен
S.split(символ)	Разбиение строки по разделителю
S.isdigit()	Состоит ли строка из цифр
S.isalpha()	Состоит ли строка из букв
S.isalnum()	Состоит ли строка из цифр или букв
S.islower()	Состоит ли строка из символов в нижнем регистре
S.isupper()	Состоит ли строка из символов в верхнем регистре
S.isspace()	Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'),
"горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
S.istitle()	Начинаются ли слова в строке с заглавной буквы
S.upper()	Преобразование строки к верхнему регистру
S.lower()	Преобразование строки к нижнему регистру
S.startswith(str)	Начинается ли строка S с шаблона str
S.endswith(str)	Заканчивается ли строка S шаблоном str
S.join(список)	Сборка строки из списка с разделителем S
ord(символ)	Символ в его код ASCII
chr(число)	Код ASCII в символ
S.capitalize()	Переводит первый символ строки в верхний регистр, а все остальные в нижний
S.center(width, [fill])	Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
S.count(str, [start],[end])	Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
S.expandtabs([tabsize])	Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца.
Если TabSize не указан, размер табуляции полагается равным 8 пробелам
S.lstrip([chars])	Удаление пробельных символов в начале строки
S.rstrip([chars])	Удаление пробельных символов в конце строки
S.strip([chars])	Удаление пробельных символов в начале и в конце строки
S.partition(шаблон)	Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
S.rpartition(sep)	Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку
S.swapcase()	Переводит символы нижнего регистра в верхний, а верхнего – в нижний
S.title()	Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
S.zfill(width)	Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
S.ljust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
S.rjust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
S.format(*args, **kwargs)	Форматирование строки                                                                       
                                                                                                                                                                        
                                                                        zfill()
Метод zfill() Метод zfill() возвращает копию строки с заполненным 0 слева. 
Длина возвращаемой строки зависит от предоставленной ширины 

str.zfill(width)

Если строка начинается с префикса знака (‘+’, ‘-‘), 0 цифр заполняется после первого символа префикса знака.
number = "-290" print(number.zfill(8))        ==> -0000290

                                                                 метод compress()
Метод compress() модуля itertools создает итератор, который фильтрует элементы из данных s,возвращая только те,
которые имеют соответствующий элемент, равный True или 1 в последовательности lst.

from itertools import compress
s = 'abcd'
lst = [1,0,1,0]
rez = compress(s, lst)
print(list(rez)  =====> ['a','c']
           
                                                                   "Функции и методы списков"
list.append(x)	Добавляет элемент в конец списка
list.extend(L)	Расширяет список list, добавляя в конец все элементы списка L
list.insert(i, x)	Вставляет на i-ый элемент значение x
list.remove(x)	Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует
list.pop([i])	Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент
list.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)
list.count(x)	Возвращает количество элементов со значением x
list.sort([key=функция])	Сортирует список на основе функции
list.reverse()	Разворачивает список
list.copy()	Поверхностная копия списка
list.clear()	Очищает список

                                                                      Методы словарей
dict.clear() - очищает словарь.

dict.copy() - возвращает копию словаря.

classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

dict.items() - возвращает пары (ключ, значение).

dict.keys() - возвращает ключи в словаре.

dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.

dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).

dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

dict.values() - возвращает значения в словаре.
                                                           операции множеств
С множествами можно выполнять множество операций: находить объединение, пересечение...

len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
И операции, непосредственно изменяющие множество:

set.update(other, ...); set |= other | ... - объединение.
set.intersection_update(other, ...); set &= other & ... - пересечение.
set.difference_update(other, ...); set -= other | ... - вычитание.
set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в множестве.
set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
set.clear() - очистка множества.

                                                      Список методов модуля random в Python:

Метод	            Описание
seed()	Инициализация генератора случайных чисел
getstate()	Возвращает текущее внутренне состояние (state) генератора случайных чисел
setstate()	Восстанавливает внутреннее состояние (state) генератора случайных чисел
getrandbits()	Возвращает число, которое представляет собой случайные биты
randrange()	Возвращает случайное число в пределах заданного промежутка
randint()	Возвращает случайное число в пределах заданного промежутка
choice()	Возвращает случайный элемент заданной последовательности
choices()	Возвращает список со случайной выборкой из заданной последовательности
shuffle()	Берет последовательность и возвращает ее в перемешанном состоянии
sample()	Возвращает заданную выборку последовательности
random()	Возвращает случайное вещественное число в промежутке от 0 до 1
uniform()	Возвращает случайное вещественное число в указанном промежутке
triangular()	Возвращает случайное вещественное число в промежутке между двумя заданными параметрами. Также можно использовать параметр mode для уточнения середины между указанными параметрами
betavariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Бета-распределении, которое используется в статистике
expovariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, или же между 0 и -1, когда параметр отрицательный. За основу берется Экспоненциальное распределение, которое используется в статистике
gammavariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Гамма-распределении, которое используется в статистике
gauss()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Гауссовом распределении, которое используется в теории вероятности
lognormvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Логнормальном распределении, которое используется в теории вероятности
normalvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Нормальном распределении, которое используется в теории вероятности
vonmisesvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении фон Мизеса, которое используется в направленной статистике
paretovariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении Парето, которое используется в теории вероятности
weibullvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении Вейбулла, которое используется в статистике
                                                  Модуль queue, очереди в Python(FIFO,LIFO)
Модуль реализует три типа очереди, которые отличаются только порядком, в котором извлекаются записи:
1)В очереди FIFO первые добавленные задачи являются первыми извлеченными.
2)В очереди LIFO самая последняя добавленная запись является первой извлеченной (работающей как стек).
3)В очереди с приоритетами записи сохраняются отсортированными с использованием модуля heapq и сначала извлекается запись с наименьшим значением.

    Очередь FIFO:
Класс queue.Queue() реализует базовый контейнер типа FIFO - "первым пришел - первым вышел".
Элементы добавляются к одному концу очереди с помощью метода put(), а удаляются с другого конца с помощью метода get().
import queue
q = queue.Queue()
for i in range(5):
    q.put(i)
while not q.empty():
    print(q.get(), end=' ')

# 0 1 2 3 4

       Очередь LIFO:
В отличие от стандартной реализации очереди FIFO, в queue.LifoQueue() используется порядок "последним пришел - первым вышел",
который обычно связан со структурой данных стека.
import queue
q = queue.LifoQueue()
for i in range(5):
    q.put(i)
while not q.empty():
    print(q.get(), end=' ')

# 4 3 2 1 0

        Очередь с приоритетом:
Иногда порядок обработки элементов в очереди должен основываться на характеристиках этих элементов, а не только на порядке их создания или добавления в очередь. Например, задания на печать из финансового отдела могут иметь приоритет над списком заданий из отдела технической поддержки.
Класс модуля queue.PriorityQueue() использует порядок сортировки содержимого очереди, чтобы решить, какой элемент получить.
import functools
import queue
import threading


@functools.total_ordering
class Job:

    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        return

    def __eq__(self, other):
        try:
            return self.priority == other.priority
        except AttributeError:
            return NotImplemented

    def __lt__(self, other):
        try:
            return self.priority < other.priority
        except AttributeError:
            return NotImplemented

def process_job(q):
    while True:
        next_job = q.get()
        print('Processing job:', next_job.description)
        q.task_done()

q = queue.PriorityQueue()
q.put(Job(3, 'Mid-level'))
q.put(Job(10, 'Low-level'))
q.put(Job(1, 'Important'))

workers = [
    threading.Thread(target=process_job, args=(q,)),
    threading.Thread(target=process_job, args=(q,)),
]
for w in workers:
    w.setDaemon(True)
    w.start()

q.join()

                                                                date и time

%a	Сокращенное название дня недели	Sun, Mon, …, Sat (en_US) Пн, Вт, ..., Вс (ru_RU)
%A	Полное название дня недели	Sunday, Monday, …, Saturday (en_US) понедельник, ..., воскресенье (ru_RU)
%w	Номер дня недели [0, …, 6]	0, 1, …, 6 (0=воскресенье, 6=суббота)
%d	День месяца [01, …, 31]	01, 02, …, 31
%b	Сокращенное название месяца	Jan, Feb, …, Dec (en_US); янв, ..., дек (ru_RU)
%B	Полное название месяца	January, February, …, December (en_US); Январь, ..., Декабрь (ru_RU)
%m	Номер месяца [01, …,12]	01, 02, …, 12
%y	Год без века [00, …, 99]	00, 01, …, 99
%Y	Год с веком	0001, 0002, …, 2013, 2014, …, 9999 В Linux год выводится без ведущих нулей: 1, 2, …, 2013, 2014, …, 9999
%H	Час (24-часовой формат) [00, …, 23]	00, 01, …, 23
%I	Час (12-часовой формат) [01, …, 12]	01, 02, …, 12
%p	До полудня или после (при 12-часовом формате)	AM, PM (en_US)
%M	Число минут [00, …, 59]	00, 01, …, 59
%S	Число секунд [00, …, 59]	00, 01, …, 59
%f	Число микросекунд	000000, 000001, …, 999999
%z	Разница с UTC в формате ±HHMM[SS[.ffffff]]	+0000, -0400, +1030, +063415, ...
%Z	Временная зона	UTC, EST, CST
%j	День года [001,366]	001, 002, …, 366
%U	Номер недели в году      (нулевая неделя начинается с воскр.) [00, …, 53]   00, 01, …, 53
%W	 Номер недели в году      (нулевая неделя начинается с пон.) [00, …, 53]    00, 01, …, 53
%c	Дата и время	Tue Aug 16 21:30:00 1988 (en_US);             03.01.2019 23:18:32 (ru_RU)
%x	Дата	08/16/88 (None); 08/16/1988 (en_US);                03.01.2019 (ru_RU)
%X	Время	21:30:00

пример:
from datetime import date, time
my_date = date(2021, 8, 10)
my_time = time(7, 18, 34)
print(my_date.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))
print(my_time.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))
выводит:
Tue Tuesday 2 10 Aug August 08 21 2021 00 12 AM 00 00 000000   222 32 32 Tue Aug 10 00:00:00 2021 08/10/21 00:00:00
Mon Monday 1 01 Jan January 01 00 1900 07 07 AM 18 34 000000   001 00 01 Mon Jan  1 07:18:34 1900 01/01/00 07:18:34

                                                              Использование локализации
Для того чтобы использовать конкретную локализацию (перевод на язык), нужно использовать модуль locale.
Приведенный ниже код устанавливает русскую локализацию:
from datetime import date
import locale

locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
my_date = date(2021, 8, 10)
print(my_date.strftime("%A %d, %B %Y"))    # форматированный вывод даты в русской локализации

и выводит:
вторник 10, Август 2021


Для установки английской локализации используется код:

import locale

locale.setlocale(locale.LC_ALL, 'en_EN.UTF-8')
                                                                    
                                         isoformat() (Для того, чтобы получить строковое представление объектов типаdate и time в ISO формате)

from datetime import date, time

my_date = date(2021, 12, 31)
my_time = time(21, 15, 17)

print('Дата: ' + my_date.isoformat())
print('Время: ' + my_time.isoformat())

выводит:
Дата: 2021-12-31
Время: 21:15:17
                                                                          Тип данных datetime
ри создании новой даты-времени (тип datetime) нужно указать год, месяц, день, часы, минуты, секунды и микросекунды. При этом год, месяц и день являются обязательными, а часы, минуты, секунды и микросекунды необязательными.
доступ:
year — год
month — месяц
day — день
hour — час
minute — минуты
second — секунды
microsecond — микросекунды
                                       Методы combine(), date(), time()
Сформировать новый объект типа datetime можно с помощью двух разных объектов, представляющих дату и время (date и time). Для этого используется метод combine().

from datetime import date, time, datetime
my_date = date(1992, 10, 6)
my_time = time(10, 45, 17)
my_datetime = datetime.combine(my_date, my_time)

print(my_datetime)
выводит:
1992-10-06 10:45:17

Если, наоборот, нужно получить из даты-времени (тип datetime) по отдельности дату (тип date) и время (тип time), то используются методы date() и time() соответственно.
Приведенный ниже код:

from datetime import date, time, datetime
my_datetime = datetime(2022, 10, 7, 14, 15, 45)
my_date = my_datetime.date()                     # получаем только дату (тип date)
my_time = my_datetime.time()                     # получаем только время (тип time)

print(my_datetime, type(my_datetime))
print(my_date, type(my_date))
print(my_time, type(my_time))
выводит:

2022-10-07 14:15:45 <class 'datetime.datetime'>
2022-10-07 <class 'datetime.date'>
14:15:45 <class 'datetime.time'>

                                                      Методы now(), utcnow(), today()
Для того, что получить текущее время на момент исполнения программы, используются методы now() и utcnow() для локального и 
UTC(Всемирное координированное время (Coordinated Universal Time, UTC) — стандарт, по которому общество регулирует часы и время. Московское время соответствует UTC+3) времени соответственно.

Приведенный ниже код:

from datetime import datetime

datetime_now = datetime.now()
datetime_utcnow = datetime.utcnow()

print(datetime_now)           # текущее локальное время (московское) на момент запуска программы
print(datetime_utcnow)        # текущее UTC время на момент запуска программы
выводит:

2021-08-13 08:03:43.224568
2021-08-13 05:03:43.224568

Метод today() аналогичен методу now(). Для получения локальной даты-времени рекомендуется использовать именно метод now().

                                     Метод timestamp(),Метод fromtimestamp()
Метод timestamp() позволяет преобразовать объект типа datetime в количество секунд, прошедших с момента начала эпохи.
Данный метод возвращает значение типа float.(Начало эпохи — это полночь 1 января 1970 года (00:00:00 UTC))

from datetime import datetime
my_datetime = datetime(2021, 10, 13, 8, 10, 23)
print(my_datetime.timestamp())

выводит:
1634101823.0

Метод fromtimestamp() позволяет преобразовать количество секунд, прошедших с момента начала эпохи, в объект типа datetime.
Данный метод является обратным по отношению к методу timestamp().

from datetime import datetime
my_datetime = datetime.fromtimestamp(1634101823.0)
print(my_datetime)
выводит:

2021-10-13 08:10:23
                                                    Форматирование даты-времени
                                                    
Чтобы преобразовать дату-время в строку нужного формата, следует воспользоваться методом strftime(), указав ему в качестве аргумента параметры форматирования.

from datetime import datetime

my_datetime = datetime(2021, 8, 10, 18, 20, 34)

print(my_datetime)                                            # вывод в ISO формате
print(my_datetime.strftime('%d.%m.%y --- %H::%M::%S'))
print(my_datetime.strftime('%d/%m/%y'))
print(my_datetime.strftime('%A %d, %B %Y'))
print(my_datetime.strftime('%H:%M:%S'))
выводит

2021-08-10 18:20:34
10.08.21 --- 18::20::34
10/08/21
Tuesday 10, August 2021
18:20:34
                                                 strptime() 
strptime(), который преобразует строку (первый аргумент) в объект datetime согласно переданному формату (второй аргумент)
Приведенный ниже код:

from datetime import datetime

datetime0 = datetime.strptime('10.08.2034 13:55:59', '%d.%m.%Y %H:%M:%S')
datetime1 = datetime.strptime('10/08/21', '%d/%m/%y')
datetime2 = datetime.strptime('Tuesday 10, August 2021', '%A %d, %B %Y')
datetime3 = datetime.strptime('18.20.34', '%H.%M.%S')
datetime4 = datetime.strptime('2021/08/10', '%Y/%m/%d')
datetime5 = datetime.strptime('10.08.2021 (Tuesday, August)', '%d.%m.%Y (%A, %B)')
datetime6 = datetime.strptime('Year: 2021, Month: 08, Day: 10, Hour: 18.', 'Year: %Y, Month: %m, Day: %d, Hour: %H.')

print(datetime0, datetime1, datetime2, datetime3, datetime4, datetime5, datetime6, sep='\n')
выводит:

2034-08-10 13:55:59
2021-08-10 00:00:00
2021-08-10 00:00:00
1900-01-01 18:20:34
2021-08-10 00:00:00
2021-08-10 00:00:00
2021-08-10 18:00:00
                                                                  Тип данных timedelta
 Тип данных timedelta представляет из себя временной интервал (разница между двумя объектами datetime или date) и используется для удобного выполнения различных манипуляций над типами datetime или date.

При создании объекта timedelta можно указать следующие аргументы:

недели (weeks)
дни (days)
часы (hours)
минуты (minutes)
секунды (seconds)
микросекунды (microseconds)
миллисекунды (milliseconds)

Мы можем выбрать любые их сочетания для задания временного интервала, при этом все аргументы являются необязательными и по умолчанию равны 0.

Аргументы могут быть целыми числами или числами с плавающей запятой, а также могут быть как положительными, так и отрицательными. Используйте именованные аргументы, вместо позиционных, чтобы избежать ошибок.

Тип timedelta внутренне хранит только сочетание days, seconds, microseconds, а остальные переданные в конструктор аргументы конвертируются в эти единицы:

millisecond преобразуется в 1000 microseconds
minutes преобразуется в 60 seconds
hours преобразуется в3600 seconds
weeks преобразуется в 7 days

В следующем примере показано, как любые аргументы, кроме days, seconds, microseconds, объединяются и нормализуются в три результирующих сочетания.

Приведенный ниже код:

from datetime import timedelta

delta1 = timedelta(days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2)  ==>64 days, 8:05:56.000010
delta2 = timedelta(weeks=1, hours=23, minutes=61)                                                          ==>8 days, 0:01:00
delta3 = timedelta(hours=25)                                                                               ==>1 day, 1:00:00
delta4 = timedelta(minutes=300)                                                                            ==>5:00:00

 у типа timedelta нет атрибутов hours и minutes, позволяющих получить количество часов и минут соответственно.
 Достать часы и минуты можно так:
 def hours_minutes(td):
    return td.seconds // 3600, (td.seconds // 60) % 60
Приведенный ниже код:

from datetime import timedelta

def hours_minutes(td):
    return td.seconds // 3600, (td.seconds // 60) % 60

delta = timedelta(days=7, seconds=125, minutes=10, hours=8, weeks=2)

hours, minutes = hours_minutes(delta)

print(delta)
print(hours)
print(minutes)
выводит:

21 days, 8:12:05
8
12
                   Сравнение временных интервалов
Временные интервалы (тип timedelta) можно сравнивать (==, !=, <, >, <=, >=), как и любые другие типы данных.
from datetime import timedelta

delta1 = timedelta(weeks=1)
delta2 = timedelta(hours=24*7)
delta3 = timedelta(minutes=24*7*59)

print(delta1 == delta2)         #True
print(delta1 != delta3)        #True
print(delta1 < delta3)         #False

               Сумма и разность временных интервалов
from datetime import timedelta

delta1 = timedelta(days=5) + timedelta(seconds=3600)  # 5 дней + 1 час
delta2 = timedelta(days=5) - timedelta(seconds=3600)  # 5 дней - 1 час

print(delta1)                      5 days, 1:00:00
print(delta2)                      4 days, 23:00:00

            Умножение временного интервала на число
 from datetime import timedelta

delta1 = 48 * timedelta(hours=1)
delta2 = timedelta(weeks=1) * (3/7)

print(delta1)                 2 days, 0:00:00
print(delta2)                 3 days, 0:00:00

            Деление временных интервалов на число
from datetime import timedelta

delta = timedelta(hours=1, minutes=6)
delta1 = delta / 2
delta2 = delta // 5

print(delta1)             0:33:00
print(delta2)             0:13:12

          Деление временного интервала на временной интервал
 помощью операторов / и // мы также можем делить один временной интервал (тип timedelta) на другой. По сути происходит деление общей длительности одного интервала на общую длительность другого интервала.

Приведенный ниже код:

from datetime import timedelta

delta1 = timedelta(weeks=1) / timedelta(hours=5)       # обычное деление, результат float
delta2 = timedelta(weeks=1) // timedelta(hours=5)      # целочисленное деление, результат int

print(delta1)                     33.6
print(delta2)                     33

Мы также можем использовать оператор нахождения остатка от деления %, при этом остаток вычисляется как объект timedelta.
from datetime import timedelta

delta1 = timedelta(weeks=1) % timedelta(hours=5)         # 3 часа
delta2 = timedelta(hours=1) % timedelta(minutes=7)       # 4 минуты

print(delta1)                       3:00:00
print(delta2)                       0:04:00

Рассмотрим следующую задачу: рабочая смена длится 7 часов 30 минут, сколько полных смен в 3-х сутках?
from datetime import timedelta

all_time = timedelta(days=3)
smena = timedelta(hours=7, minutes=30)

print(all_time // smena)           #9
print(all_time % smena)           #4:30:00

                                                                   Модуль time
Для того чтобы получить количество секунд, прошедших с момента начала эпохи, необходимо использовать одноименную функцию time() из модуля time.

import time
seconds = time.time()    # получаем количество прошедших секунд в виде float числа
print('Количество секунд с начала эпохи =', seconds)

                Функция ctime()
Функция ctime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает строку, представляющую собой местное (локальное) время.
import time

seconds = 1630387918.354396
local_time = time.ctime(seconds)
print('Местное время:', local_time)          #Tue Aug 31 08:31:58 2021

Таким образом, функция ctime() возвращает строковое представление о местном (локальном) времени, которое включает в себя:
день недели: Tue (Tuesday)
название месяца: Aug (August)
число месяца: 31
часы, минуты, секунды: 08:31:58
                Функция sleep()
Функция sleep() используется для добавления задержки в выполнении программы.
Эта функция принимает в качестве аргумента количество секунд (secs) и добавляет задержку в выполнении программы на указанное количество секунд.
Аргумент secs может быть числом с плавающей точкой (float), для указания более точного времени приостановки.
Например,мы можем сделать задержку на 700 миллисекунд, что составляет 0.7 секунды, как показано ниже:

import time 

print('Before the sleep statement')
time.sleep(0.7)
print('After the sleep statement')
год: 2021
                  Функция monotonic()       monotonic_ns()
Используемый таймер в функции monotonic() никогда не вернет при повторном вызове значение, которое будет меньше значения, полученного при предыдущем вызове. 
Это позволяет избежать многих ошибок, а также неожиданного поведения.
import time

start_time = time.monotonic()
for i in range(5): 
    print(i)
    time.sleep(0.5)
end_time = time.monotonic()
elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')

выводит (время работы программы может незначительно отличаться):
0
1
2
3
4
Время работы программы = 2.547000000020489

                                Функция perf_counter()
 ля самого точного измерения времени выполнения программы следует использовать функцию perf_counter().
 Данная функция использует таймер с наибольшим доступным разрешением, 
 что делает эту функцию отличным инструментом для измерения времени выполнения кода на коротких интервалах.
 
 import time
start_time = time.perf_counter()
for i in range(5): 
    print(i)
    time.sleep(1)
end_time = time.perf_counter()
elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')

выводит (время работы программы может незначительно отличаться):
0
1
2
3
4
Время работы программы = 5.042140900040977
                                                                    Тип данных struct_time
Данный тип является именованным кортежем, представляющий информацию о времени. Структура представления времени struct_time чем-то похожа на тип datetime.
Именованный кортеж struct_time состоит из следующих атрибутов:

Номер индекса  	Атрибут	       Значение
0	              tm_year	       диапазон от 0000 до 9999
1	              tm_mon	       диапазон от 1 до 12
2	              tm_mday	       диапазон от 1 до 31
3	              tm_hour	       диапазон от 0 до 23
4	              tm_min 	       диапазон от 0 до 59
5	              tm_sec	       диапазон от 0 до 61
6	              tm_wday	       диапазон от 0 до 6, понедельник = 0
7	              tm_yday	       диапазон от 1 до 366
8	              tm_isdst	     значения -1, 0, 1
N/A	            tm_zone	       сокращение названия часового пояса
N/A	            tm_gmtoff	     смещение к востоку от UTC в секундах

Создавать объекты типа struct_time можно на основе кортежа:

import time
time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0)
time_obj = time.struct_time(time_tuple)

На практике редко приходится собственноручно создавать объекты типа struct_time. Обычно используют функции модуля time, которые сами создают и оперируют ими.
Такие функции как localtime(), gmtime(), asctime() и другие, принимают объект time.struct_time в качестве аргумента или возвращают его.

                               Функция localtime()
Функция localtime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает кортеж struct_time в локальном времени.
Если функции localtime() передан аргумент None, то вернется значение time().
Приведенный ниже код:

import time
result = time.localtime(1630387918)
print('Результат:', result)           #time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=8, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0)
print('Год:', result.tm_year)         #Год: 2021
print('Месяц:', result.tm_mon)        #Месяц: 8
print('День:', result.tm_mday)        #День: 31
print('Час:', result.tm_hour)         #Час: 8

мы можем обращаться к данным именованного кортежа struct_time и по индексам.
import time

result = time.localtime(1630387918)
print('Результат:', result)
print('Год:', result[0])
print('Месяц:', result[1])
print('День:', result[2])
print('Час:', result[3])
                    Функция gmtime()
Функция gmtime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает кортеж struct_time в UTC.
Если функции gmtime() передан аргумент None, то вернется значение time().
import time

result = time.gmtime(1630387918)
print('Результат:', result)      #Результат: time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=5, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0)
print('Год:', result.tm_year)    #Год: 2021
print('Месяц:', result.tm_mon)   #Месяц: 8
print('День:', result.tm_mday)   #День: 31
print('Час:', result.tm_hour)    #Час: 5

                           Функция mktime()
Функция mktime() принимает struct_time (или кортеж, содержащий 99 значений, относящихся к struct_time)
в качестве аргумента и возвращает количество секунд, прошедших с начала эпохи, в местном времени.

import time
time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0)
time_obj = time.mktime(time_tuple)
print('Локальное время в секундах:', time_obj)      #Локальное время в секундах: 1630377118.0

Функция mktime() является обратной к функции localtime(). Следующий пример показывает их связь:

import time
seconds = 1630377118
time_obj = time.localtime(seconds)            # возвращает struct_time
print(time_obj)                        #time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=5, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0)
time_seconds = time.mktime(time_obj)          # возвращает секунды из struct_time
print(time_seconds)                    #1630377118.0

Когда кортеж с неправильной длиной передается функции, ожидающей struct_time или имеющей элементы неправильного типа, возникает ошибка TypeError.

                      Функция asctime()
Функция asctime() принимает struct_time (или кортеж, содержащий 99 значений, относящихся к struct_time) в качестве аргумента и возвращает строку,
представляющую собой дату и время.

import time

time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0)

result = time.asctime(time_tuple)
print('Результат:', result)          #Результат: Tue Aug 31 05:31:58 2021

                                                       ----модуль calendar---------------
Атрибуты модуля calendar
В отличие от функций, которые выполняют определенную работу, в модуле calendar есть полезные атрибуты,
которые возвращают константные (общепринятые) значения, полезные при решении практических задач.

           Атрибут day_name
Атрибут calendar.day_name возвращает итерируемый объект, содержащий названия дней недели на английском языке.

import calendar
for name in calendar.day_name:
    print(name)
выводит:
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday

Для локализации на русский язык мы используем код:

import calendar, locale
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
for name in calendar.day_name:
    print(name)
который выводит:
понедельник
вторник
среда
четверг
пятница
суббота
воскресенье

              Атрибут day_abbr
Атрибут calendar.day_abbr возвращает итерируемый объект, содержащий сокращенные названия дней недели.
import calendar, locale

for name in calendar.day_abbr:
    print(name)

locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')

for name in calendar.day_abbr:
    print(name)
выводит:
Mon
Tue
Wed
Thu
Fri
Sat
Sun
Пн
Вт
Ср
Чт
Пт
Сб
Вс

Атрибут month_name
Атрибут calendar.month_name возвращает итерируемый объект, содержащий названия месяцев года.

import calendar, locale

english_names = list(calendar.month_name)
print(english_names)
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
russian_names = list(calendar.month_name)
print(russian_names)
выводит:

['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
['', 'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']

           Атрибут month_abbr
Атрибут calendar.month_abbr возвращает итерируемый объект, содержащий сокращенные названия месяцев года.
import calendar, locale
english_names = list(calendar.month_abbr)
print(english_names)
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
russian_names = list(calendar.month_abbr)
print(russian_names)
выводит:

['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
['', 'янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек']

Атрибуты номеров дней недели
Для получения номеров дней недели можно использовать атрибуты: MONDAY, TUESDAY, ..., SUNDAY.

Приведенный ниже код:

import calendar

print(calendar.MONDAY)           #0
print(calendar.TUESDAY)          #1
print(calendar.WEDNESDAY)        #2
print(calendar.THURSDAY)         #3
print(calendar.FRIDAY)           #4
print(calendar.SATURDAY)         #5
print(calendar.SUNDAY)           #6

                                                          -------Функции модуля calendar-------------------
Функция setfirstweekday()
По умолчанию в модуле calendar понедельник является первым днем недели (имеет номер 00), а воскресенье – последним днем недели (имеет номер 66).
Функция setfirstweekday() позволяет изменить поведение по умолчанию и устанавливает заданный день недели в качестве начала недели.
Например, чтобы установить первый будний день воскресенье, мы используем код:

import calendar
calendar.setfirstweekday(calendar.SUNDAY)     # эквивалентно calendar.setfirstweekday(6)

               Функция firstweekday()
Функция firstweekday() возвращает целое число, означающее день недели, установленное в качестве начала недели.
import calendar
print(calendar.firstweekday())               #0
calendar.setfirstweekday(calendar.SUNDAY)
print(calendar.firstweekday())              #6

Функция isleap()
Напомним, что год является високосным, если его номер кратен 4, но не кратен 100100, или если он кратен 400. 
Модуль calendar содержит функцию isleap(), которая осуществляет нужную проверку.

import calendar
print(calendar.isleap(2020))        #True
print(calendar.isleap(2021))       #False

                  Функция leapdays()
Функция leapdays(y1, y2) возвращает количество високосных лет в диапазоне от y1 до y2 (исключая), где y1 и y2 – годы.

import calendar
print(calendar.leapdays(2020, 2025))          #2

так как в нужном диапазоне [2020;2025) находятся два високосных года: 2020 и 2024.

                 Функция weekday()
Функция weekday(year, month, day) возвращает день недели в виде целого числа (где 00 – понедельник, 66 – воскресенье) для заданной даты. Аргументы функции year – год начиная с 19701970, month – месяц в диапазоне 1 - 121−12, day – число в диапазоне 1 - 311−31.


import calendar
print(calendar.weekday(2021, 9, 1))     # среда
print(calendar.weekday(2021, 9, 2))     # четверг
выводит:
2
3

                   Функция monthrange()
Функция monthrange(year, month) возвращает день недели первого дня месяца и количество дней в месяце в виде кортежа для указанного года year и месяца month.

import calendar
print(calendar.monthrange(2022, 1))     # январь 2022 года
print(calendar.monthrange(2021, 9))     # сентябрь 2021 года
выводит:
(5, 31)
(2, 30)

               Функция monthcalendar()
Функция monthcalendar(year, month) возвращает матрицу, представляющую календарь на месяц. Каждая строка матрицы представляет неделю.

import calendar
print(*calendar.monthcalendar(2021, 9), sep='\n')
выводит:
[0, 0, 1, 2, 3, 4, 5]
[6, 7, 8, 9, 10, 11, 12]
[13, 14, 15, 16, 17, 18, 19]
[20, 21, 22, 23, 24, 25, 26]
[27, 28, 29, 30, 0, 0, 0]
Обратите внимание на то, что дни, которые не входят в указанный месяц, представлены нулями. При этом каждая неделя начинается с понедельника, если не установлено другое функцией  setfirstweekday().

                 Функция month()
Функция month(year, month, w=0, l=0) возвращает календарь на месяц в многострочной строке.
Аргументами функции являются: year (год), month (месяц), w (ширина столбца даты) и l (количество строк, отводимые на неделю).
Аргументы w и l имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции.

import calendar
print(calendar.month(2021, 9))
print(calendar.month(2021, 10))
print(calendar.month(2021, 9, w=3))
print(calendar.month(2021, 9, l=2))
print(calendar.month(2021, 9, w=5, l=2))
выводит:

   September 2021
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30

    October 2021
Mo Tu We Th Fr Sa Su
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31

       September 2021
Mon Tue Wed Thu Fri Sat Sun
          1   2   3   4   5
  6   7   8   9  10  11  12
 13  14  15  16  17  18  19
 20  21  22  23  24  25  26
 27  28  29  30

   September 2021

Mo Tu We Th Fr Sa Su

       1  2  3  4  5

 6  7  8  9 10 11 12

13 14 15 16 17 18 19

20 21 22 23 24 25 26

27 28 29 30


              September 2021

 Mon   Tue   Wed   Thu   Fri   Sat   Sun

               1     2     3     4     5

   6     7     8     9    10    11    12

  13    14    15    16    17    18    19

  20    21    22    23    24    25    26

  27    28    29    30
  
                   функция calendar()
Функция calendar(year, w=2, l=1, c=6, m=3) возвращает календарь на весь год в виде многострочной строки.
Аргументами функции являются: year (год),  w (ширина столбца даты) и l (количество строк, отводимые на неделю),
c (количество пробелов между столбцом месяца),  m (количество столбцов).
Аргументы w, l, c, m имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции.

import calendar
print(calendar.calendar(2021))
выводит:

                                  2021

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14
11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21
18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28
25 26 27 28 29 30 31                                29 30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                      1  2          1  2  3  4  5  6
 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13
12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20
19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27
26 27 28 29 30            24 25 26 27 28 29 30      28 29 30
                          31

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                         1             1  2  3  4  5
 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12
12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19
19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26
26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30
                          30 31

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12
11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19
18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26
25 26 27 28 29 30 31      29 30                     27 28 29 30 31

import calendar, locale
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
print(calendar.calendar(2022, m=4))
выводит:

                                               2022

       Январь                   Февраль                     Март                     Апрель
Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс
                1  2          1  2  3  4  5  6          1  2  3  4  5  6                   1  2  3
 3  4  5  6  7  8  9       7  8  9 10 11 12 13       7  8  9 10 11 12 13       4  5  6  7  8  9 10
10 11 12 13 14 15 16      14 15 16 17 18 19 20      14 15 16 17 18 19 20      11 12 13 14 15 16 17
17 18 19 20 21 22 23      21 22 23 24 25 26 27      21 22 23 24 25 26 27      18 19 20 21 22 23 24
24 25 26 27 28 29 30      28                        28 29 30 31               25 26 27 28 29 30
31

        Май                       Июнь                      Июль                     Август
Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс
                   1             1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7
 2  3  4  5  6  7  8       6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 14
 9 10 11 12 13 14 15      13 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 21
16 17 18 19 20 21 22      20 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 28
23 24 25 26 27 28 29      27 28 29 30               25 26 27 28 29 30 31      29 30 31
30 31

      Сентябрь                  Октябрь                    Ноябрь                   Декабрь
Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс
          1  2  3  4                      1  2          1  2  3  4  5  6                1  2  3  4
 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13       5  6  7  8  9 10 11
12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20      12 13 14 15 16 17 18
19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27      19 20 21 22 23 24 25
26 27 28 29 30            24 25 26 27 28 29 30      28 29 30                  26 27 28 29 30 31
                          31

                        Функции prmonth(), prcal()
Функция prmonth(theyear, themonth, w=0, l=0) печатает календарь на месяц, возвращенный функцией month(theyear, themonth, w=0, l=0).
Функция prcal(year, w=0, l=0, c=6, m=3) печатает календарь на весь год, возвращенный функцией calendar(year, w=0, l=0, c=6, m=3).

import calendar
calendar.prmonth(2021, 9)
calendar.prcal(2021)

эквивалентен коду:
import calendar
print(calendar.month(2021, 9))
print(calendar.calendar(2021))
и выводит:

   September 2021
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30
                                  2021

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14
11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21
18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28
25 26 27 28 29 30 31                                29 30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                      1  2          1  2  3  4  5  6
 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13
12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20
19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27
26 27 28 29 30            24 25 26 27 28 29 30      28 29 30
                          31

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                         1             1  2  3  4  5
 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12
12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19
19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26
26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30
                          30 31

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12
11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19
18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26
25 26 27 28 29 30 31      29 30                     27 28 29 30 31

Полезные ссылки по работе со временем:
1)https://www.timeanddate.com/
2)https://docs-python.ru/standart-library/modul-datetime-python/     #документация по модулю datetime
3)https://docs-python.ru/standart-library/modul-zoneinfo-python/     #модуль zoneinfo в Python, база часовых поясов
4)https://docs-python.ru/standart-library/modul-zoneinfo-python/     #Python pytz  Этот модуль обслуживает функции преобразования даты и времени и помогает         пользователям обслуживать международную клиентскую базу.
5)https://pythonru.com/biblioteki/modul-dateutil                    #модуль dateutil Он помогает планировать, получать данные в определенное время или устанавливать временные метки.
6)https://pythonim.ru/moduli/arrow-python                            #Модуль Arrow в Python – это библиотека, заменяющая datetime. Это позволяет легко создавать экземпляры даты и времени с учетом часового пояса.

                          --------------------------------------Потоковый ввод(sys.stdin)-------------------
Поток ввода (sys.stdin) — является итератором, который невозможно перезапустить. Как и любой итератор, он может двигаться только вперёд.
Как только данные прочитаны, они удаляются из потока ввода безвозвратно.

Пока есть данные в потоке ввода sys.stdin (то есть пока пользователь их вводит) программа будет записывать вводимые строки в переменную line, убирать символы перевода строки и выводить их на печать.

Если запустить такую программу, то она будет работать вечно. Чтобы показать, что ввод закончен, недостаточно нажать Enter — компьютер не знает, завершил ли пользователь работу или будет ещё что-то вводить (при этом Enter превратится в пустую строку).
Для завершения ввода необходимо ввести Ctrl + D (если работаете в консоли Linux или IDE PyCharm), либо Ctrl + Z, затем Enter (если работаете в консоли Windows).

                  Читаем входные данные в одну строку
С помощью потока ввода (sys.stdin) можно в одну строчку кода прочитать весь пользовательский ввод в список.

Реализуется это с помощью списочного выражения:
import sys
data = [line.strip() for line in sys.stdin]

или с помощью функции высшего порядка map():
import sys
data = list(map(str.strip, sys.stdin))

                      Методы read() и readlines()
Как уже было сказано выше, мы можем обойти циклом for итератор sys.stdin. Кроме того, можно считать все строки из итератора (с сохранением символов перевода строки) в список с помощью метода readlines():

import sys
data = sys.stdin.readlines()
Обратите внимание на то, что символ перехода на новую строку (\n) сохраняется в считанных строках.
Если разделять на строки нет необходимости, то считать многострочный текст из стандартного потока ввода в текстовую переменную можно с помощью метода read():

import sys
data = sys.stdin.read()

                              Потоковый вывод
Аналогичным образом можно работать с потоковым выводом (sys.stdout). По умолчанию функция print() перенаправляет вывод данных именно в sys.stdout, хотя нам ничего не мешает самостоятельно писать в него.

Приведенный ниже код:

import sys
print('Hello')
sys.stdout.write('world!')
print('from')
sys.stdout.write('python\n')
print('Bye-bye')

выведет:
Hello
world!from
python
Bye-bye

Обратите внимание на то, что функция print() добавляет перевод на новую строку, а явная запись данных в sys.stdout с помощью метода write() нет. Чтобы добавить перевод на новую строку, мы используем стандартный символ \n.
Также нужно иметь в виду, что при использовании потока вывода sys.stdout нам нужно самостоятельно преобразовывать данные к строковому типу данных (функция print() это делает автоматически).

                     --------------------------------------работа с csv файлами-------------------------------------------
                                                          Модуль csv
              Чтение данных с помощью reader
 import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.reader(file)                               # создаем reader объект
    for row in rows:
        print(row)

Объект reader дает доступ к построчному итератору, полностью аналогичному работе с файлом или списком.

После выполнения этой строки в переменную rows будет записан итератор, с помощью которого можно «пробежаться» циклом по файлу. В каждой итерации цикла при этом будет доступна соответствующая строка файла, уже разбитая по запятым и представляющая собой список. При этом автоматически будут учтены все нюансы с запятыми внутри кавычек и самими кавычками.

Так как каждая строка файла, полученная из итератора, является списком, к ней можно применять все способы работы со списками.

Пусть содержимое файла products.csv имеет вид (в качестве разделителя выбран символ ';'):
keywords;price;product_name
"Садовый стул, стул для дачи";1699;ВЭДДО
Садовый стул;2999;ЭПЛАРО
Садовый табурет;1699;ЭПЛАРО
Садовый стол;1999;ТЭРНО
"Складной стол, обеденный стол";7499;ЭПЛАРО
Настил;1299;РУННЕН
Стеллаж;1299;ХИЛЛИС
"Кружка, сосуд, стакан с ручкой";39;СТЕЛЬНА
Молочник;299;ВАРДАГЕН
Термос для еды;699;ЭФТЕРФРОГАД
Ситечко;59;ИДЕАЛИСК
Чайник заварочный;499;РИКЛИГ
Кофе-пресс;699;УПХЕТТА
Чашка с блюдцем;249;ИКЕА
"Кружка, стакан с ручкой";249;ЭМНТ
Ситечко;199;САККУННИГ
Кружка;199;ФИНСТИЛТ
"Тарелка, блюдце";269;ЭВЕРЕНС
Приведенный ниже код:

import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.reader(file, delimiter=';', quotechar='"')
    for index, row in enumerate(rows):
        if index > 5:
            break
        print(row)
выводит первые 66 строк файла, включая заголовок с названиями столбцов:

['keywords', 'price', 'product_name']
['Садовый стул, стул для дачи', '1699', 'ВЭДДО']
['Садовый стул', '2999', 'ЭПЛАРО']
['Садовый табурет', '1699', 'ЭПЛАРО']
['Садовый стол', '1999', 'ТЭРНО']
['Складной стол, обеденный стол', '7499', 'ЭПЛАРО']
При создании reader объекта мы указываем, что символ-разделитель записей delimiter в нашем файле — точка с запятой, а символ кавычек quotechar — двойные кавычки. Кроме того, мы используем встроенную функцию enumerate() для нумерации строк.

                      Чтение данных с помощью DictReader
Иcпользовать reader объект не всегда удобно, так как он возвращает сырые списки из строк файла, к тому же первой строкой является строка с названиями столбцов, которая практически всегда удаляется, так как мешает правильной обработке данных.

В модуле csv есть специальный объект DictReader, который поддерживает создание объекта-словаря на основе названий столбцов. С помощью DictReader объекта мы можем обращаться к полям не по индексу, а по названию, что делает код более понятным.

Пусть содержимое файла products.csv имеет вид (в качестве разделителя выбран символ ';'):

keywords;price;product_name
"Садовый стул, стул для дачи";1699;ВЭДДО
Садовый стул;2999;ЭПЛАРО
Садовый табурет;1699;ЭПЛАРО
Садовый стол;1999;ТЭРНО
"Складной стол, обеденный стол";7499;ЭПЛАРО
Настил;1299;РУННЕН
Стеллаж;1299;ХИЛЛИС
"Кружка, сосуд, стакан с ручкой";39;СТЕЛЬНА
Молочник;299;ВАРДАГЕН
Термос для еды;699;ЭФТЕРФРОГАД
Ситечко;59;ИДЕАЛИСК
Чайник заварочный;499;РИКЛИГ
Кофе-пресс;699;УПХЕТТА
Чашка с блюдцем;249;ИКЕА
"Кружка, стакан с ручкой";249;ЭМНТ
Ситечко;199;САККУННИГ
Кружка;199;ФИНСТИЛТ
"Тарелка, блюдце";269;ЭВЕРЕНС
Приведенный ниже код:

import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';', quotechar='"')
    for row in rows:
        print(row)
выводит:

{'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'}
{'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'}
{'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Настил', 'price': '1299', 'product_name': 'РУННЕН'}
{'keywords': 'Стеллаж', 'price': '1299', 'product_name': 'ХИЛЛИС'}
{'keywords': 'Кружка, сосуд, стакан с ручкой', 'price': '39', 'product_name': 'СТЕЛЬНА'}
{'keywords': 'Молочник', 'price': '299', 'product_name': 'ВАРДАГЕН'}
{'keywords': 'Термос для еды', 'price': '699', 'product_name': 'ЭФТЕРФРОГАД'}
{'keywords': 'Ситечко', 'price': '59', 'product_name': 'ИДЕАЛИСК'}
{'keywords': 'Чайник заварочный', 'price': '499', 'product_name': 'РИКЛИГ'}
{'keywords': 'Кофе-пресс', 'price': '699', 'product_name': 'УПХЕТТА'}
{'keywords': 'Чашка с блюдцем', 'price': '249', 'product_name': 'ИКЕА'}
{'keywords': 'Кружка, стакан с ручкой', 'price': '249', 'product_name': 'ЭМНТ'}
{'keywords': 'Ситечко', 'price': '199', 'product_name': 'САККУННИГ'}
{'keywords': 'Кружка', 'price': '199', 'product_name': 'ФИНСТИЛТ'}
{'keywords': 'Тарелка, блюдце', 'price': '269', 'product_name': 'ЭВЕРЕНС'}

import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';', quotechar='"')
    expensive = sorted(rows, key=lambda item: int(item['price']), reverse=True)
    for record in expensive[:5]:
        print(record)
выводит 5 самых дорогих товаров:

{'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'}
{'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'}
{'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'}
При создании DictReader объекта значениями по умолчанию для аргументов delimiter и quotechar являются ',' (символ запятой) и '"' (символ двойной кавычки) соответственно.

Обратите внимание на то, что при использовании DictReader мы не избавляемся от первой строки, содержащей названия столбцов. При этом к элементам строк мы обращаемся теперь не по индексам (int(item[1])), а по их названиям (int(item['price'])), что намного удобнее.

             Запись данных с помощью writer
Для записи данных в csv файл можно использовать специальный writer объект.

import csv

columns = ['first_name', 'second_name', 'class_number', 'class_letter']
data = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Артур', 'Харисов', 10, 'В']]
with open('students.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(columns)
    for row in data:
        writer.writerow(row)
создает файл students.csv с содержимым:

first_name,second_name,class_number,class_letter
Тимур,Гуев,11,А
Руслан,Чаниев,9,Б
Артур,Харисов,10,В

Обратите внимание на необязательный параметр newline функции open(), который имеет значение '' (пустой строки).
Он отвечает за переводы строк при чтении или записи в текстовый файл. По умолчанию имеет значение None, в этом случае все разделители строк преобразуются в '\n'.
Если в файле оказывается лишний перевод строки, то следует использовать этот параметр в режиме newline='', тогда '\n' будет преобразован в пустую строку.

При создании writer объекта мы так же можем его настраивать, задавая delimeter и многие другие параметры.

Помимо метода writerow() можно использовать и метод writerows(), чтобы записать сразу несколько строк. Единственным аргументом этого метода может быть коллекция коллекций. То есть, каждый элемент списка rows в нашем случае должен быть коллекцией. Если rows будет, например, списком чисел, программа завершится с ошибкой.

Приведенный ниже код:

import csv

columns = ['first_name', 'second_name', 'class_number', 'class_letter']
data = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Роман', 'Белых', 10, 'В']]

with open('students.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)
    writer.writerow(columns)
    writer.writerows(data)
создает файл students.csv с содержимым:

"first_name";"second_name";"class_number";"class_letter"
"Тимур";"Гуев";11;"А"
"Руслан";"Чаниев";9;"Б"
"Роман";"Белых";10;"В"

Запись данных с помощью DictWriter
Для записи данных в csv файл также можно использовать DictWriter объект, который позволяет записывать содержимое словаря в файл.

Приведенный ниже код:

import csv

data = [{'first_name': 'Тимур', 'second_name': 'Гуев', 'class_number': 11, 'class_letter': 'А'},
        {'first_name': 'Руслан', 'second_name': 'Чаниев', 'class_number': 9, 'class_letter': 'Б'},
        {'first_name': 'Роман', 'second_name': 'Белых', 'class_number': 10, 'class_letter': 'В'}]

columns = ['first_name', 'second_name', 'class_number', 'class_letter']

with open('students.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=columns, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)
    writer.writeheader()
    for row in data:
        writer.writerow(row)
создает файл students.csv с содержимым:

"first_name";"second_name";"class_number";"class_letter"
"Тимур";"Гуев";11;"А"
"Руслан";"Чаниев";9;"Б"
"Роман";"Белых";10;"В"
Мы также можем использовать метод writerows() объекта DictWriter для записи сразу нескольких строк. Таким образом вместо строк кода:

for row in data:
    writer.writerow(row)
можно написать:

writer.writerows(data)
Обратите внимание на то, что ключи словарей, которые записываются в файл, должны совпадать с названиям полей, которые переданы в качестве аргумента fieldnames, иначе будет возникать ошибка ValueError.

                                        ------------------работа с json файлами-------------------------------
              модуль json
Преобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией».
В Python для сериализации и десериализации в формат json есть модуль, который так и называется — json.

          Функция dumps()
Для сериализации данных в json строку используется функция dumps() из модуля json. Для того, чтобы сериализовать данные с ее помощью, достаточно передать в нее аргументом любой сериализуемый Python объект. 

Так как json — текстовый формат, то сериализация в него — это по сути преобразование данных в строку.

import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}
json_data = json.dumps(data)            # сериализуем словарь data в json строку

print(type(json_data))          <class 'str'>
print(json_data)               {"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}

Обратите внимание на кавычки, независимо от того, что в Python-словаре мы использовали одинарные, в результирующую строку всегда попадают двойные.

            Функция dump()
В отличие от функции dumps(), которая преобразует (сериализует) Python объект в json строку, функция dump() записывает переданный Python объект в файл.


import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

with open('contries.json', 'w') as file:
    json.dump(data, file)
    
создает файл contries.json и сохраняет в него информацию из словаря data в json формате.
Если открыть файл contries.json, мы увидим, что json выведен в одну строку без форматирования:
{"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}

               Необязательные аргументы indent, sort_keys и separators
Функции записи dumps() и dump() имеют необязательные аргументы indent, sort_keys и separators, которые можно использовать для более удобного чтения человеком.

Аргумент indent задает отступ от левого края. По умолчанию имеет значение None для более компактного представления без отступов.


import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data1 = json.dumps(data, indent=2)
json_data2 = json.dumps(data, indent=10)

print(json_data1)
print(json_data2)
выводит:

{
  "name": "Russia",
  "phone_code": 7,
  "capital": "Moscow",
  "currency": "RUB"
}
{
          "name": "Russia",
          "phone_code": 7,
          "capital": "Moscow",
          "currency": "RUB"
}
Если значением indent является строка, то она используется в качестве отступа.

import json

data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data = json.dumps(data, indent='++++')

print(json_data)
выводит:

{
++++"name": "Russia",
++++"phone_code": 7,
++++"capital": "Moscow",
++++"currency": "RUB"
}
   Отступов также не будет, если значение аргумента indent равно 00, отрицательному числу или пустой строке.

Аргумент sort_keys задает сортировку ключей в результирующем json. По умолчанию имеет значение False для более быстрого создания json.
Если установить значение аргумента в True, то ключи будут отсортированы в алфавитном порядке, что особенно удобно, когда ключей много.

import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data1 = json.dumps(data, indent=3)
json_data2 = json.dumps(data, indent=3, sort_keys=True)

print(json_data1)
print(json_data2)
выводит:

{
   "name": "Russia",
   "phone_code": 7,
   "capital": "Moscow",
   "currency": "RUB"
}
{
   "capital": "Moscow",
   "currency": "RUB",
   "name": "Russia",
   "phone_code": 7
}
Аргумент separators задает кортеж, состоящий из двух элементов (item_separator, key_separator), которые представляют разделители для элементов и ключей.
По умолчанию аргумент имеет значение (', ', ': ').

Приведенный ниже код:

import json

data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data = json.dumps(data, indent=3, separators=(';', ' = '))

print(json_data)
выводит:

{
   "name" = "Russia";
   "phone_code" = 7;
   "capital" = "Moscow";
   "currency" = "RUB"
}

            Функция loads()
Для десериализации данных нужно использовать функцию loads(). Ее аргумент — это строка с данными в формате json.


import json
json_data = '{"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}'

data = json.loads(json_data)
print(type(data))
print(data)
выводит:

<class 'dict'>
{'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}
Как видно из примера, функция loads() десериализует json строку в словарь.
В случае если строка для десериализации содержит данные с ошибкой, то модуль json не сможет правильно прочитать такую строку, и программа завершится с ошибкой.

                    Функция load()
В отличие от функции loads(), которая в качестве аргумента принимает строку с данными в формате json, функция load() принимает файловый объект и возвращает его десериализованное содержимое.

Пусть файл data.json имеет следующее содержимое:

{
  "name": "Russia",
  "phone_code": 7,
  "capital": "Moscow",
  "cities": ["Abakan", "Almetyevsk", "Anadyr", "Anapa", "Arkhangelsk", "Astrakhan"],
  "currency": "RUB"
}
Приведенный ниже код:

import json

with open('data.json') as file:
    data = json.load(file)                # передаем файловый объект
    for key, value in data.items():
        if type(value) == list:
            print(f'{key}: {", ".join(value)}')
        else:
            print(f'{key}: {value}')
читает содержимое data.json файла в словарь data и выводит его содержимое:

name: Russia
phone_code: 7
capital: Moscow
cities: Abakan, Almetyevsk, Anadyr, Anapa, Arkhangelsk, Astrakhan
currency: RUB

             Изменение типа данных(json<==>python)
 Таблица конвертации типов данных Python в JSON:

Python	JSON
dict	object
list, tuple	array
str	string
int, float	number
True	true
False	false
None	null
Таблица конвертации JSON в типы данных Python:

JSON	         Python       
object	dict
array	list
string	str
number (int)	int
number (real)	float
true	True
false	False
null	None

                   Ограничение по типам данных(json)
 формат JSON нельзя записать словарь, у которого ключи – кортежи.

Приведенный ниже код:

import json

data = {
        'beegeek': 2018,
        ('Timur', 'Guev'): 29,
        ('Arthur', 'Kharisov'): 20,
        'stepik': 2013
       }

json_data = json.dumps(data)        # преобразуем dict в json

print(json_data)
генерирует ошибку:

TypeError: keys must be str, int, float, bool or None, not tuple
С помощью необязательного аргумента skipkeys можно игнорировать подобные ключи.

Приведенный ниже код:

import json

data = {
        'beegeek': 2018,
        ('Timur', 'Guev'): 29,
        ('Arthur', 'Kharisov'): 20,
        'stepik': 2013
       }

json_data = json.dumps(data, skipkeys=True)        # преобразуем dict в json

print(json_data)
выводит:

{"beegeek": 2018, "stepik": 2013}
Кроме того, в JSON ключами словаря могут быть только строки. Но, если в словаре Python использовались числа, булевы значения или None, то ошибки не будет, вместо этого они будут преобразованы в строки.

Приведенный ниже код:

import json

data = {1: 'Timur', False: 'Arthur', None: 'Ruslan'}
json_data = json.dumps(data)

print(json_data)
выводит:

{"1": "Timur", "false": "Arthur", "null": "Ruslan"}

                          Кириллические символы в json
import json
data = {'firstName': 'Тимур', 'lastName': 'Гуев'}
s = json.dumps(data)
print(s)
выводит:

{"firstName": "\u0422\u0438\u043c\u0443\u0440", "lastName": "\u0413\u0443\u0435\u0432"}
Результат, скорее всего, будет неожиданным. Каждая буква из строк Тимур и Гуев будет заменена на ее код. Эти коды стандартны, и код для каждой из букв индивидуален. Например. 0438 — код буквы и.  А на этой странице можно посмотреть полное описание этого кода и символа.

Обратное преобразование из строки в словарь вернет закодированное значение в первоначальный вид.

Приведенный ниже код:

import json

data = {'firstName': 'Тимур', 'lastName': 'Гуев'}
s = json.dumps(data)
print(s)
result = json.loads(s)
print(result)
выводит:

{"firstName": "\u0422\u0438\u043c\u0443\u0440", "lastName": "\u0413\u0443\u0435\u0432"}
{'firstName': 'Тимур', 'lastName': 'Гуев'}
Благодаря стандартным кодам, символы будут прочитаны и преобразованы в нужный вид любой программой на любом языке программирования.

С помощью необязательного аргумента ensure_ascii функций dumps() и dump() можно отказаться от такого кодирования.

Приведенный ниже код:

import json

data = {'firstName': 'Тимур', 'lastName': 'Гуев'}
s = json.dumps(data, ensure_ascii=False)
print(s)
result = json.loads(s)
print(result)
выводит:

{"firstName": "Тимур", "lastName": "Гуев"}
{'firstName': 'Тимур', 'lastName': 'Гуев'}
                                                     
                                             -----------------работа с zip файлами---------------------------------
                                             
Архивация (упаковка) – помещение (загрузка) исходных файлов в архивный файл в сжатом или несжатом виде.

Разархивация (распаковка) – процесс восстановления файлов из архива точно в таком виде, какой они имели до загрузки в архив. При распаковке файлы извлекаются из архива и помещаются на диск или в оперативную память;

В Python для работы с zip архивами используется встроенный модуль zipfile. Основное преимущество данного модуля заключается в том, что он позволяет работать с архивом, как с обычной папкой, содержащей файлы и другие каталоги.

             Модуль zipfile
Объекты ZipFile похожи на файловые объекты, возвращаемые функцией open()

В начале работы мы создаем объект типа ZipFile, передавая ему имя архива (архив лежит в той же папке, что и программа).

Метод printdir() выводит таблицу с информацией о содержимом архива: полные названия файлов с указанием даты изменения и размера в байтах.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    zip_file.printdir()
выводит:

File Name                                             Modified             Size
test/                                          2021-11-27 12:47:10            0
test/Картинки/                                 2021-11-27 12:49:02            0
test/Картинки/1.jpg                            2021-09-02 12:30:20        90156
test/Картинки/avatar.png                       2021-08-20 09:38:44        19053
test/Картинки/certificate.png                  2021-10-23 09:46:36        43699
test/Картинки/py.png                           2021-07-28 17:55:56        33522
test/Картинки/World_Time_Zones_Map.png         2021-11-08 07:30:06      2324421
test/Картинки/Снимок экрана.png                2021-10-01 20:47:02        10878
test/Неравенства.djvu                          2021-08-19 08:39:06      5283010
test/Программы/                                2021-11-27 12:48:20            0
test/Программы/image_util.py                   2021-11-18 12:42:22         4955
test/Программы/sort.py                         2021-11-14 19:31:02           61
test/Разные файлы/                             2021-11-27 12:48:10            0
test/Разные файлы/astros.json                  2021-11-08 09:29:58          505
При создании объекта ZipFile мы также можем передать необязательный аргумент mode, который задает режим работы (по аналогии с обычными файлами):

r — файл будет открыт для чтения
w — если файл существует, то он будет уничтожен и вместо него будет создан новый файл
a — существующий файл будет открыт в режиме добавления в конец
   По умолчанию параметр mode имеет значение mode='r', то есть архив открывается для чтения.
   
                  Метод infolist()
Метод infolist() позволяет получить информацию о файлах из архива в виде списка специальных объектов (тип ZipInfo), которые содержат дополнительную информацию о каждом файле:

file_size
compress_size
filename
date_time
...
Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    info = zip_file.infolist()
    print(info[6].file_size)                # размер начального файла в байтах
    print(info[6].compress_size)            # размер сжатого файла в байтах
    print(info[6].filename)                 # имя файла
    print(info[6].date_time)                # дата изменения файла
выводит:

2324421
2322032
test/Картинки/World_Time_Zones_Map.png
(2021, 11, 8, 7, 30, 6)                                 #date_time представляет из себя кортеж (год, месяц, день, час, минута, секунда)

 метод is_dir(), чтобы проверить тип объекта: файл или папка.
 Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    info = zip_file.infolist()
    print(info[0].is_dir())
    print(info[6].is_dir())
выводит:
True
False

                           Метод namelist()
Метод namelist() возвращает список названий файлов и директорий, содержащихся в архиве.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    info = zip_file.namelist()
    print(*info, sep='\n')
выводит: 

test/
test/Картинки/
test/Картинки/1.jpg
test/Картинки/avatar.png
test/Картинки/certificate.png
test/Картинки/py.png
test/Картинки/World_Time_Zones_Map.png
test/Картинки/Снимок экрана.png
test/Неравенства.djvu
test/Программы/
test/Программы/image_util.py
test/Программы/sort.py
test/Разные файлы/
test/Разные файлы/astros.json

                     Метод getinfo()
В отличие от метода infolist(), который позволяет получить информацию о всех файлах из архива в виде списка специальных объектов (тип ZipInfo), метод getinfo() позволяет получить информацию о конкретном файле по его имени в архиве.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    info = zip_file.namelist()                # получаем названия всех файлов архива
    last_file = zip_file.getinfo(info[-4])    # получаем информацию об отдельном файле
    print(last_file.file_size)
    print(last_file.compress_size)
    print(last_file.filename)
    print(last_file.date_time)
выводит:

4955
1641
test/Программы/image_util.py
(2021, 11, 18, 12, 42, 22)

                    Работа с конкретными файлами из архива
Структуру архива мы получили, «вытащим» теперь и конкретный файл.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    with zip_file.open('test/Разные файлы/astros.json') as file:
        print(file.read())
выводит:

b'{"number": 10, "people": [{"craft": "ISS", "name": "Mark Vande Hei"}, {"craft": "ISS", "name": "Pyotr Dubrov"}, {"craft": "ISS", "name": "Thomas Pesquet"}, {"craft": "ISS", "name": "Megan McArthur"}, {"craft": "ISS", "name": "Shane Kimbrough"}, {"craft": "ISS", "name": "Akihiko Hoshide"}, {"craft": "ISS", "name": "Anton Shkaplerov"}, {"craft": "Shenzhou 13", "name": "Zhai Zhigang"}, {"craft": "Shenzhou 13", "name": "Wang Yaping"}, {"craft": "Shenzhou 13", "name": "Ye Guangfu"}], "message": "success"}'
Обратите внимание на символ b перед выводом. Это бинарная строка. Метод file.read() возвращает сырые байты (тип bytes). Для того чтобы преобразовать их в строку (тип str), нужно использовать метод decode(), указав нужную кодировку (файл astros.json имеет кодировку UTF-8).

   Метод ZipFile.open() открывает файл именно в бинарном виде, не в текстовом.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    with zip_file.open('test/Разные файлы/astros.json') as file:
        print(file.read().decode('utf-8'))
выводит:

{"number": 10, "people": [{"craft": "ISS", "name": "Mark Vande Hei"}, {"craft": "ISS", "name": "Pyotr Dubrov"}, {"craft": "ISS", "name": "Thomas Pesquet"}, {"craft": "ISS", "name": "Megan McArthur"}, {"craft": "ISS", "name": "Shane Kimbrough"}, {"craft": "ISS", "name": "Akihiko Hoshide"}, {"craft": "ISS", "name": "Anton Shkaplerov"}, {"craft": "Shenzhou 13", "name": "Zhai Zhigang"}, {"craft": "Shenzhou 13", "name": "Wang Yaping"}, {"craft": "Shenzhou 13", "name": "Ye Guangfu"}], "message": "success"}

Обратите внимание на отсутствие символа b.

                                 Запись в zip архив
По аналогии с чтением файлов из архива их можно туда и записывать, для этого необходимо создать объект ZipFile в режимах mode='w' или mode='a'.

Для записи файла в архив используется метод write(), который принимает имя существующего файла.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('archive.zip', mode='w') as zip_file:
    zip_file.write('program.py')
    zip_file.write('lse.jpeg')
    print(zip_file.namelist())
cоздает в папке с программой архив с именем archive.zip и записывает в него содержимое файлов program.py и lse.jpeg, которые так же находятся в папке с программой, а затем выводит список всех файлов данного архива:

['program.py', 'lse.jpeg']
   Если файлы для записи в архив не будут найдены, то возникнет ошибка (исключение) FileNotFoundError.

Метод write() может принимать еще один строковый аргумент, задающий новое имя файла в архиве.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('archive.zip', mode='w') as zip_file:
    zip_file.write('program.py', 'new_program.py')  # первый аргумент - это имя файла
    zip_file.write('lse.jpeg', 'lse1.jpeg')         # второй аргумент - это имя файла в архиве
    print(zip_file.namelist())                      
cоздает в папке с программой архив с именем archive.zip и записывает в него содержимое файлов program.py и lse.jpeg, которые так же находятся в папке с программой, а затем выводит список всех файлов данного архива:

['new_program.py', 'lse1.jpeg']
Для добавления файлов в уже существующий архив необходимо создать объект ZipFile в режиме mode='a'.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip', mode='a') as zip_file:
    zip_file.write('program.py', 'test/program.py')
    zip_file.write('lse.jpeg')
    print(*zip_file.namelist(), sep='\n')
добавляет два новых файла program.py и lse.jpeg в уже существующий архив test.zip и выводит:

test/
test/Картинки/
test/Картинки/1.jpg
test/Картинки/avatar.png
test/Картинки/certificate.png
test/Картинки/py.png
test/Картинки/World_Time_Zones_Map.png
test/Картинки/Снимок экрана.png
test/Неравенства.djvu
test/Программы/
test/Программы/image_util.py
test/Программы/sort.py
test/Разные файлы/
test/Разные файлы/astros.json
test/program.py
lse.jpeg

Обратите внимание на то, что файл program.py добавлен в папку test, в то время как файл lse.jpeg добавлен в корень архива.

                             Извлечение содержимого zip-файла в каталог
                               
Для извлечения данных из архива в каталог используются методы extract() и extractall().

Если требуется извлечь отдельные файлы, то используется метод extract(), он принимает два аргумента: название файла и путь, по которому требуется извлечь файл. Если путь не указывать, то файл будет извлечен в папку, где находится файл с программой.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    zip_file.extract('test/Картинки/avatar.png')
    zip_file.extract('test/Программы/image_util.py')
    zip_file.extract('lse.jpeg')
извлекает файлы из обновленного архива test.zip.

Если требуется извлечь все содержимое архива, то используется метод extractall(), он принимает в качестве аргумента путь, по которому требуется извлечь все файлы. Если путь не указывать, то файл будет извлечен в папку, где находится файл с программой.

Приведенный ниже код:

from zipfile import ZipFile

with ZipFile('test.zip') as zip_file:
    zip_file.extractall()
извлекает все содержимое файла test.zip в папку, где находится файл с программой, при этом структура каталогов архива сохраняется.

-------------------------------------------------------------работа с модулем pickle-------------------------------------------------------------
                                 Модуль pickle
Как уже было сказано, JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком. С помощью встроенного модуля json можно сериализовать только встроенные типы данных:
bool
dict
int
float
list
string
tuple
None

Помимо сериализации в формат json мы также можем использовать бинарную сериализацию, то есть сериализацию в байты. Для этого в Python используется модуль pickle. Интерфейс взаимодействия с модулем pickle абсолютно такой же, как и для модуля json. Мы будем использовать четыре основных функции:

dump()
load()
dumps()
loads()
Функции dump() и load()
Функция dump() модуля pickle принимает сериализуемый Python объект, сериализует его в бинарный, Python-зависимый формат, используя протокол pickle, и сохраняет его в открытый для записи бинарный файл.

Приведенный ниже код:

import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}

with open('file.pkl', 'wb') as file:
    pickle.dump(obj, file)
создает файл file.pkl, содержащий бинарное представление объекта obj на основе протокола pickle.

Функция load() принимает файловый объект, читает из него сериализованные данные, десериализует их в Python-объект и возвращает полученный Python-объект.

Приведенный ниже код:

import pickle

with open('file.pkl', 'rb') as file:     # используется файл полученный на предыдущем шаге
    obj = pickle.load(file)
    print(obj)
    print(type(obj))
выводит:

{'Python': 1991, 'Java': 1995, 'C#': 2002}
<class 'dict'>

                                        Функции dumps() и loads()
Функция dumps() (обратите внимание на s в конце имени функции) выполняет такую же сериализацию, как и функция dump(). Но вместо того чтобы сохранять сериализованные данные в открытый для записи бинарный файл, она просто возвращает эти сериализованные данные.

Приведенный ниже код:

import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)

print(binary_obj)
print(type(binary_obj))
выводит:

b'\x80\x03}q\x00(X\x06\x00\x00\x00Pythonq\x01M\xc7\x07X\x04\x00\x00\x00Javaq\x02M\xcb\x07X\x02\x00\x00\x00C#q\x03M\xd2\x07u.'
<class 'bytes'>
Поскольку протокол pickle использует бинарный формат данных, функция dumps() возвращает объект типа bytes.

ункция loads() (обратите внимание на s в конце имени функции) выполняет такую же десериализацию, как и функция load(). Но вместо того чтобы принимать файловый объект, она принимает объект типа bytes, содержащий сериализованные данные.

Приведенный ниже код:

import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)

new_obj = pickle.loads(binary_obj)

print(new_obj)
выводит:

{'Python': 1991, 'Java': 1995, 'C#': 2002}
Обратите внимание, что объекты obj и new_obj равны, то есть имеют одинаковое содержимое, однако объекты не являются идентичными. Мы создали идеальную копию, но это всё же копия.

Приведенный ниже код:

import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)
new_obj = pickle.loads(binary_obj)

print(obj == new_obj)
print(obj is new_obj)       # проверка на идентичность
выводит:
True
False

                      Примечания
Примечание 1. Название модуля pickle переводится с английского на русский как мариновать. Название было взято из языка программирования Modula-3, который вдохновил многие функции Python. До официального релиза модуль pickle имел название flatten.

Примечание 2. Модуль pickle может сериализовывать:

все встроенные типы данных (bool, int, float, complex, str, None)
cписки, кортежи, словари и множества, содержащие любую комбинацию встроенных типов данных
cписки, кортежи, словари и множества, содержащие любую комбинацию списков, кортежей, словарей и множеств
функции, классы и экземпляры классов

Примечание 3. Модуль pickle может сериализовывать обычные функции (объявленные с помощью  def), но не может сериализовывать лямбда-функции (объявленные с помощью lambda).

Примечание 4. Модуль pickle может сериализовывать функции из модуля operator.

Примечание 5. Модуль pickle не может сериализовывать генераторы.

Примечание 6. Модули pickle и json делают практически одно и то же, по сути это одна и та же технология, только по-разному реализованная.

Примечание 7. Протокол pickle зависит от Python и не совместим с другими языками программирования. Если необходима совместимость с другими языками программирования, то следует использовать JSON сериализацию.

Примечание 8. Протокол pickle – это бинарный формат данных. Убедитесь, что открываете файлы pickle в бинарном режиме, иначе данные при записи будут повреждены. Формат данных JSON – текстовый, а не двоичный.

Примечание 9. Официальная документации по модулю pickle доступна по ссылке https://docs.python.org/3/library/pickle.html.

Примечание 10. Модуль pickle не защищен. Никогда не десериализуйте данные, полученные из ненадежного источника, так как они могут оказаться вредоносными и выполняющими произвольный код во время распаковки.

Примечание 11. Модуль pickle сериализует и десериализует данные быстрее чем модуль json.

---------------------------------------------------------поверхностное и глубокое копирование объектов------------------------------------------------------
                                                            ----Создание копий объектов--------
Как мы уже знаем, оператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии.

Приведенный ниже код:
data1 = [1, 2, 3]
data2 = data1
data1.append(4)
print(id(data1), data1)
print(id(data2), data2)
всегда выводит равные идентификаторы (числа могут отличаться от запуска к запуску программы):
2371294168448 [1, 2, 3, 4]
2371294168448 [1, 2, 3, 4]
Поскольку списки (тип list) являются изменяемыми, то изменения в data1, также видны в data2.

Для создания реальных копий объектов в Python используют модуль copy.

Модуль copy
Модуль copy содержит две функции:

copy(): копирует объект и возвращает его поверхностную копию
deepcopy(): копирует объект и возвращает его глубокую копию
Поверхностное копирование
Поверхностное копирование создает отдельный новый объект, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти.

Приведенный ниже код:

import copy

data1 = [1, 2, 3]
data2 = copy.copy(data1)
data1.append(4)

print(id(data1), data1)
print(id(data2), data2)
всегда выводит разные идентификаторы (числа могут отличаться от запуска к запуску программы):

2072210867584 [1, 2, 3, 4]
2072250543808 [1, 2, 3]
так как переменная data2 ссылается на новый объект, который представляют копию списка [1, 2, 3]. В данном примере элементами списка являются целые числа (неизменяемый тип int), поэтому изменение одного списка не отражается на другом. Если бы элементами списка были бы изменяемые типы, то поверхностное копирование скопировало бы лишь ссылки на их адреса памяти. Следовательно, любое изменение элементов одного объекта отразилось бы также и на элементах другого объекта.

Приведенный ниже код:

import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)

data1.append([7, 8, 9])

print(id(data1), data1)
print(id(data2), data2)
выводит (числа могут отличаться от запуска к запуску программы):

2320743120512 [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
2320753594368 [[1, 2, 3], [4, 5, 6]]
В то время как приведенный ниже код:

import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)

data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)
print(id(data2), data2)
выводит (числа могут отличаться от запуска к запуску программы):

2088862020160 [[1, 2, 3, 7], [4, 5, 6, 8]]
2088872808384 [[1, 2, 3, 7], [4, 5, 6, 8]]
Изменения затронули оба списка, потому что оба они содержат ссылки на один и тот же вложенный объект. Так работает поверхностное копирование.

Поверхностное копирование создает отдельный новый объект, но вместо того чтобы копировать дочерние элементы в новый объект, оно просто копирует ссылки на их адреса памяти.

Глубокое копирование
Глубокое копирование создает новую и отдельную копию всего объекта со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта, не будут отражаться в исходной, и наоборот.

Приведенный ниже код:

import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.deepcopy(data1)

data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)
print(id(data2), data2)
выводит (числа могут отличаться от запуска к запуску программы):

2001097388608 [[1, 2, 3, 7], [4, 5, 6]]
2001108045760 [[1, 2, 3], [4, 5, 6, 8]]
При глубоком копировании временные затраты на создание копии, очевидно выше чем при создании поверхностной копии. Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может тратить много времени.

Примечания
Примечание 1. У списков, множеств и словарей есть метод copy(), создающий их поверхностную копию.

Приведенный ниже код:

data1 = [1, 2, 3, 4]
data2 = [[1, 2], [3, 4]]

new_data1 = data1.copy()
new_data2 = data2.copy()

print(data1 is new_data1, data1 == new_data1)
print(data2 is new_data2, data2 == new_data2)

new_data1[0] = 100
new_data2[0][0] = 100

print(data1)
print(data2)
выводит:

False True
False True
[1, 2, 3, 4]
[[100, 2], [3, 4]]
   Оператор is проверяет, ссылаются ли две переменные на один объект, оператор == проверяет равенство значений.

Примечание 2. Встроенные функции, используемые при создании коллекций (list, set, dict, ...), также могут быть использованы для создания поверхностной копии объектов.

Приведенный ниже код:

data1 = [1, 2, 3, 4]
data2 = {'a': 1, 'b': 2}
data3 = {1, 2, 3, 4}

new_data1 = list(data1)
new_data2 = dict(data2)
new_data3 = set(data3)

print(data1 is new_data1, data1 == new_data1)
print(data2 is new_data2, data2 == new_data2)
print(data3 is new_data3, data3 == new_data3)
выводит:

False True
False True
False True
Примечание 3. Поверхностную копию списка также можно создать с помощью среза всего списка.

Приведенный ниже код:

data = [1, 2, 3, 4]

new_data = data[:]

print(data is new_data, data == new_data)
выводит:

False True
Однако не стоит забывать, что такая копия является поверхностной.

Приведенный ниже код:

data = [[1, 2], [3, 4]]

new_data = data[:]

data[0][0] = 10
new_data[1][1] = 40
 
print(data)
print(new_data)
выводит:

[[10, 2], [3, 40]]
[[10, 2], [3, 40]]
Примечание 4. Документация модуля copy на русском и английском языках. (https://docs-python.ru/standart-library/modul-copy-python/  ,https://docs.python.org/3/library/copy.html)

Примечание 5. Для определения размера объектов встроенных типов можно использовать функцию getsizeof() модуля sys. Данная функция возвращает размер объекта в байтах.

Приведенный ниже код:

import sys

print(sys.getsizeof(10))
print(sys.getsizeof(True))
print(sys.getsizeof(None))
print(sys.getsizeof(''))
print(sys.getsizeof('beegeek'))
выводит (на 64-х разрядном компьютере):

28
28
16
51
56
Обратите внимание на то, что с помощью функции getsizeof() нельзя вычислять размер сложных объектов, содержащих вложенные структуры (списки списков и т.д.). Для того чтобы правильно определять размер абсолютно любого объекта (включая пользовательские) в Python используется функция asizeof() модуля asizeof, который находится в библиотеке pympler.

---------------------------------------------------------------------Модуль collections----------------------------------------------------------------------------
----------------------------------------------------------Именованные кортежи-----------------------------------------------------------------------
Python содержит встроенный модуль collections, который содержит специализированные типы коллекций, альтернативных традиционным list, tuple, dict:

namedtuple
defaultdict
OrderedDict
Counter
ChainMap
deque
В рамках данного урока мы изучим именованные кортежи (тип namedtuple).

Уверенное владение встроенными модулями, такими как collections, – одна из черт, отличающих продвинутых программистов от начинающих.

Именованные кортежи
Именованные кортежи (тип namedtuple) — это подтип обычных кортежей в Python. У них те же функции, что и у обычных, но их значения можно получать как с помощью индекса (например, [0]), так и с помощью имени через точку (например, .name).

   Основное предназначение именованных кортежей — это улучшение читаемости программного кода.

Рассмотрим пример, в котором происходит работа с точкой на плоскости, имеющей две координаты x и y.

Приведенный ниже код использует функционал обычных кортежей (тип tuple):

point = (3, 7)

print(point)
print(point[0], point[1])
print(type(point))
и выводит:

(3, 7)
3 7
<class 'tuple'>
Не забывайте, что кортежи являются неизменяемыми, при попытке изменить значение кортежа мы получим ошибку TypeError.

Приведенный выше код работает как и полагается: он создает точку с двумя координатами. Однако является ли данный код читабельным? Можно ли заранее сказать, за что отвечают индексы 0 и 1? Всегда ли нулевой индекс — это значение x, а первый индекс — значение y?

Чтобы предотвратить эту двусмысленность и сделать код читабельнее, мы можем использовать именованный кортеж.

Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])     # объявляем тип Point именованного кортежа

point = Point(3, 7)                         # создаем именованный кортеж Point

print(point)
print(point.x, point.y)
print(point[0], point[1])
print(type(point))
выводит:

Point(x=3, y=7)
3 7
3 7
<class '__main__.Point'>
В приведенном выше коде мы создали объект типа Point, который является именованным кортежем. Обратиться к полям именованного кортежа можно через точку (point.x, point.y) или по индексу (point[0], point[1]), как и в обычных кортежах.

Важно отметить, что, хотя кортежи и именованные кортежи неизменяемы, сохраняемые в них значения не обязательно должны быть неизменяемыми. Совершенно законно создать кортеж или именованный кортеж, содержащий изменяемые значения.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'children'])

sveta = Person('Sveta Gueva', ['Larisa', 'Timur'])
print(sveta)

sveta.children.append('Soslan')
print(sveta)
выводит:

Person(name='Sveta Gueva', children=['Larisa', 'Timur'])
Person(name='Sveta Gueva', children=['Larisa', 'Timur', 'Soslan'])
При этом код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'children'])

sveta = Person('Sveta Gueva', ['Larisa', 'Timur'])
sveta.children = ['Larisa', 'Timur', 'Soslan']
приведет к ошибке AttributeError.

Таким образом, мы можем создавать именованные кортежи, содержащие изменяемые объекты. Мы можем изменять изменяемые объекты в исходном кортеже. Однако это не означает, что мы изменяем сам кортеж. Кортеж продолжит содержать те же ссылки на память.

Кортежи и именованные кортежи с изменяемыми значениями не могут быть хешированы, поэтому не могут быть элементами множеств и ключами в словарях. Кортежи и именованные кортежи без изменяемых значений могут быть хешированы, поэтому могут быть элементами множеств и ключами в словарях.

Функция namedtuple()
Функция namedtuple() выступает в роли фабричной функции, порождающей новые типы данных.

Сигнатура данной функции имеет вид: 

namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)
То есть функция принимает два обязательных параметра typename и field_names и три необязательных rename, defaults, module, имеющих значения по умолчанию False, None, None соответственно.

Параметры typename и field_names
Параметр typename отвечает за имя создаваемого типа, параметр field_names за названия полей. Имя типа — это строка с типом, который нужно сделать именованным кортежем. В качестве параметра field_names можно использовать:

список
словарь
кортеж
строка
множество
Параметр field_names является списком:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])    # в качестве второго параметра передаем список
point =  Point(2, 4)
print(point)                               # выводит Point(x=2, y=4)
Параметр field_names является кортежем:

from collections import namedtuple

Point = namedtuple('Point', ('x', 'y'))    # в качестве второго параметра передаем кортеж
point =  Point(2, 4)
print(point)                               # выводит Point(x=2, y=4)
Параметр field_names является словарем:

В этом случае для полей именованного кортежа используются ключи словаря, поэтому в качестве значений можно указать, все что угодно.

from collections import namedtuple

Point = namedtuple('Point', {'x': 0, 'y': 69})    # в качестве второго параметра передаем словарь
point =  Point(2, 4)
print(point)                                      # выводит Point(x=2, y=4)
Параметр field_names является строкой:

При создании именованного кортежа с помощью строки мы указываем поля либо через символ пробела, либо разделяя их символом ,.

from collections import namedtuple

Point = namedtuple('Point', 'x y')    # в качестве второго параметра передаем строку
point =  Point(2, 4)
print(point)                          # выводит Point(x=2, y=4)
либо:

from collections import namedtuple

Point = namedtuple('Point', 'x,y')     # в качестве второго параметра передаем строку
point =  Point(2, 4)
print(point)                           # выводит Point(x=2, y=4)
Параметр field_names является множеством:

Мы можем создать именованный кортеж с помощью множества, однако делать это не рекомендуется. Как мы знаем множество – это неупорядоченный набор данных. Когда мы используем неупорядоченный набор данных для предоставления полей именованному кортежу, мы можем получить неожиданный результат.

Результатом работы кода:

from collections import namedtuple

Point = namedtuple('Point', {'x', 'y'})    # в качестве второго параметра передаем множество
point =  Point(2, 4)
print(point)
может быть как:

Point(x=2, y=4)
так и:

Point(y=2, x=4)
В приведенном выше примере имена координат меняются местами, что может не подходить для вашего варианта использования.

 В качестве параметра field_names можно передавать любой итерируемый объект, например, результат вызова   функций map() и filter().

Обратите также внимание на то, что создавать именованные кортежи можно не только с помощью позиционных аргументов, но и с помощью именованных.

Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
point1 = Point(2, 4)                          # позиционные аргументы
point2 = Point(y=10, x=3)                     # именованные аргументы

print(point1)
print(point2)
выводит:

Point(x=2, y=4)
Point(x=3, y=10)
В качестве названия полей для именованных кортежей мы можем использовать любое корректное название имени переменной, за исключением:

имен, начинающихся с подчеркивания (_)
ключевых слов языка Python (if, with, else, class, ...)
Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', '_y'])
приводит к возникновению ошибки: ValueError: Field names cannot start with an underscore: '_y'.

Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'if'])
приводит к возникновению ошибки: ValueError: Type names and field names cannot be a keyword: 'if'.

Параметр rename
Допустим, мы импортируем данные из CSV-файла и превращаем каждую строку в именованный кортеж. Структура файла имеет вид:

name,surname,age,class
Timur,Guev,28,11
Ruslan,Chaniev,22,9
...
Названия полей мы берем из заголовка CSV-файла:

from collections import namedtuple

headers = ('name', 'surname', 'age', 'class')

Student = namedtuple('Student', headers)
Поскольку одно поле имеет название class (ключевое слово языка Python) мы получаем ошибку: ValueError: Type names and field names cannot be a keyword: 'class'.

Проблема заключается в том, что мы не знаем, будут ли в качестве названий полей у нас ключевые слова языка Python или нет. Для решения данной проблемы можно использовать параметр rename со значением True.

Приведенный ниже код:

from collections import namedtuple

headers = ('name', 'surname', 'age', 'class')

Student = namedtuple('Student', headers, rename=True)

stud = Student('Роман', 'Белых', 26, 10)
print(stud)
выводит:

Student(name='Роман', surname='Белых', age=26, _3=10)
Обратите внимание на то, что Python автоматически переименовал поле class в _3.

Приведенный ниже код:

from collections import namedtuple

headers = ('name', 'surname', 'age', 'class', 'with', 'color', 'name', 'class', 'if')

Student = namedtuple('Student', headers, rename=True)

stud = Student('Тимур', 'Гуев', 28, 11, 'sister', 'green', 'Tim', '11A', 'else')
print(stud)
выводит:

Student(name='Тимур', surname='Гуев', age=28, _3=11, _4='sister', color='green', _6='Tim', _7='11A', _8='else')
Как мы видим, неудачные имена полей переименовались в соответствии с их порядковыми номерами, причем перед порядковым номером используется символ подчеркивания.

Параметр defaults
Параметр defaults используется для того, чтобы установить значения по умолчанию для полей именованного кортежа.

Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'], defaults=(0, 0))
point1 = Point()      # используем значения по умолчанию
point2 = Point(1, 9)

print(point1)
print(point2)
выводит:

Point(x=0, y=0)
Point(x=1, y=9)
Можно указать значение по умолчанию только для некоторых полей, при этом defaults присваивает значения по умолчанию с конца.

Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'], defaults=(0,))
point =  Point(7)      # используем значения по умолчанию для y
print(point)
выводит:

Point(x=7, y=0)
   Имейте в виду, что параметр defaults работает только в Python 3.7+.

Параметр module
Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
point = Point(1, 2)
print(type(point))
выводит:

<class '__main__.Point'>
Если мы укажем допустимое имя модуля для этого аргумента, тогда атрибуту .__ module__ результирующего именованного кортежа будет присвоено это значение.

Приведенный ниже код:

from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'], module='customtypes')
point = Point(1, 2)
print(type(point))
выводит:

<class 'customtypes.Point'>
Параметр module был добавлен в Python 3.6 для того, чтобы появилась возможность сериализовать/десериализовать именованные кортежи с помощью модуля pickle.

Распаковка именованного кортежа
Мы можем распаковывать именованный кортеж, также как и обычный.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)

name, age, height = timur

print(name)
print(age)
print(height)
выводит:

Тимур
29
170

Примечание . При работе с именованным кортежами мы можем использовать срезы.

from collections import namedtuple

Point = namedtuple('Point3D', ['x', 'y', 'z'])
point = Point(89, 54, -34)

print(point[1:])
print(point[:2])
print(point[1:2])
выводит:
(54, -34)
(89, 54)
(54,)

                    -----Атрибуты _fields, _field_defaults----
Именованные кортежи имеют два дополнительных атрибута: _fields и _field_defaults.
Первый атрибут содержит кортеж строк, в котором перечислены имена полей.
Второй атрибут содержит словарь, который сопоставляет имена полей с соответствующими значениями по умолчанию, если таковые имеются.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])
tim = Person('Тимур', 29, 170)

print(tim)
print(tim._fields)
print(Person._fields)
выводит:

Person(name='Тимур', age=29, height=170)
('name', 'age', 'height')
('name', 'age', 'height')
Обратите внимание на то, что мы можем обращаться к атрибуту _fields как через переменную (tim), так и через сам тип именованного кортежа (Person).

С помощью атрибута _fields мы можем создавать новые именованные кортежи на основании уже существующих. В следующем примере мы создадим новый именованный кортеж с именем ExtendedPerson, который расширяет старый Person новым полем weight.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

ExtendedPerson = namedtuple('ExtendedPerson', [*Person._fields, 'weight'])  # распаковка полей старого кортежа

timur = ExtendedPerson('Тимур', 29, 170, 65)

print(timur)
print(ExtendedPerson._fields)
выводит:

ExtendedPerson(name='Тимур', age=29, height=170, weight=65)
('name', 'age', 'height', 'weight')
Мы также можем использовать атрибут _fields для перебора полей и их значений с помощью встроенной функции zip():

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)

for field, value in zip(Person._fields, timur):
    print(field, '->', value)
выводит:

name -> Тимур
age -> 29
height -> 170

С помощью атрибута _field_defaults мы можем выяснить, какие поля именованного кортежа имеют значения по умолчанию.
Значения по умолчанию делают поля необязательными.
Например, предположим, что наш именованный кортеж Person должен включать дополнительное поле для хранения страны, в которой живет человек.
Поскольку в основном мы работаем с людьми из России, то мы устанавливаем соответствующее значение по умолчанию для поля страны следующим образом:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height', 'country'], defaults=['Russia'])

timur = Person('Тимур', 29, 170)

print(timur)
print(timur._field_defaults)
print(Person._field_defaults)
Приведенный выше код выводит:

Person(name='Тимур', age=29, height=170, country='Russia')
{'country': 'Russia'}
{'country': 'Russia'}
Если именованный кортеж не предоставляет значений по умолчанию, тогда атрибут _field_defaults содержит пустой словарь.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height', 'country'])

timur = Person('Тимур', 29, 170, 'Russia')

print(Person._field_defaults)
выводит:

{}

                             ----------Методы _make(), _replace(), _asdict()--------------
Напомним, что обычные кортежи (tuple) имеют два встроенных метода:

index(): возвращает индекс первого элемента, значение которого равняется переданному значению
count(): возвращает количество элементов в кортеже, значения которых равны переданному значению
Именованные кортежи (тип namedtuple) являются производными от обычных кортежей (тип tuple), поэтому наследует их методы, а также добавляют три новых: _make(), _replace(), _asdict().

Имена новых методов (_make(), _replace(), _asdict()) и атрибутов (_fields, _field_defaults) начинаются с подчеркивания,  чтобы предотвратить конфликты имен с полями именованных кортежей.

                              --------------Метод _make()-------------
Метод _make() используется для создания именованных кортежей из итерируемых объектов (список, кортеж, строка, словарь и т.д.).

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person._make(['Timur', 29, 170])

print(timur)
выводит:

Person(name='Timur', age=29, height=170)
Обратите внимание на то, что метод _make() – это метод типа, а не конкретного экземпляра, поэтому вызывать его нужно через название типа (Person._make). Метод _make() работает как альтернативный конструктор типа.

                                    -------------Метод _asdict()-------------
Мы можем преобразовывать именованные кортежи в словари с помощью метода _asdict().
Этот метод возвращает словарь, в котором имена полей используются в качестве ключей.
Ключи результирующего словаря находятся в том же порядке, что и поля в исходном именованном кортеже.

Приведенный ниже код:

from collections import namedtuple
Person = namedtuple('Person', ['name', 'age', 'height'])
timur = Person._make(['Timur', 29, 170])

print(timur._asdict())
выводит:

{'name': 'Timur', 'age': 29, 'height': 170}
До Python 3.8 метод _asdict() возвращал тип данных OrderedDict.
В настоящий момент метод возвращает обычный словарь (тип dict), так как сейчас словари запоминают порядок добавления в них ключей.

                          --------------------Метод _replace()-----------------
Метод _replace() позволяет создавать новые именованные кортежи на основании уже существующих с заменой некоторых значений.
Потребность в данном методе вызвана тем, что именованные кортежи являются неизменяемыми.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height', 'country'])

timur1 = Person('Тимур', 29, 170, 'Russia')
timur2 = timur1._replace(age=30, country='Germany')

print(timur1)
print(timur2)
выводит:

Person(name='Тимур', age=29, height=170, country='Russia')
Person(name='Тимур', age=30, height=170, country='Germany')
Обратите внимание на то, что метод _replace() не изменяет текущий именованный кортеж, а возвращает новый.

Сравнение именованных кортежей и словарей
Словарь (dict) — это фундаментальная структура данных в Python. Сам язык построен на словарях, они используются повсюду. Несложно заметить, что функционал именованных кортежей можно полностью заменить функционалом словарей. Давайте проведем небольшое сравнение именованных кортежей и словарей по следующим параметрам:

читабельность (readability)
изменяемость (mutability)
потребление памяти (memory usage)
производительность (performance)
Читабельность
С точки зрения удобочитаемости вы, вероятно, можете сказать, что словари так же читабельны, как и именованные кортежи. Несмотря на то что они не обеспечивают доступа к атрибутам через точечную нотацию, поиск ключей в стиле словаря довольно удобочитаем и прост.

Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)

print(timur.name)
print(timur.age)
print(timur.height)
без потери читабельности можно заменить на код:

timur = {'name': 'Тимур', 'age': 29, 'height': 170}

print(timur['name'])
print(timur['age'])
print(timur['height'])
В обоих примерах мы полностью понимаем код и его назначение. Однако для определения именованного кортежа требуются две дополнительные строки кода: одна строка для импорта фабричной функции namedtuple(), а другая — для определения самого именованного кортежа Person.

Доступ к атрибутам через точечную нотацию выглядит немного аккуратнее чем через квадратные скобки. Также нужно заметить, что при использовании квадратных скобок нам нужно использовать символ кавычки.

Изменяемость
Большая разница между обеими структурами данных заключается в том, что словари изменяемы, а именованные кортежи неизменны. Это означает, что вы можете изменять словари на месте (подобно спискам), но не можете изменять именованные кортежи (подобно обычным кортежам).

Приведенный ниже код:

timur = {'name': 'Тимур', 'age': 29, 'height': 170}
timur['age'] = 30      # изменяем значение в словаре

print(timur['age'])    # выводим измененное значение
выводит:

30
 Приведенный ниже код:

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)
timur.age = 30

print(timur.age)
приводит к возникновению ошибки:

AttributeError: can't set attribute
Мы всегда можем обновить значение существующего ключа в словаре, но не можем сделать того же самого в именованном кортеже. Мы также можем добавлять новые пары "ключ-значение" в существующие словари, но не можем добавлять пары "поле-значение" в существующие именованные кортежи.

В именованных кортежах мы можем использовать  метод _replace() для обновления значения некоторого поля, но этот метод создает и возвращает новый именованный экземпляр кортежа вместо обновления на месте.

Потребление памяти
Для сравнения потребления памяти именованным кортежем и словарем мы будем использовать функцию asizeof() модуля pympler.

Приведенный ниже код:

from collections import namedtuple
from pympler import asizeof

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)
timur_dct = {'name': 'Тимур', 'age': 29, 'height': 170}

print(f'Именованный кортеж: {asizeof.asizeof(timur)} байт')
print(f'Словарь: {asizeof.asizeof(timur_dct)} байт')
выводит:

Именованный кортеж: 112 байт
Словарь: 304 байт
Именованный кортеж потребляет меньше памяти (примерно на 
63
%
63%), чем эквивалентный словарь. Поэтому, если потребление памяти является ограничением, следует подумать об использовании именованного кортежа вместо словаря.

Когда мы сравниваем именованные кортежи и словари, разница в конечном потреблении памяти будет зависеть от количества полей (значений) и их типов. Используя разные значения, мы будем получать разные результаты.

Производительность
Наконец, нам нужно иметь представление о том, насколько сильно различаются именованные кортежи и словари с точки зрения производительности операций. Для этого мы будем тестировать операции принадлежности и операции доступа к атрибутам.

Приведенный ниже код:

from collections import namedtuple
from time import perf_counter

def average_time(structure, test_func):
    time_measurements = []
    for _ in range(1_000_000):
        start = perf_counter()
        test_func(structure)
        end = perf_counter()
        time_measurements.append(end - start)
    return sum(time_measurements) / len(time_measurements) * int(10**9)

def time_dict(dictionary):
    'name' in dictionary
    'missing_key' in dictionary
    28 in dictionary.values()
    'missing_value' in dictionary.values()
    dictionary['age']

def time_namedtuple(named_tuple):
    'name' in named_tuple._fields
    'missing_field' in named_tuple._fields
    28 in named_tuple
    'missing_value' in named_tuple
    named_tuple.age

Person = namedtuple('Person', ['name', 'age', 'height'])

timur = Person('Тимур', 29, 170)
timur_dct = {'name': 'Тимур', 'age': 29, 'height': 170}

print(f'Именованный кортеж: {average_time(timur, time_namedtuple)} наносекунд')
print(f'Словарь: {average_time(timur_dct , time_dict)} наносекунд')
выводит (результат может незначительно отличаться):

Именованный кортеж: 382 наносекунд
Словарь: 508 наносекунд
Таким образом, именованные кортежи работают немного быстрее, чем словари по отношению к операциям принадлежности и доступа к атрибутам.

Итоговая таблица сравнения:

Характеристика                 / тип	Именованный кортеж	   Словарь
Читабельность (readability)	               ✔️	                 ✔️
Изменяемость (mutability)	                 ❌	                ✔️
Потребление памяти (memory usage)	         ✔️	                 ❌
Производительность (performance)	         ✔️	                 ❌

---------------------------------------------------------------Тип данных defaultdict---------------------------------------------------------------------
Тип defaultdict ведет себя почти так же, как обычный словарь dict, но если мы попытаемся получить доступ (или изменить значение) по несуществующему ключу,
то defaultdict автоматически создаст ключ и сгенерирует для него значение по умолчанию.
Такое поведение делает defaultdict удобным вариантом обработки недостающих ключей в словарях.

Для того чтобы не возникало ошибки при обращении по несуществующему ключу с помощью квадратных скобок, достаточно использовать альтернативный вариант словаря – defaultdict.

Приведенный ниже код:

from collections import defaultdict

info = defaultdict(int)       # создаем словарь со значением по умолчанию 0

info['name'] = 'Timur'
info['age'] = 29
info['job'] = 'Teacher'

print(info['salary'])
print(info)
выводит:

0
defaultdict(<class 'int'>, {'name': 'Timur', 'age': 29, 'job': 'Teacher', 'salary': 0})
Функция defaultdict() принимает в качестве аргумента тип элемента по умолчанию. Таким образом, для ключей, к которым происходит обращение, словарь defaultdict поставит в соответствие дефолтный элемент данного типа:

для int – число 0
для float – число 0.0
для bool – значение False
для str – пустая строка ''
для list – пустой список []
для tuple – пустой кортеж ()
для set – пустое множество set()
для dict – пустой словарь {}
Помимо первого аргумента – типа элемента по умолчанию – мы можем передать второй аргумент: словарь, на основании которого будет создан defaultdict.

Приведенный ниже код:

from collections import defaultdict

info = defaultdict(int, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})

print(info['name'])
print(info['salary'])
print(info)
выводит:

Timur
0
defaultdict(<class 'int'>, {'name': 'Timur', 'age': 29, 'job': 'Teacher', 'salary': 0})
Также допустимы все способы, которые мы используем при создании обычных словарей, а именно передача именованных аргументов или итерируемого объекта,
содержащего пары ключ-значение (например, список кортежей).

Приведенный ниже код:

from collections import defaultdict

info1 = defaultdict(int, name='Timur', age=29, job='Teacher')
info2 = defaultdict(int, [('name', 'Timur'), ('age', 29), ('job', 'Teacher')])

print(info1)
print(info2)
выводит:

defaultdict(<class 'int'>, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})
defaultdict(<class 'int'>, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})
Обратите внимание, что при создании словаря defaultdict мы можем указать только именованные аргументы,
но не можем указать только итерируемый объект с парами ключ-значение (или словарь).

Приведенный ниже код:

from collections import defaultdict

info = defaultdict(name='Timur', age=29, job='Teacher')

print(info)
выводит: 

defaultdict(None, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})
В то время как следующий код:

from collections import defaultdict

info = defaultdict([('name', 'Timur'), ('age', 29), ('job', 'Teacher')])

print(info)
приводит к возникновению ошибки, так как в качестве первого аргумента должен быть указан тип элемента по умолчанию, а не итерируемый объект с парами ключ-значение (или словарь).

Рассмотрим задачу: пусть задан список чисел numbers, в котором некоторые числа встречаются несколько раз.
Нужно узнать, сколько именно раз встречается каждое из чисел.
С помощью типа данных defaultdict:

from collections import defaultdict

numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]
result = defaultdict(int)
for num in numbers:
    result[num] += 1

Тип данных defaultdict часто используют в связке с пустым списком в качестве значения по умолчанию, чтобы начинать добавление элементов без лишнего кода.

Приведенный ниже код работает так, как полагается:

from collections import defaultdict

my_dict = defaultdict(list)

for i in range(7):
    my_dict[i].append(i)

for key in my_dict:
    print(key, my_dict[key])
и выводит:

0 [0]
1 [1]
2 [2]
3 [3]
4 [4]
5 [5]
6 [6]
При использовании defaultdict нет необходимости ни проверять наличие соответствующих ключей в словаре, ни создавать предварительно пустые списки.

          Когда использовать defaultdict?
Приведем несколько рекомендаций, когда удобно использовать defaultdict, вместо dict:
1)Если ваш код в значительной степени основан на словарях и вы все время имеете дело с отсутствующими ключами, вам следует подумать об использовании defaultdict,
    а не обычного dict
2)Если элементы вашего словаря необходимо инициализировать некоторым значением по умолчанию, вам следует подумать об использовании defaultdict, вместо dict
3)Если ваш код использует словари для агрегирования, накопления, подсчета или группировки значений, вам следует подумать об использовании defaultdict, вместо dict

           Примечания
Примечание 1. Тип defaultdict наследуется от типа dict.

Приведенный ниже код:
from collections import defaultdict
print(issubclass(defaultdict, dict))
выводит:
True
Таким образом, все методы доступные для обычных словарей (тип dict), также доступны и для defaultdict словарей.

Примечание 2. Мы можем сравнивать обычные словари (тип dict) и defaultdict словари.

Приведенный ниже код:

from collections import defaultdict
info1 = {'name': 'Timur', 'age': 29, 'job': 'Teacher'}
info2 = defaultdict(int, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})
print(info1 == info2)

выводит:
True

римечание 3. При создании defaultdict словаря можно указывать не только тип данных для значений по умолчанию, но и любую функцию, не принимающую аргументов и возвращающую некоторое дефолтное значение.

Приведенный ниже код (передаем функцию, объявленную с помощью def):

from collections import defaultdict

def get_default():
    return 69

info = defaultdict(get_default, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})

print(info['name'])
print(info['salary'])
выводит:

Timur
69
 Приведенный ниже код (передаем функцию, объявленную с помощью lambda):

from collections import defaultdict

info = defaultdict(lambda: '1000000$', {'name': 'Timur', 'age': 29, 'job': 'Teacher'})

print(info['name'])
print(info['salary'])
выводит:

Timur
1000000$
Обратите внимание, что передаваемая функция не должна принимать никаких аргументов.

Приведенный ниже код:

from collections import defaultdict

def get_default(x):
    return 2 * x

info = defaultdict(get_default, {'name': 'Timur', 'age': 29, 'job': 'Teacher'})

print(info['name'])
print(info['salary'])
приводит к возникновению ошибки.

Примечание 4. Если создать экземпляр defaultdict словаря без указания default_factory (значения по умолчанию для отсутствующих ключей),
то поведение defaultdict будет таким же, как и у обычного словаря (тип dict).

Приведенный ниже код:
from collections import defaultdict
data = defaultdict()
print(data['salary'])
приводит к возникновению ошибки KeyError.

Аналогичное поведение будет, если в качестве default_factory передать значение None.

Приведенный ниже код:

from collections import defaultdict

data = defaultdict(None)

print(data['salary'])
также приводит к возникновению ошибки KeyError.

   Значение None является значением по умолчанию для default_factory.

Примечание 5. Функцию, которая возвращает значение по умолчанию для отсутствующих ключей, можно явно менять через атрибут default_factory.

Приведенный ниже код:

from collections import defaultdict

data = defaultdict(int)
print(data['salary1'])

data.default_factory = list
print(data['salary2'])

data.default_factory = float
print(data['salary3'])
выводит:

0
[]
0.0
Примечание 6. Тип defaultdict работает быстрее чем использование методов setdefault() и get() обычного словаря (тип dict).
