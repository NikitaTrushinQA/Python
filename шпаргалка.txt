                                                           "Функции и методы строк"
Функция или метод	                               
S = 'str'; S = "str"; S = '''str'''; S = """str"""	Литералы строк
S = "s\np\ta\nbbb"	Экранированные последовательности
S = r"C:\temp\new"	Неформатированные строки (подавляют экранирование)
S = b"byte"	Строка байтов
S1 + S2	Конкатенация (сложение строк)
S1 * 3	Повторение строки
S[i]	Обращение по индексу
S[i:j:step]	Извлечение среза
len(S)	Длина строки
S.find(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или -1
S.rfind(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
S.index(str, [start],[end])	Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
S.rindex(str, [start],[end])	Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
S.replace(шаблон, замена[, maxcount])	Замена шаблона на замену. maxcount ограничивает количество замен
S.split(символ)	Разбиение строки по разделителю
S.isdigit()	Состоит ли строка из цифр
S.isalpha()	Состоит ли строка из букв
S.isalnum()	Состоит ли строка из цифр или букв
S.islower()	Состоит ли строка из символов в нижнем регистре
S.isupper()	Состоит ли строка из символов в верхнем регистре
S.isspace()	Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'),
"горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
S.istitle()	Начинаются ли слова в строке с заглавной буквы
S.upper()	Преобразование строки к верхнему регистру
S.lower()	Преобразование строки к нижнему регистру
S.startswith(str)	Начинается ли строка S с шаблона str
S.endswith(str)	Заканчивается ли строка S шаблоном str
S.join(список)	Сборка строки из списка с разделителем S
ord(символ)	Символ в его код ASCII
chr(число)	Код ASCII в символ
S.capitalize()	Переводит первый символ строки в верхний регистр, а все остальные в нижний
S.center(width, [fill])	Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
S.count(str, [start],[end])	Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)
S.expandtabs([tabsize])	Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца.
Если TabSize не указан, размер табуляции полагается равным 8 пробелам
S.lstrip([chars])	Удаление пробельных символов в начале строки
S.rstrip([chars])	Удаление пробельных символов в конце строки
S.strip([chars])	Удаление пробельных символов в начале и в конце строки
S.partition(шаблон)	Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
S.rpartition(sep)	Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку
S.swapcase()	Переводит символы нижнего регистра в верхний, а верхнего – в нижний
S.title()	Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
S.zfill(width)	Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
S.ljust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
S.rjust(width, fillchar=" ")	Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
S.format(*args, **kwargs)	Форматирование строки                                                                       
                                                                                                                                                                        
                                                                        zfill()
Метод zfill() Метод zfill() возвращает копию строки с заполненным 0 слева. 
Длина возвращаемой строки зависит от предоставленной ширины 

str.zfill(width)

Если строка начинается с префикса знака (‘+’, ‘-‘), 0 цифр заполняется после первого символа префикса знака.
number = "-290" print(number.zfill(8))        ==> -0000290

                                                                 метод compress()
Метод compress() модуля itertools создает итератор, который фильтрует элементы из данных s,возвращая только те,
которые имеют соответствующий элемент, равный True или 1 в последовательности lst.

from itertools import compress
s = 'abcd'
lst = [1,0,1,0]
rez = compress(s, lst)
print(list(rez)  =====> ['a','c']
           
                                                                   "Функции и методы списков"
list.append(x)	Добавляет элемент в конец списка
list.extend(L)	Расширяет список list, добавляя в конец все элементы списка L
list.insert(i, x)	Вставляет на i-ый элемент значение x
list.remove(x)	Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует
list.pop([i])	Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент
list.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)
list.count(x)	Возвращает количество элементов со значением x
list.sort([key=функция])	Сортирует список на основе функции
list.reverse()	Разворачивает список
list.copy()	Поверхностная копия списка
list.clear()	Очищает список

                                                                      Методы словарей
dict.clear() - очищает словарь.

dict.copy() - возвращает копию словаря.

classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

dict.get(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

dict.items() - возвращает пары (ключ, значение).

dict.keys() - возвращает ключи в словаре.

dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.

dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).

dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

dict.values() - возвращает значения в словаре.
                                                           операции множеств
С множествами можно выполнять множество операций: находить объединение, пересечение...

len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
И операции, непосредственно изменяющие множество:

set.update(other, ...); set |= other | ... - объединение.
set.intersection_update(other, ...); set &= other & ... - пересечение.
set.difference_update(other, ...); set -= other | ... - вычитание.
set.symmetric_difference_update(other); set ^= other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.add(elem) - добавляет элемент в множество.
set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.
set.discard(elem) - удаляет элемент, если он находится в множестве.
set.pop() - удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым.
set.clear() - очистка множества.

                                                      Список методов модуля random в Python:

Метод	            Описание
seed()	Инициализация генератора случайных чисел
getstate()	Возвращает текущее внутренне состояние (state) генератора случайных чисел
setstate()	Восстанавливает внутреннее состояние (state) генератора случайных чисел
getrandbits()	Возвращает число, которое представляет собой случайные биты
randrange()	Возвращает случайное число в пределах заданного промежутка
randint()	Возвращает случайное число в пределах заданного промежутка
choice()	Возвращает случайный элемент заданной последовательности
choices()	Возвращает список со случайной выборкой из заданной последовательности
shuffle()	Берет последовательность и возвращает ее в перемешанном состоянии
sample()	Возвращает заданную выборку последовательности
random()	Возвращает случайное вещественное число в промежутке от 0 до 1
uniform()	Возвращает случайное вещественное число в указанном промежутке
triangular()	Возвращает случайное вещественное число в промежутке между двумя заданными параметрами. Также можно использовать параметр mode для уточнения середины между указанными параметрами
betavariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Бета-распределении, которое используется в статистике
expovariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, или же между 0 и -1, когда параметр отрицательный. За основу берется Экспоненциальное распределение, которое используется в статистике
gammavariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Гамма-распределении, которое используется в статистике
gauss()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Гауссовом распределении, которое используется в теории вероятности
lognormvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Логнормальном распределении, которое используется в теории вероятности
normalvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на Нормальном распределении, которое используется в теории вероятности
vonmisesvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении фон Мизеса, которое используется в направленной статистике
paretovariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении Парето, которое используется в теории вероятности
weibullvariate()	Возвращает случайное вещественное число в промежутке между 0 и 1, основываясь на распределении Вейбулла, которое используется в статистике
                                                  Модуль queue, очереди в Python(FIFO,LIFO)
Модуль реализует три типа очереди, которые отличаются только порядком, в котором извлекаются записи:
1)В очереди FIFO первые добавленные задачи являются первыми извлеченными.
2)В очереди LIFO самая последняя добавленная запись является первой извлеченной (работающей как стек).
3)В очереди с приоритетами записи сохраняются отсортированными с использованием модуля heapq и сначала извлекается запись с наименьшим значением.

    Очередь FIFO:
Класс queue.Queue() реализует базовый контейнер типа FIFO - "первым пришел - первым вышел".
Элементы добавляются к одному концу очереди с помощью метода put(), а удаляются с другого конца с помощью метода get().
import queue
q = queue.Queue()
for i in range(5):
    q.put(i)
while not q.empty():
    print(q.get(), end=' ')

# 0 1 2 3 4

       Очередь LIFO:
В отличие от стандартной реализации очереди FIFO, в queue.LifoQueue() используется порядок "последним пришел - первым вышел",
который обычно связан со структурой данных стека.
import queue
q = queue.LifoQueue()
for i in range(5):
    q.put(i)
while not q.empty():
    print(q.get(), end=' ')

# 4 3 2 1 0

        Очередь с приоритетом:
Иногда порядок обработки элементов в очереди должен основываться на характеристиках этих элементов, а не только на порядке их создания или добавления в очередь. Например, задания на печать из финансового отдела могут иметь приоритет над списком заданий из отдела технической поддержки.
Класс модуля queue.PriorityQueue() использует порядок сортировки содержимого очереди, чтобы решить, какой элемент получить.
import functools
import queue
import threading


@functools.total_ordering
class Job:

    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        return

    def __eq__(self, other):
        try:
            return self.priority == other.priority
        except AttributeError:
            return NotImplemented

    def __lt__(self, other):
        try:
            return self.priority < other.priority
        except AttributeError:
            return NotImplemented

def process_job(q):
    while True:
        next_job = q.get()
        print('Processing job:', next_job.description)
        q.task_done()

q = queue.PriorityQueue()
q.put(Job(3, 'Mid-level'))
q.put(Job(10, 'Low-level'))
q.put(Job(1, 'Important'))

workers = [
    threading.Thread(target=process_job, args=(q,)),
    threading.Thread(target=process_job, args=(q,)),
]
for w in workers:
    w.setDaemon(True)
    w.start()

q.join()

                                                                date и time

%a	Сокращенное название дня недели	Sun, Mon, …, Sat (en_US) Пн, Вт, ..., Вс (ru_RU)
%A	Полное название дня недели	Sunday, Monday, …, Saturday (en_US) понедельник, ..., воскресенье (ru_RU)
%w	Номер дня недели [0, …, 6]	0, 1, …, 6 (0=воскресенье, 6=суббота)
%d	День месяца [01, …, 31]	01, 02, …, 31
%b	Сокращенное название месяца	Jan, Feb, …, Dec (en_US); янв, ..., дек (ru_RU)
%B	Полное название месяца	January, February, …, December (en_US); Январь, ..., Декабрь (ru_RU)
%m	Номер месяца [01, …,12]	01, 02, …, 12
%y	Год без века [00, …, 99]	00, 01, …, 99
%Y	Год с веком	0001, 0002, …, 2013, 2014, …, 9999 В Linux год выводится без ведущих нулей: 1, 2, …, 2013, 2014, …, 9999
%H	Час (24-часовой формат) [00, …, 23]	00, 01, …, 23
%I	Час (12-часовой формат) [01, …, 12]	01, 02, …, 12
%p	До полудня или после (при 12-часовом формате)	AM, PM (en_US)
%M	Число минут [00, …, 59]	00, 01, …, 59
%S	Число секунд [00, …, 59]	00, 01, …, 59
%f	Число микросекунд	000000, 000001, …, 999999
%z	Разница с UTC в формате ±HHMM[SS[.ffffff]]	+0000, -0400, +1030, +063415, ...
%Z	Временная зона	UTC, EST, CST
%j	День года [001,366]	001, 002, …, 366
%U	Номер недели в году      (нулевая неделя начинается с воскр.) [00, …, 53]   00, 01, …, 53
%W	 Номер недели в году      (нулевая неделя начинается с пон.) [00, …, 53]    00, 01, …, 53
%c	Дата и время	Tue Aug 16 21:30:00 1988 (en_US);             03.01.2019 23:18:32 (ru_RU)
%x	Дата	08/16/88 (None); 08/16/1988 (en_US);                03.01.2019 (ru_RU)
%X	Время	21:30:00

пример:
from datetime import date, time
my_date = date(2021, 8, 10)
my_time = time(7, 18, 34)
print(my_date.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))
print(my_time.strftime('%a %A %w %d %b %B %m %y %Y %H %I %p %M %S %f %z %Z %j %U %W %c %x %X'))
выводит:
Tue Tuesday 2 10 Aug August 08 21 2021 00 12 AM 00 00 000000   222 32 32 Tue Aug 10 00:00:00 2021 08/10/21 00:00:00
Mon Monday 1 01 Jan January 01 00 1900 07 07 AM 18 34 000000   001 00 01 Mon Jan  1 07:18:34 1900 01/01/00 07:18:34

                                                              Использование локализации
Для того чтобы использовать конкретную локализацию (перевод на язык), нужно использовать модуль locale.
Приведенный ниже код устанавливает русскую локализацию:
from datetime import date
import locale

locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
my_date = date(2021, 8, 10)
print(my_date.strftime("%A %d, %B %Y"))    # форматированный вывод даты в русской локализации

и выводит:
вторник 10, Август 2021


Для установки английской локализации используется код:

import locale

locale.setlocale(locale.LC_ALL, 'en_EN.UTF-8')
                                                                    
                                         isoformat() (Для того, чтобы получить строковое представление объектов типаdate и time в ISO формате)

from datetime import date, time

my_date = date(2021, 12, 31)
my_time = time(21, 15, 17)

print('Дата: ' + my_date.isoformat())
print('Время: ' + my_time.isoformat())

выводит:
Дата: 2021-12-31
Время: 21:15:17
                                                                          Тип данных datetime
ри создании новой даты-времени (тип datetime) нужно указать год, месяц, день, часы, минуты, секунды и микросекунды. При этом год, месяц и день являются обязательными, а часы, минуты, секунды и микросекунды необязательными.
доступ:
year — год
month — месяц
day — день
hour — час
minute — минуты
second — секунды
microsecond — микросекунды
                                       Методы combine(), date(), time()
Сформировать новый объект типа datetime можно с помощью двух разных объектов, представляющих дату и время (date и time). Для этого используется метод combine().

from datetime import date, time, datetime
my_date = date(1992, 10, 6)
my_time = time(10, 45, 17)
my_datetime = datetime.combine(my_date, my_time)

print(my_datetime)
выводит:
1992-10-06 10:45:17

Если, наоборот, нужно получить из даты-времени (тип datetime) по отдельности дату (тип date) и время (тип time), то используются методы date() и time() соответственно.
Приведенный ниже код:

from datetime import date, time, datetime
my_datetime = datetime(2022, 10, 7, 14, 15, 45)
my_date = my_datetime.date()                     # получаем только дату (тип date)
my_time = my_datetime.time()                     # получаем только время (тип time)

print(my_datetime, type(my_datetime))
print(my_date, type(my_date))
print(my_time, type(my_time))
выводит:

2022-10-07 14:15:45 <class 'datetime.datetime'>
2022-10-07 <class 'datetime.date'>
14:15:45 <class 'datetime.time'>

                                                      Методы now(), utcnow(), today()
Для того, что получить текущее время на момент исполнения программы, используются методы now() и utcnow() для локального и 
UTC(Всемирное координированное время (Coordinated Universal Time, UTC) — стандарт, по которому общество регулирует часы и время. Московское время соответствует UTC+3) времени соответственно.

Приведенный ниже код:

from datetime import datetime

datetime_now = datetime.now()
datetime_utcnow = datetime.utcnow()

print(datetime_now)           # текущее локальное время (московское) на момент запуска программы
print(datetime_utcnow)        # текущее UTC время на момент запуска программы
выводит:

2021-08-13 08:03:43.224568
2021-08-13 05:03:43.224568

Метод today() аналогичен методу now(). Для получения локальной даты-времени рекомендуется использовать именно метод now().

                                     Метод timestamp(),Метод fromtimestamp()
Метод timestamp() позволяет преобразовать объект типа datetime в количество секунд, прошедших с момента начала эпохи.
Данный метод возвращает значение типа float.(Начало эпохи — это полночь 1 января 1970 года (00:00:00 UTC))

from datetime import datetime
my_datetime = datetime(2021, 10, 13, 8, 10, 23)
print(my_datetime.timestamp())

выводит:
1634101823.0

Метод fromtimestamp() позволяет преобразовать количество секунд, прошедших с момента начала эпохи, в объект типа datetime.
Данный метод является обратным по отношению к методу timestamp().

from datetime import datetime
my_datetime = datetime.fromtimestamp(1634101823.0)
print(my_datetime)
выводит:

2021-10-13 08:10:23
                                                    Форматирование даты-времени
                                                    
Чтобы преобразовать дату-время в строку нужного формата, следует воспользоваться методом strftime(), указав ему в качестве аргумента параметры форматирования.

from datetime import datetime

my_datetime = datetime(2021, 8, 10, 18, 20, 34)

print(my_datetime)                                            # вывод в ISO формате
print(my_datetime.strftime('%d.%m.%y --- %H::%M::%S'))
print(my_datetime.strftime('%d/%m/%y'))
print(my_datetime.strftime('%A %d, %B %Y'))
print(my_datetime.strftime('%H:%M:%S'))
выводит

2021-08-10 18:20:34
10.08.21 --- 18::20::34
10/08/21
Tuesday 10, August 2021
18:20:34
                                                 strptime() 
strptime(), который преобразует строку (первый аргумент) в объект datetime согласно переданному формату (второй аргумент)
Приведенный ниже код:

from datetime import datetime

datetime0 = datetime.strptime('10.08.2034 13:55:59', '%d.%m.%Y %H:%M:%S')
datetime1 = datetime.strptime('10/08/21', '%d/%m/%y')
datetime2 = datetime.strptime('Tuesday 10, August 2021', '%A %d, %B %Y')
datetime3 = datetime.strptime('18.20.34', '%H.%M.%S')
datetime4 = datetime.strptime('2021/08/10', '%Y/%m/%d')
datetime5 = datetime.strptime('10.08.2021 (Tuesday, August)', '%d.%m.%Y (%A, %B)')
datetime6 = datetime.strptime('Year: 2021, Month: 08, Day: 10, Hour: 18.', 'Year: %Y, Month: %m, Day: %d, Hour: %H.')

print(datetime0, datetime1, datetime2, datetime3, datetime4, datetime5, datetime6, sep='\n')
выводит:

2034-08-10 13:55:59
2021-08-10 00:00:00
2021-08-10 00:00:00
1900-01-01 18:20:34
2021-08-10 00:00:00
2021-08-10 00:00:00
2021-08-10 18:00:00
                                                                  Тип данных timedelta
 Тип данных timedelta представляет из себя временной интервал (разница между двумя объектами datetime или date) и используется для удобного выполнения различных манипуляций над типами datetime или date.

При создании объекта timedelta можно указать следующие аргументы:

недели (weeks)
дни (days)
часы (hours)
минуты (minutes)
секунды (seconds)
микросекунды (microseconds)
миллисекунды (milliseconds)

Мы можем выбрать любые их сочетания для задания временного интервала, при этом все аргументы являются необязательными и по умолчанию равны 0.

Аргументы могут быть целыми числами или числами с плавающей запятой, а также могут быть как положительными, так и отрицательными. Используйте именованные аргументы, вместо позиционных, чтобы избежать ошибок.

Тип timedelta внутренне хранит только сочетание days, seconds, microseconds, а остальные переданные в конструктор аргументы конвертируются в эти единицы:

millisecond преобразуется в 1000 microseconds
minutes преобразуется в 60 seconds
hours преобразуется в3600 seconds
weeks преобразуется в 7 days

В следующем примере показано, как любые аргументы, кроме days, seconds, microseconds, объединяются и нормализуются в три результирующих сочетания.

Приведенный ниже код:

from datetime import timedelta

delta1 = timedelta(days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2)  ==>64 days, 8:05:56.000010
delta2 = timedelta(weeks=1, hours=23, minutes=61)                                                          ==>8 days, 0:01:00
delta3 = timedelta(hours=25)                                                                               ==>1 day, 1:00:00
delta4 = timedelta(minutes=300)                                                                            ==>5:00:00

 у типа timedelta нет атрибутов hours и minutes, позволяющих получить количество часов и минут соответственно.
 Достать часы и минуты можно так:
 def hours_minutes(td):
    return td.seconds // 3600, (td.seconds // 60) % 60
Приведенный ниже код:

from datetime import timedelta

def hours_minutes(td):
    return td.seconds // 3600, (td.seconds // 60) % 60

delta = timedelta(days=7, seconds=125, minutes=10, hours=8, weeks=2)

hours, minutes = hours_minutes(delta)

print(delta)
print(hours)
print(minutes)
выводит:

21 days, 8:12:05
8
12
                   Сравнение временных интервалов
Временные интервалы (тип timedelta) можно сравнивать (==, !=, <, >, <=, >=), как и любые другие типы данных.
from datetime import timedelta

delta1 = timedelta(weeks=1)
delta2 = timedelta(hours=24*7)
delta3 = timedelta(minutes=24*7*59)

print(delta1 == delta2)         #True
print(delta1 != delta3)        #True
print(delta1 < delta3)         #False

               Сумма и разность временных интервалов
from datetime import timedelta

delta1 = timedelta(days=5) + timedelta(seconds=3600)  # 5 дней + 1 час
delta2 = timedelta(days=5) - timedelta(seconds=3600)  # 5 дней - 1 час

print(delta1)                      5 days, 1:00:00
print(delta2)                      4 days, 23:00:00

            Умножение временного интервала на число
 from datetime import timedelta

delta1 = 48 * timedelta(hours=1)
delta2 = timedelta(weeks=1) * (3/7)

print(delta1)                 2 days, 0:00:00
print(delta2)                 3 days, 0:00:00

            Деление временных интервалов на число
from datetime import timedelta

delta = timedelta(hours=1, minutes=6)
delta1 = delta / 2
delta2 = delta // 5

print(delta1)             0:33:00
print(delta2)             0:13:12

          Деление временного интервала на временной интервал
 помощью операторов / и // мы также можем делить один временной интервал (тип timedelta) на другой. По сути происходит деление общей длительности одного интервала на общую длительность другого интервала.

Приведенный ниже код:

from datetime import timedelta

delta1 = timedelta(weeks=1) / timedelta(hours=5)       # обычное деление, результат float
delta2 = timedelta(weeks=1) // timedelta(hours=5)      # целочисленное деление, результат int

print(delta1)                     33.6
print(delta2)                     33

Мы также можем использовать оператор нахождения остатка от деления %, при этом остаток вычисляется как объект timedelta.
from datetime import timedelta

delta1 = timedelta(weeks=1) % timedelta(hours=5)         # 3 часа
delta2 = timedelta(hours=1) % timedelta(minutes=7)       # 4 минуты

print(delta1)                       3:00:00
print(delta2)                       0:04:00

Рассмотрим следующую задачу: рабочая смена длится 7 часов 30 минут, сколько полных смен в 3-х сутках?
from datetime import timedelta

all_time = timedelta(days=3)
smena = timedelta(hours=7, minutes=30)

print(all_time // smena)           #9
print(all_time % smena)           #4:30:00

                                                                   Модуль time
Для того чтобы получить количество секунд, прошедших с момента начала эпохи, необходимо использовать одноименную функцию time() из модуля time.

import time
seconds = time.time()    # получаем количество прошедших секунд в виде float числа
print('Количество секунд с начала эпохи =', seconds)

                Функция ctime()
Функция ctime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает строку, представляющую собой местное (локальное) время.
import time

seconds = 1630387918.354396
local_time = time.ctime(seconds)
print('Местное время:', local_time)          #Tue Aug 31 08:31:58 2021

Таким образом, функция ctime() возвращает строковое представление о местном (локальном) времени, которое включает в себя:
день недели: Tue (Tuesday)
название месяца: Aug (August)
число месяца: 31
часы, минуты, секунды: 08:31:58
                Функция sleep()
Функция sleep() используется для добавления задержки в выполнении программы.
Эта функция принимает в качестве аргумента количество секунд (secs) и добавляет задержку в выполнении программы на указанное количество секунд.
Аргумент secs может быть числом с плавающей точкой (float), для указания более точного времени приостановки.
Например,мы можем сделать задержку на 700 миллисекунд, что составляет 0.7 секунды, как показано ниже:

import time 

print('Before the sleep statement')
time.sleep(0.7)
print('After the sleep statement')
год: 2021
                  Функция monotonic()       monotonic_ns()
Используемый таймер в функции monotonic() никогда не вернет при повторном вызове значение, которое будет меньше значения, полученного при предыдущем вызове. 
Это позволяет избежать многих ошибок, а также неожиданного поведения.
import time

start_time = time.monotonic()
for i in range(5): 
    print(i)
    time.sleep(0.5)
end_time = time.monotonic()
elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')

выводит (время работы программы может незначительно отличаться):
0
1
2
3
4
Время работы программы = 2.547000000020489

                                Функция perf_counter()
 ля самого точного измерения времени выполнения программы следует использовать функцию perf_counter().
 Данная функция использует таймер с наибольшим доступным разрешением, 
 что делает эту функцию отличным инструментом для измерения времени выполнения кода на коротких интервалах.
 
 import time
start_time = time.perf_counter()
for i in range(5): 
    print(i)
    time.sleep(1)
end_time = time.perf_counter()
elapsed_time = end_time - start_time
print(f'Время работы программы = {elapsed_time}')

выводит (время работы программы может незначительно отличаться):
0
1
2
3
4
Время работы программы = 5.042140900040977
                                                                    Тип данных struct_time
Данный тип является именованным кортежем, представляющий информацию о времени. Структура представления времени struct_time чем-то похожа на тип datetime.
Именованный кортеж struct_time состоит из следующих атрибутов:

Номер индекса  	Атрибут	       Значение
0	              tm_year	       диапазон от 0000 до 9999
1	              tm_mon	       диапазон от 1 до 12
2	              tm_mday	       диапазон от 1 до 31
3	              tm_hour	       диапазон от 0 до 23
4	              tm_min 	       диапазон от 0 до 59
5	              tm_sec	       диапазон от 0 до 61
6	              tm_wday	       диапазон от 0 до 6, понедельник = 0
7	              tm_yday	       диапазон от 1 до 366
8	              tm_isdst	     значения -1, 0, 1
N/A	            tm_zone	       сокращение названия часового пояса
N/A	            tm_gmtoff	     смещение к востоку от UTC в секундах

Создавать объекты типа struct_time можно на основе кортежа:

import time
time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0)
time_obj = time.struct_time(time_tuple)

На практике редко приходится собственноручно создавать объекты типа struct_time. Обычно используют функции модуля time, которые сами создают и оперируют ими.
Такие функции как localtime(), gmtime(), asctime() и другие, принимают объект time.struct_time в качестве аргумента или возвращают его.

                               Функция localtime()
Функция localtime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает кортеж struct_time в локальном времени.
Если функции localtime() передан аргумент None, то вернется значение time().
Приведенный ниже код:

import time
result = time.localtime(1630387918)
print('Результат:', result)           #time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=8, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0)
print('Год:', result.tm_year)         #Год: 2021
print('Месяц:', result.tm_mon)        #Месяц: 8
print('День:', result.tm_mday)        #День: 31
print('Час:', result.tm_hour)         #Час: 8

мы можем обращаться к данным именованного кортежа struct_time и по индексам.
import time

result = time.localtime(1630387918)
print('Результат:', result)
print('Год:', result[0])
print('Месяц:', result[1])
print('День:', result[2])
print('Час:', result[3])
                    Функция gmtime()
Функция gmtime() принимает в качестве аргумента количество секунд, прошедших с начала эпохи, и возвращает кортеж struct_time в UTC.
Если функции gmtime() передан аргумент None, то вернется значение time().
import time

result = time.gmtime(1630387918)
print('Результат:', result)      #Результат: time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=5, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0)
print('Год:', result.tm_year)    #Год: 2021
print('Месяц:', result.tm_mon)   #Месяц: 8
print('День:', result.tm_mday)   #День: 31
print('Час:', result.tm_hour)    #Час: 5

                           Функция mktime()
Функция mktime() принимает struct_time (или кортеж, содержащий 99 значений, относящихся к struct_time)
в качестве аргумента и возвращает количество секунд, прошедших с начала эпохи, в местном времени.

import time
time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0)
time_obj = time.mktime(time_tuple)
print('Локальное время в секундах:', time_obj)      #Локальное время в секундах: 1630377118.0

Функция mktime() является обратной к функции localtime(). Следующий пример показывает их связь:

import time
seconds = 1630377118
time_obj = time.localtime(seconds)            # возвращает struct_time
print(time_obj)                        #time.struct_time(tm_year=2021, tm_mon=8, tm_mday=31, tm_hour=5, tm_min=31, tm_sec=58, tm_wday=1, tm_yday=243, tm_isdst=0)
time_seconds = time.mktime(time_obj)          # возвращает секунды из struct_time
print(time_seconds)                    #1630377118.0

Когда кортеж с неправильной длиной передается функции, ожидающей struct_time или имеющей элементы неправильного типа, возникает ошибка TypeError.

                      Функция asctime()
Функция asctime() принимает struct_time (или кортеж, содержащий 99 значений, относящихся к struct_time) в качестве аргумента и возвращает строку,
представляющую собой дату и время.

import time

time_tuple = (2021, 8, 31, 5, 31, 58, 1, 243, 0)

result = time.asctime(time_tuple)
print('Результат:', result)          #Результат: Tue Aug 31 05:31:58 2021

                                                       ----модуль calendar---------------
Атрибуты модуля calendar
В отличие от функций, которые выполняют определенную работу, в модуле calendar есть полезные атрибуты,
которые возвращают константные (общепринятые) значения, полезные при решении практических задач.

           Атрибут day_name
Атрибут calendar.day_name возвращает итерируемый объект, содержащий названия дней недели на английском языке.

import calendar
for name in calendar.day_name:
    print(name)
выводит:
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday

Для локализации на русский язык мы используем код:

import calendar, locale
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
for name in calendar.day_name:
    print(name)
который выводит:
понедельник
вторник
среда
четверг
пятница
суббота
воскресенье

              Атрибут day_abbr
Атрибут calendar.day_abbr возвращает итерируемый объект, содержащий сокращенные названия дней недели.
import calendar, locale

for name in calendar.day_abbr:
    print(name)

locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')

for name in calendar.day_abbr:
    print(name)
выводит:
Mon
Tue
Wed
Thu
Fri
Sat
Sun
Пн
Вт
Ср
Чт
Пт
Сб
Вс

Атрибут month_name
Атрибут calendar.month_name возвращает итерируемый объект, содержащий названия месяцев года.

import calendar, locale

english_names = list(calendar.month_name)
print(english_names)
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
russian_names = list(calendar.month_name)
print(russian_names)
выводит:

['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
['', 'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь']

           Атрибут month_abbr
Атрибут calendar.month_abbr возвращает итерируемый объект, содержащий сокращенные названия месяцев года.
import calendar, locale
english_names = list(calendar.month_abbr)
print(english_names)
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
russian_names = list(calendar.month_abbr)
print(russian_names)
выводит:

['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
['', 'янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек']

Атрибуты номеров дней недели
Для получения номеров дней недели можно использовать атрибуты: MONDAY, TUESDAY, ..., SUNDAY.

Приведенный ниже код:

import calendar

print(calendar.MONDAY)           #0
print(calendar.TUESDAY)          #1
print(calendar.WEDNESDAY)        #2
print(calendar.THURSDAY)         #3
print(calendar.FRIDAY)           #4
print(calendar.SATURDAY)         #5
print(calendar.SUNDAY)           #6

                                                          -------Функции модуля calendar-------------------
Функция setfirstweekday()
По умолчанию в модуле calendar понедельник является первым днем недели (имеет номер 00), а воскресенье – последним днем недели (имеет номер 66).
Функция setfirstweekday() позволяет изменить поведение по умолчанию и устанавливает заданный день недели в качестве начала недели.
Например, чтобы установить первый будний день воскресенье, мы используем код:

import calendar
calendar.setfirstweekday(calendar.SUNDAY)     # эквивалентно calendar.setfirstweekday(6)

               Функция firstweekday()
Функция firstweekday() возвращает целое число, означающее день недели, установленное в качестве начала недели.
import calendar
print(calendar.firstweekday())               #0
calendar.setfirstweekday(calendar.SUNDAY)
print(calendar.firstweekday())              #6

Функция isleap()
Напомним, что год является високосным, если его номер кратен 4, но не кратен 100100, или если он кратен 400. 
Модуль calendar содержит функцию isleap(), которая осуществляет нужную проверку.

import calendar
print(calendar.isleap(2020))        #True
print(calendar.isleap(2021))       #False

                  Функция leapdays()
Функция leapdays(y1, y2) возвращает количество високосных лет в диапазоне от y1 до y2 (исключая), где y1 и y2 – годы.

import calendar
print(calendar.leapdays(2020, 2025))          #2

так как в нужном диапазоне [2020;2025) находятся два високосных года: 2020 и 2024.

                 Функция weekday()
Функция weekday(year, month, day) возвращает день недели в виде целого числа (где 00 – понедельник, 66 – воскресенье) для заданной даты. Аргументы функции year – год начиная с 19701970, month – месяц в диапазоне 1 - 121−12, day – число в диапазоне 1 - 311−31.


import calendar
print(calendar.weekday(2021, 9, 1))     # среда
print(calendar.weekday(2021, 9, 2))     # четверг
выводит:
2
3

                   Функция monthrange()
Функция monthrange(year, month) возвращает день недели первого дня месяца и количество дней в месяце в виде кортежа для указанного года year и месяца month.

import calendar
print(calendar.monthrange(2022, 1))     # январь 2022 года
print(calendar.monthrange(2021, 9))     # сентябрь 2021 года
выводит:
(5, 31)
(2, 30)

               Функция monthcalendar()
Функция monthcalendar(year, month) возвращает матрицу, представляющую календарь на месяц. Каждая строка матрицы представляет неделю.

import calendar
print(*calendar.monthcalendar(2021, 9), sep='\n')
выводит:
[0, 0, 1, 2, 3, 4, 5]
[6, 7, 8, 9, 10, 11, 12]
[13, 14, 15, 16, 17, 18, 19]
[20, 21, 22, 23, 24, 25, 26]
[27, 28, 29, 30, 0, 0, 0]
Обратите внимание на то, что дни, которые не входят в указанный месяц, представлены нулями. При этом каждая неделя начинается с понедельника, если не установлено другое функцией  setfirstweekday().

                 Функция month()
Функция month(year, month, w=0, l=0) возвращает календарь на месяц в многострочной строке.
Аргументами функции являются: year (год), month (месяц), w (ширина столбца даты) и l (количество строк, отводимые на неделю).
Аргументы w и l имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции.

import calendar
print(calendar.month(2021, 9))
print(calendar.month(2021, 10))
print(calendar.month(2021, 9, w=3))
print(calendar.month(2021, 9, l=2))
print(calendar.month(2021, 9, w=5, l=2))
выводит:

   September 2021
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30

    October 2021
Mo Tu We Th Fr Sa Su
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31

       September 2021
Mon Tue Wed Thu Fri Sat Sun
          1   2   3   4   5
  6   7   8   9  10  11  12
 13  14  15  16  17  18  19
 20  21  22  23  24  25  26
 27  28  29  30

   September 2021

Mo Tu We Th Fr Sa Su

       1  2  3  4  5

 6  7  8  9 10 11 12

13 14 15 16 17 18 19

20 21 22 23 24 25 26

27 28 29 30


              September 2021

 Mon   Tue   Wed   Thu   Fri   Sat   Sun

               1     2     3     4     5

   6     7     8     9    10    11    12

  13    14    15    16    17    18    19

  20    21    22    23    24    25    26

  27    28    29    30
  
                   функция calendar()
Функция calendar(year, w=2, l=1, c=6, m=3) возвращает календарь на весь год в виде многострочной строки.
Аргументами функции являются: year (год),  w (ширина столбца даты) и l (количество строк, отводимые на неделю),
c (количество пробелов между столбцом месяца),  m (количество столбцов).
Аргументы w, l, c, m имеют значения по умолчанию, поэтому их можно не передавать явно при вызове функции.

import calendar
print(calendar.calendar(2021))
выводит:

                                  2021

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14
11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21
18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28
25 26 27 28 29 30 31                                29 30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                      1  2          1  2  3  4  5  6
 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13
12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20
19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27
26 27 28 29 30            24 25 26 27 28 29 30      28 29 30
                          31

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                         1             1  2  3  4  5
 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12
12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19
19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26
26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30
                          30 31

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12
11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19
18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26
25 26 27 28 29 30 31      29 30                     27 28 29 30 31

import calendar, locale
locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8')
print(calendar.calendar(2022, m=4))
выводит:

                                               2022

       Январь                   Февраль                     Март                     Апрель
Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс
                1  2          1  2  3  4  5  6          1  2  3  4  5  6                   1  2  3
 3  4  5  6  7  8  9       7  8  9 10 11 12 13       7  8  9 10 11 12 13       4  5  6  7  8  9 10
10 11 12 13 14 15 16      14 15 16 17 18 19 20      14 15 16 17 18 19 20      11 12 13 14 15 16 17
17 18 19 20 21 22 23      21 22 23 24 25 26 27      21 22 23 24 25 26 27      18 19 20 21 22 23 24
24 25 26 27 28 29 30      28                        28 29 30 31               25 26 27 28 29 30
31

        Май                       Июнь                      Июль                     Август
Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс
                   1             1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7
 2  3  4  5  6  7  8       6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 14
 9 10 11 12 13 14 15      13 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 21
16 17 18 19 20 21 22      20 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 28
23 24 25 26 27 28 29      27 28 29 30               25 26 27 28 29 30 31      29 30 31
30 31

      Сентябрь                  Октябрь                    Ноябрь                   Декабрь
Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс      Пн Вт Ср Чт Пт Сб Вс
          1  2  3  4                      1  2          1  2  3  4  5  6                1  2  3  4
 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13       5  6  7  8  9 10 11
12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20      12 13 14 15 16 17 18
19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27      19 20 21 22 23 24 25
26 27 28 29 30            24 25 26 27 28 29 30      28 29 30                  26 27 28 29 30 31
                          31

                        Функции prmonth(), prcal()
Функция prmonth(theyear, themonth, w=0, l=0) печатает календарь на месяц, возвращенный функцией month(theyear, themonth, w=0, l=0).
Функция prcal(year, w=0, l=0, c=6, m=3) печатает календарь на весь год, возвращенный функцией calendar(year, w=0, l=0, c=6, m=3).

import calendar
calendar.prmonth(2021, 9)
calendar.prcal(2021)

эквивалентен коду:
import calendar
print(calendar.month(2021, 9))
print(calendar.calendar(2021))
и выводит:

   September 2021
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30
                                  2021

      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14
11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21
18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28
25 26 27 28 29 30 31                                29 30 31

       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                      1  2          1  2  3  4  5  6
 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13
12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20
19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27
26 27 28 29 30            24 25 26 27 28 29 30      28 29 30
                          31

        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
          1  2  3  4                         1             1  2  3  4  5
 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12
12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19
19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26
26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30
                          30 31

      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5
 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12
11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19
18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26
25 26 27 28 29 30 31      29 30                     27 28 29 30 31

Полезные ссылки по работе со временем:
1)https://www.timeanddate.com/
2)https://docs-python.ru/standart-library/modul-datetime-python/     #документация по модулю datetime
3)https://docs-python.ru/standart-library/modul-zoneinfo-python/     #модуль zoneinfo в Python, база часовых поясов
4)https://docs-python.ru/standart-library/modul-zoneinfo-python/     #Python pytz  Этот модуль обслуживает функции преобразования даты и времени и помогает         пользователям обслуживать международную клиентскую базу.
5)https://pythonru.com/biblioteki/modul-dateutil                    #модуль dateutil Он помогает планировать, получать данные в определенное время или устанавливать временные метки.
6)https://pythonim.ru/moduli/arrow-python                            #Модуль Arrow в Python – это библиотека, заменяющая datetime. Это позволяет легко создавать экземпляры даты и времени с учетом часового пояса.

                          --------------------------------------Потоковый ввод(sys.stdin)-------------------
Поток ввода (sys.stdin) — является итератором, который невозможно перезапустить. Как и любой итератор, он может двигаться только вперёд.
Как только данные прочитаны, они удаляются из потока ввода безвозвратно.

Пока есть данные в потоке ввода sys.stdin (то есть пока пользователь их вводит) программа будет записывать вводимые строки в переменную line, убирать символы перевода строки и выводить их на печать.

Если запустить такую программу, то она будет работать вечно. Чтобы показать, что ввод закончен, недостаточно нажать Enter — компьютер не знает, завершил ли пользователь работу или будет ещё что-то вводить (при этом Enter превратится в пустую строку).
Для завершения ввода необходимо ввести Ctrl + D (если работаете в консоли Linux или IDE PyCharm), либо Ctrl + Z, затем Enter (если работаете в консоли Windows).

                  Читаем входные данные в одну строку
С помощью потока ввода (sys.stdin) можно в одну строчку кода прочитать весь пользовательский ввод в список.

Реализуется это с помощью списочного выражения:
import sys
data = [line.strip() for line in sys.stdin]

или с помощью функции высшего порядка map():
import sys
data = list(map(str.strip, sys.stdin))

                      Методы read() и readlines()
Как уже было сказано выше, мы можем обойти циклом for итератор sys.stdin. Кроме того, можно считать все строки из итератора (с сохранением символов перевода строки) в список с помощью метода readlines():

import sys
data = sys.stdin.readlines()
Обратите внимание на то, что символ перехода на новую строку (\n) сохраняется в считанных строках.
Если разделять на строки нет необходимости, то считать многострочный текст из стандартного потока ввода в текстовую переменную можно с помощью метода read():

import sys
data = sys.stdin.read()

                              Потоковый вывод
Аналогичным образом можно работать с потоковым выводом (sys.stdout). По умолчанию функция print() перенаправляет вывод данных именно в sys.stdout, хотя нам ничего не мешает самостоятельно писать в него.

Приведенный ниже код:

import sys
print('Hello')
sys.stdout.write('world!')
print('from')
sys.stdout.write('python\n')
print('Bye-bye')

выведет:
Hello
world!from
python
Bye-bye

Обратите внимание на то, что функция print() добавляет перевод на новую строку, а явная запись данных в sys.stdout с помощью метода write() нет. Чтобы добавить перевод на новую строку, мы используем стандартный символ \n.
Также нужно иметь в виду, что при использовании потока вывода sys.stdout нам нужно самостоятельно преобразовывать данные к строковому типу данных (функция print() это делает автоматически).

                     --------------------------------------работа с csv файлами-------------------------------------------
                                                          Модуль csv
              Чтение данных с помощью reader
 import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.reader(file)                               # создаем reader объект
    for row in rows:
        print(row)

Объект reader дает доступ к построчному итератору, полностью аналогичному работе с файлом или списком.

После выполнения этой строки в переменную rows будет записан итератор, с помощью которого можно «пробежаться» циклом по файлу. В каждой итерации цикла при этом будет доступна соответствующая строка файла, уже разбитая по запятым и представляющая собой список. При этом автоматически будут учтены все нюансы с запятыми внутри кавычек и самими кавычками.

Так как каждая строка файла, полученная из итератора, является списком, к ней можно применять все способы работы со списками.

Пусть содержимое файла products.csv имеет вид (в качестве разделителя выбран символ ';'):
keywords;price;product_name
"Садовый стул, стул для дачи";1699;ВЭДДО
Садовый стул;2999;ЭПЛАРО
Садовый табурет;1699;ЭПЛАРО
Садовый стол;1999;ТЭРНО
"Складной стол, обеденный стол";7499;ЭПЛАРО
Настил;1299;РУННЕН
Стеллаж;1299;ХИЛЛИС
"Кружка, сосуд, стакан с ручкой";39;СТЕЛЬНА
Молочник;299;ВАРДАГЕН
Термос для еды;699;ЭФТЕРФРОГАД
Ситечко;59;ИДЕАЛИСК
Чайник заварочный;499;РИКЛИГ
Кофе-пресс;699;УПХЕТТА
Чашка с блюдцем;249;ИКЕА
"Кружка, стакан с ручкой";249;ЭМНТ
Ситечко;199;САККУННИГ
Кружка;199;ФИНСТИЛТ
"Тарелка, блюдце";269;ЭВЕРЕНС
Приведенный ниже код:

import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.reader(file, delimiter=';', quotechar='"')
    for index, row in enumerate(rows):
        if index > 5:
            break
        print(row)
выводит первые 66 строк файла, включая заголовок с названиями столбцов:

['keywords', 'price', 'product_name']
['Садовый стул, стул для дачи', '1699', 'ВЭДДО']
['Садовый стул', '2999', 'ЭПЛАРО']
['Садовый табурет', '1699', 'ЭПЛАРО']
['Садовый стол', '1999', 'ТЭРНО']
['Складной стол, обеденный стол', '7499', 'ЭПЛАРО']
При создании reader объекта мы указываем, что символ-разделитель записей delimiter в нашем файле — точка с запятой, а символ кавычек quotechar — двойные кавычки. Кроме того, мы используем встроенную функцию enumerate() для нумерации строк.

                      Чтение данных с помощью DictReader
Иcпользовать reader объект не всегда удобно, так как он возвращает сырые списки из строк файла, к тому же первой строкой является строка с названиями столбцов, которая практически всегда удаляется, так как мешает правильной обработке данных.

В модуле csv есть специальный объект DictReader, который поддерживает создание объекта-словаря на основе названий столбцов. С помощью DictReader объекта мы можем обращаться к полям не по индексу, а по названию, что делает код более понятным.

Пусть содержимое файла products.csv имеет вид (в качестве разделителя выбран символ ';'):

keywords;price;product_name
"Садовый стул, стул для дачи";1699;ВЭДДО
Садовый стул;2999;ЭПЛАРО
Садовый табурет;1699;ЭПЛАРО
Садовый стол;1999;ТЭРНО
"Складной стол, обеденный стол";7499;ЭПЛАРО
Настил;1299;РУННЕН
Стеллаж;1299;ХИЛЛИС
"Кружка, сосуд, стакан с ручкой";39;СТЕЛЬНА
Молочник;299;ВАРДАГЕН
Термос для еды;699;ЭФТЕРФРОГАД
Ситечко;59;ИДЕАЛИСК
Чайник заварочный;499;РИКЛИГ
Кофе-пресс;699;УПХЕТТА
Чашка с блюдцем;249;ИКЕА
"Кружка, стакан с ручкой";249;ЭМНТ
Ситечко;199;САККУННИГ
Кружка;199;ФИНСТИЛТ
"Тарелка, блюдце";269;ЭВЕРЕНС
Приведенный ниже код:

import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';', quotechar='"')
    for row in rows:
        print(row)
выводит:

{'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'}
{'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'}
{'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Настил', 'price': '1299', 'product_name': 'РУННЕН'}
{'keywords': 'Стеллаж', 'price': '1299', 'product_name': 'ХИЛЛИС'}
{'keywords': 'Кружка, сосуд, стакан с ручкой', 'price': '39', 'product_name': 'СТЕЛЬНА'}
{'keywords': 'Молочник', 'price': '299', 'product_name': 'ВАРДАГЕН'}
{'keywords': 'Термос для еды', 'price': '699', 'product_name': 'ЭФТЕРФРОГАД'}
{'keywords': 'Ситечко', 'price': '59', 'product_name': 'ИДЕАЛИСК'}
{'keywords': 'Чайник заварочный', 'price': '499', 'product_name': 'РИКЛИГ'}
{'keywords': 'Кофе-пресс', 'price': '699', 'product_name': 'УПХЕТТА'}
{'keywords': 'Чашка с блюдцем', 'price': '249', 'product_name': 'ИКЕА'}
{'keywords': 'Кружка, стакан с ручкой', 'price': '249', 'product_name': 'ЭМНТ'}
{'keywords': 'Ситечко', 'price': '199', 'product_name': 'САККУННИГ'}
{'keywords': 'Кружка', 'price': '199', 'product_name': 'ФИНСТИЛТ'}
{'keywords': 'Тарелка, блюдце', 'price': '269', 'product_name': 'ЭВЕРЕНС'}

import csv

with open('products.csv', encoding='utf-8') as file:
    rows = csv.DictReader(file, delimiter=';', quotechar='"')
    expensive = sorted(rows, key=lambda item: int(item['price']), reverse=True)
    for record in expensive[:5]:
        print(record)
выводит 5 самых дорогих товаров:

{'keywords': 'Складной стол, обеденный стол', 'price': '7499', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый стул', 'price': '2999', 'product_name': 'ЭПЛАРО'}
{'keywords': 'Садовый стол', 'price': '1999', 'product_name': 'ТЭРНО'}
{'keywords': 'Садовый стул, стул для дачи', 'price': '1699', 'product_name': 'ВЭДДО'}
{'keywords': 'Садовый табурет', 'price': '1699', 'product_name': 'ЭПЛАРО'}
При создании DictReader объекта значениями по умолчанию для аргументов delimiter и quotechar являются ',' (символ запятой) и '"' (символ двойной кавычки) соответственно.

Обратите внимание на то, что при использовании DictReader мы не избавляемся от первой строки, содержащей названия столбцов. При этом к элементам строк мы обращаемся теперь не по индексам (int(item[1])), а по их названиям (int(item['price'])), что намного удобнее.

             Запись данных с помощью writer
Для записи данных в csv файл можно использовать специальный writer объект.

import csv

columns = ['first_name', 'second_name', 'class_number', 'class_letter']
data = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Артур', 'Харисов', 10, 'В']]
with open('students.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(columns)
    for row in data:
        writer.writerow(row)
создает файл students.csv с содержимым:

first_name,second_name,class_number,class_letter
Тимур,Гуев,11,А
Руслан,Чаниев,9,Б
Артур,Харисов,10,В

Обратите внимание на необязательный параметр newline функции open(), который имеет значение '' (пустой строки).
Он отвечает за переводы строк при чтении или записи в текстовый файл. По умолчанию имеет значение None, в этом случае все разделители строк преобразуются в '\n'.
Если в файле оказывается лишний перевод строки, то следует использовать этот параметр в режиме newline='', тогда '\n' будет преобразован в пустую строку.

При создании writer объекта мы так же можем его настраивать, задавая delimeter и многие другие параметры.

Помимо метода writerow() можно использовать и метод writerows(), чтобы записать сразу несколько строк. Единственным аргументом этого метода может быть коллекция коллекций. То есть, каждый элемент списка rows в нашем случае должен быть коллекцией. Если rows будет, например, списком чисел, программа завершится с ошибкой.

Приведенный ниже код:

import csv

columns = ['first_name', 'second_name', 'class_number', 'class_letter']
data = [['Тимур', 'Гуев', 11, 'А'], ['Руслан', 'Чаниев', 9, 'Б'], ['Роман', 'Белых', 10, 'В']]

with open('students.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.writer(file, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)
    writer.writerow(columns)
    writer.writerows(data)
создает файл students.csv с содержимым:

"first_name";"second_name";"class_number";"class_letter"
"Тимур";"Гуев";11;"А"
"Руслан";"Чаниев";9;"Б"
"Роман";"Белых";10;"В"

Запись данных с помощью DictWriter
Для записи данных в csv файл также можно использовать DictWriter объект, который позволяет записывать содержимое словаря в файл.

Приведенный ниже код:

import csv

data = [{'first_name': 'Тимур', 'second_name': 'Гуев', 'class_number': 11, 'class_letter': 'А'},
        {'first_name': 'Руслан', 'second_name': 'Чаниев', 'class_number': 9, 'class_letter': 'Б'},
        {'first_name': 'Роман', 'second_name': 'Белых', 'class_number': 10, 'class_letter': 'В'}]

columns = ['first_name', 'second_name', 'class_number', 'class_letter']

with open('students.csv', 'w', encoding='utf-8', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=columns, delimiter=';', quoting=csv.QUOTE_NONNUMERIC)
    writer.writeheader()
    for row in data:
        writer.writerow(row)
создает файл students.csv с содержимым:

"first_name";"second_name";"class_number";"class_letter"
"Тимур";"Гуев";11;"А"
"Руслан";"Чаниев";9;"Б"
"Роман";"Белых";10;"В"
Мы также можем использовать метод writerows() объекта DictWriter для записи сразу нескольких строк. Таким образом вместо строк кода:

for row in data:
    writer.writerow(row)
можно написать:

writer.writerows(data)
Обратите внимание на то, что ключи словарей, которые записываются в файл, должны совпадать с названиям полей, которые переданы в качестве аргумента fieldnames, иначе будет возникать ошибка ValueError.

                                        ------------------работа с json файлами-------------------------------
              модуль json
Преобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией».
В Python для сериализации и десериализации в формат json есть модуль, который так и называется — json.

          Функция dumps()
Для сериализации данных в json строку используется функция dumps() из модуля json. Для того, чтобы сериализовать данные с ее помощью, достаточно передать в нее аргументом любой сериализуемый Python объект. 

Так как json — текстовый формат, то сериализация в него — это по сути преобразование данных в строку.

import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}
json_data = json.dumps(data)            # сериализуем словарь data в json строку

print(type(json_data))          <class 'str'>
print(json_data)               {"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}

Обратите внимание на кавычки, независимо от того, что в Python-словаре мы использовали одинарные, в результирующую строку всегда попадают двойные.

            Функция dump()
В отличие от функции dumps(), которая преобразует (сериализует) Python объект в json строку, функция dump() записывает переданный Python объект в файл.


import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

with open('contries.json', 'w') as file:
    json.dump(data, file)
    
создает файл contries.json и сохраняет в него информацию из словаря data в json формате.
Если открыть файл contries.json, мы увидим, что json выведен в одну строку без форматирования:
{"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}

               Необязательные аргументы indent, sort_keys и separators
Функции записи dumps() и dump() имеют необязательные аргументы indent, sort_keys и separators, которые можно использовать для более удобного чтения человеком.

Аргумент indent задает отступ от левого края. По умолчанию имеет значение None для более компактного представления без отступов.


import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data1 = json.dumps(data, indent=2)
json_data2 = json.dumps(data, indent=10)

print(json_data1)
print(json_data2)
выводит:

{
  "name": "Russia",
  "phone_code": 7,
  "capital": "Moscow",
  "currency": "RUB"
}
{
          "name": "Russia",
          "phone_code": 7,
          "capital": "Moscow",
          "currency": "RUB"
}
Если значением indent является строка, то она используется в качестве отступа.

import json

data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data = json.dumps(data, indent='++++')

print(json_data)
выводит:

{
++++"name": "Russia",
++++"phone_code": 7,
++++"capital": "Moscow",
++++"currency": "RUB"
}
   Отступов также не будет, если значение аргумента indent равно 00, отрицательному числу или пустой строке.

Аргумент sort_keys задает сортировку ключей в результирующем json. По умолчанию имеет значение False для более быстрого создания json.
Если установить значение аргумента в True, то ключи будут отсортированы в алфавитном порядке, что особенно удобно, когда ключей много.

import json
data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data1 = json.dumps(data, indent=3)
json_data2 = json.dumps(data, indent=3, sort_keys=True)

print(json_data1)
print(json_data2)
выводит:

{
   "name": "Russia",
   "phone_code": 7,
   "capital": "Moscow",
   "currency": "RUB"
}
{
   "capital": "Moscow",
   "currency": "RUB",
   "name": "Russia",
   "phone_code": 7
}
Аргумент separators задает кортеж, состоящий из двух элементов (item_separator, key_separator), которые представляют разделители для элементов и ключей.
По умолчанию аргумент имеет значение (', ', ': ').

Приведенный ниже код:

import json

data = {'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}

json_data = json.dumps(data, indent=3, separators=(';', ' = '))

print(json_data)
выводит:

{
   "name" = "Russia";
   "phone_code" = 7;
   "capital" = "Moscow";
   "currency" = "RUB"
}

            Функция loads()
Для десериализации данных нужно использовать функцию loads(). Ее аргумент — это строка с данными в формате json.


import json
json_data = '{"name": "Russia", "phone_code": 7, "capital": "Moscow", "currency": "RUB"}'

data = json.loads(json_data)
print(type(data))
print(data)
выводит:

<class 'dict'>
{'name': 'Russia', 'phone_code': 7, 'capital': 'Moscow', 'currency': 'RUB'}
Как видно из примера, функция loads() десериализует json строку в словарь.
В случае если строка для десериализации содержит данные с ошибкой, то модуль json не сможет правильно прочитать такую строку, и программа завершится с ошибкой.

                    Функция load()
В отличие от функции loads(), которая в качестве аргумента принимает строку с данными в формате json, функция load() принимает файловый объект и возвращает его десериализованное содержимое.

Пусть файл data.json имеет следующее содержимое:

{
  "name": "Russia",
  "phone_code": 7,
  "capital": "Moscow",
  "cities": ["Abakan", "Almetyevsk", "Anadyr", "Anapa", "Arkhangelsk", "Astrakhan"],
  "currency": "RUB"
}
Приведенный ниже код:

import json

with open('data.json') as file:
    data = json.load(file)                # передаем файловый объект
    for key, value in data.items():
        if type(value) == list:
            print(f'{key}: {", ".join(value)}')
        else:
            print(f'{key}: {value}')
читает содержимое data.json файла в словарь data и выводит его содержимое:

name: Russia
phone_code: 7
capital: Moscow
cities: Abakan, Almetyevsk, Anadyr, Anapa, Arkhangelsk, Astrakhan
currency: RUB

             Изменение типа данных(json<==>python)
 Таблица конвертации типов данных Python в JSON:

Python	JSON
dict	object
list, tuple	array
str	string
int, float	number
True	true
False	false
None	null
Таблица конвертации JSON в типы данных Python:

JSON	         Python       
object	dict
array	list
string	str
number (int)	int
number (real)	float
true	True
false	False
null	None

                   Ограничение по типам данных(json)
 формат JSON нельзя записать словарь, у которого ключи – кортежи.

Приведенный ниже код:

import json

data = {
        'beegeek': 2018,
        ('Timur', 'Guev'): 29,
        ('Arthur', 'Kharisov'): 20,
        'stepik': 2013
       }

json_data = json.dumps(data)        # преобразуем dict в json

print(json_data)
генерирует ошибку:

TypeError: keys must be str, int, float, bool or None, not tuple
С помощью необязательного аргумента skipkeys можно игнорировать подобные ключи.

Приведенный ниже код:

import json

data = {
        'beegeek': 2018,
        ('Timur', 'Guev'): 29,
        ('Arthur', 'Kharisov'): 20,
        'stepik': 2013
       }

json_data = json.dumps(data, skipkeys=True)        # преобразуем dict в json

print(json_data)
выводит:

{"beegeek": 2018, "stepik": 2013}
Кроме того, в JSON ключами словаря могут быть только строки. Но, если в словаре Python использовались числа, булевы значения или None, то ошибки не будет, вместо этого они будут преобразованы в строки.

Приведенный ниже код:

import json

data = {1: 'Timur', False: 'Arthur', None: 'Ruslan'}
json_data = json.dumps(data)

print(json_data)
выводит:

{"1": "Timur", "false": "Arthur", "null": "Ruslan"}

                          Кириллические символы в json
import json
data = {'firstName': 'Тимур', 'lastName': 'Гуев'}
s = json.dumps(data)
print(s)
выводит:

{"firstName": "\u0422\u0438\u043c\u0443\u0440", "lastName": "\u0413\u0443\u0435\u0432"}
Результат, скорее всего, будет неожиданным. Каждая буква из строк Тимур и Гуев будет заменена на ее код. Эти коды стандартны, и код для каждой из букв индивидуален. Например. 0438 — код буквы и.  А на этой странице можно посмотреть полное описание этого кода и символа.

Обратное преобразование из строки в словарь вернет закодированное значение в первоначальный вид.

Приведенный ниже код:

import json

data = {'firstName': 'Тимур', 'lastName': 'Гуев'}
s = json.dumps(data)
print(s)
result = json.loads(s)
print(result)
выводит:

{"firstName": "\u0422\u0438\u043c\u0443\u0440", "lastName": "\u0413\u0443\u0435\u0432"}
{'firstName': 'Тимур', 'lastName': 'Гуев'}
Благодаря стандартным кодам, символы будут прочитаны и преобразованы в нужный вид любой программой на любом языке программирования.

С помощью необязательного аргумента ensure_ascii функций dumps() и dump() можно отказаться от такого кодирования.

Приведенный ниже код:

import json

data = {'firstName': 'Тимур', 'lastName': 'Гуев'}
s = json.dumps(data, ensure_ascii=False)
print(s)
result = json.loads(s)
print(result)
выводит:

{"firstName": "Тимур", "lastName": "Гуев"}
{'firstName': 'Тимур', 'lastName': 'Гуев'}
