Функции модуля itertools можно разделить на следующие категории:

порождающие данные
фильтрующие данные
преобразующие данные
группирующие данные
объединяющие или разделяющие данные
порождающие комбинаторные данные
В этом уроке речь пойдет о функциях, порождающих новые данные.

Функции, порождающие данные
К этой категории относятся следующие функции:

count()
cycle()
repeat()
Все функции данной категории по умолчанию порождают бесконечные итераторы.

-------------------------------------------------------------------------------------------------Функция count()----------------------------------------
Функция count() возвращает итератор, генерирующий бесконечную последовательность чисел.

Аргументы функции:

start — начало отсчета, по умолчанию имеет значение 0
step — шаг, по умолчанию имеет значение 1
В отличие от встроенной функции range(), в функции count() аргумент для задания верхней границы не предусмотрен.

Приведенный ниже код:

from itertools import count

count1 = count()

print(next(count1))
print(next(count1), next(count1), next(count1))

count2 = count(69, 10)

print(next(count2))
print(next(count2))
print(next(count2), next(count2), next(count2))

for i in zip(count(10), ['a', 'b', 'c']):
    print(i)
выводит:

0
1 2 3
69
79
89 99 109
(10, 'a')
(11, 'b')
(12, 'c')
Обратите внимание на то, что мы не можем создать список на основе итератора, который возвращает функция count(), поскольку он является бесконечным.

Аргументами start и step функции count() могут быть любые числовые значения, допускающие операцию сложения.

Приведенный ниже код:

from itertools import count
from fractions import Fraction

for index, number in enumerate(count(1.0, 0.5)):
    if index < 6:
        print(number)
    else:
        break

frac_iter = count(1, Fraction(1, 2))
print(next(frac_iter), next(frac_iter), next(frac_iter), next(frac_iter), next(frac_iter))
выводит:

1.0
1.5
2.0
2.5
3.0
3.5
1 3/2 2 5/2 3
Функция count() примерно эквивалентна следующему коду:

def count(start=0, step=1):
    n = start
    while True:
        yield n
        n += step
 -------------------------------------------------------------------------------------------------------------------------Функция cycle()-------------------------------------------------------------------
Функция cycle() возвращает итератор, циклично генерирующий последовательность элементов переданного итерируемого объекта.

Аргументы функции:

iterable — итерируемый объект
Обратите внимание на то, что функция cycle() сохраняет копию каждого элемента из iterable. Когда итерируемый объект iterable исчерпан, функция начинает возвращать элементы из сохраненной копии.

Приведенный ниже код:

from itertools import cycle

for index, char in enumerate(cycle('abcd')):
    if index < 7:
        print(char)
    else:
        break

cycle_iter = cycle([0, 1])
print(next(cycle_iter), next(cycle_iter), next(cycle_iter), next(cycle_iter), next(cycle_iter))

for i in zip(range(7), cycle(['a', 'b', 'c'])):
    print(i)
выводит:

a
b
c
d
a
b
c
0 1 0 1 0
(0, 'a')
(1, 'b')
(2, 'c')
(3, 'a')
(4, 'b')
(5, 'c')
(6, 'a')
Для выполнения функции cycle() может потребоваться значительное количество дополнительной памяти в зависимости от длины iterable.

Функция cycle() примерно эквивалентна следующему коду:

def cycle(iterable):
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element
----------------------------------------------------------------------------------------------------------------------------Функция repeat()-----------------------------------------------------------------------------
Функция repeat() возвращает итератор, бесконечно генерирующий единственное значение, переданное в качестве аргумента. Количество генераций можно ограничить c помощью необязательного аргумента times.

Аргументы функции:

obj — любой Python объект
times — количество повторений, по умолчанию имеет значение None
Приведенный ниже код:

from itertools import repeat

for i in repeat('bee-and-geek', 5):
    print(i)

repeat_iter = repeat([1, 2, 3])

print(next(repeat_iter))
print(next(repeat_iter))
print(next(repeat_iter))
выводит:

bee-and-geek
bee-and-geek
bee-and-geek
bee-and-geek
bee-and-geek
[1, 2, 3]
[1, 2, 3]
[1, 2, 3]
   Функция repeat() является ленивой, она использует только память, необходимую для хранения одного элемента.

Функцию repeat() удобно использовать совместно c функциями zip() и map(), если со значениями, генерируемыми другими итераторами, должно сочетаться некое постоянное значение.

Приведенный ниже код объединяет значения 0, 1, 2, 3, 4, ... со строкой bee-and-geek, возвращаемой функцией repeat():

from itertools import count, repeat

for i, s in zip(count(), repeat('bee-and-geek', 5)):
    print(i, s)
и выводит: 

0 bee-and-geek
1 bee-and-geek
2 bee-and-geek
3 bee-and-geek
4 bee-and-geek
Приведенный ниже код использует встроенную функцию map() для умножения на 2 чисел в диапазоне от 0 до 5.

from itertools import repeat

for a, b, c in map(lambda x, у: (x, у, x * у), repeat(2), range(6)):
    print(f'{a} * {b} = {c}')
выводит: 

2 * 0 = 0
2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
2 * 4 = 8
2 * 5 = 10
В данном случае итератор, возвращаемый функцией repeat(), не нуждается в явном ограничении числа генераций, поскольку обработка c помощью функции map() прекращается сразу же, как только исчерпывается любой из ее входных итерируемых объектов, а функция range() возвращает только шесть элементов.

Функция repeat() примерно эквивалентна следующему коду:

def repeat(object, times=None):
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object
-----------------------------------------------------------------------------------------------------------------------------------------------Функция starmap()----------------------------------------------
Функция starmap() возвращает итератор, элементами которого являются элементы переданного итерируемого объекта iterable, к которым была применена функция func.

Аргументы функции:

func — произвольная функция
iterable — итерируемый объект, элементами которого являются итерируемые объекты
Функция starmap() используется вместо map() в том случае, когда элементами итерируемого объекта являются другие итерируемые объекты, скажем, кортежи, и каждый элемент этих кортежей должен быть передан в функцию function в качестве самостоятельного аргумента.

Приведенный ниже код:

from itertools import starmap

persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]
pairs = [(1, 3), (2, 5), (6, 4)]
points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

full_names = list(starmap(lambda name, surname: f'{name} {surname}', persons))

print(full_names)
print(*starmap(lambda a, b: a + b, pairs))
print(*starmap(lambda x, y, z: x * y * z, points))
выводит:

['Timur Guev', 'Arthur Kharisov']
4 7 10
1 2 12
Разница между функциями map() и starmap() заключается в способе передачи аргументов вызываемой функции function и аналогична разнице между function(a, b) и function(*c).

Функция starmap() примерно эквивалентна следующему коду:

def starmap(function, iterable):
    for args in iterable:
        yield function(*args)

---------------------------------------------------------------------------------------------------------------------------Функция accumulate()-------------------------------------------------------------------------------
Функция accumulate() возвращает итератор, элементами которого являются накопленные суммы или накопленные результаты функции func.

Аргументы функции:

iterable — итерируемый объект
func — функция, принимающая два аргумента, по умолчанию используется функция сложения operator.add
initial — начальное значение, по умолчанию имеет значение None
Функция работает аналогично функции reduce() за тем исключением, что функция accumulate() генерирует все промежуточные результаты, а не только конечный.

Приведенный ниже код:

from itertools import accumulate
import operator

data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]

print(list(accumulate(data)))
print(list(accumulate(data, operator.mul)))
print(list(accumulate(data, max)))
print(list(accumulate(data, min)))
выводит:

[3, 7, 13, 15, 16, 25, 25, 32, 37, 45]
[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]
[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]
[3, 3, 3, 2, 1, 1, 0, 0, 0, 0]
Обычно количество элементов результирующего итератора совпадает с количеством элементов итерируемого объекта. Однако, если задано значение аргумента initial, то накопление начинается с начального значения initial, и в этом случае результирующий итератор будет иметь один дополнительный элемент.

 ​​​​​​Приведенный ниже код:

from itertools import accumulate

print(list(accumulate([1, 2, 3, 4, 5], initial=100)))
выводит:

[100, 101, 103, 106, 110, 115]
Функция accumulate() примерно эквивалентна следующему коду:

import operator

def accumulate(iterable, func=operator.add, *, initial=None):
    it = iter(iterable)
    total = initial
    if initial is None:
        try:
            total = next(it)
        except StopIteration:
            return
    yield total
    for element in it:
        total = func(total, element)
        yield total
