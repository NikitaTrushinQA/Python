                                                                       ОБРАБОТКА ИСКЛЮЧЕНИЙ 

Типы ошибок
Разработка программы на любом языке программирования практически всегда бывает связана с возникновением различного рода ошибок,
препятствующих получению желаемого результата.

Обычно выделяют следующие три категории ошибок:

-синтаксические – возникают из-за синтаксических погрешностей кода
-логические – проявляются вследствие логических неточностей в алгоритме
-ошибки времени выполнения, исключения – вызваны некорректными действиями пользователя или системы.

                                                                        СИНТАКСИЧЕСКИЕ ОШИБКИ
Синтаксические ошибки являются следствием несоблюдения общепринятого синтаксиса языка. Другими словами, это ошибки, связанные с неправильно набранным кодом.
Например пропуск круглой скобки, запятой или двоеточия.

В приведенном ниже коде:

print('Hello, world!'
допущена одна синтаксическая ошибка: пропущена закрывающая скобка. При попытке его запуска получим:

SyntaxError: '(' was never closed
В приведенном ниже коде:

def square(num)
    return num ** 2
допущена также синтаксическая ошибка: пропущен символ двоеточия в описании функции. При попытке его запуска получим:

    def square(num)
                   ^
SyntaxError: expected ':'
Синтаксические ошибки легко отлавливаются интерпретатором, который сразу же сообщает программисту о проблеме в написанном коде. 

                                                                            ЛОГИЧЕСКИЕ ОШИБКИ
Логические ошибки считаются более сложными в выявлении, поскольку не отлавливаются интерпретатором.
 Обычно они вызваны определенным недостатком в логике программы, из-за чего результат работы программы отличается от желаемого результата.
 Возможным решением проблемы является тестирование программы на разных примерах входных данных, для которых известен правильный результат.

В приведенном ниже коде:

def avg(a, b):
    return a + b / 2
описана функция avg(), подсчитывающая среднее значение переданных в нее аргументов.
В теле функции допущена логическая ошибка, пропущены скобки, на два должна делиться сумма чисел a и b.

Приведенный ниже код:

print(avg(6, 14))
выводит неверный результат:

13.0
Обратите внимание на то, что приведенная выше функция avg() не всегда работает неверно.

Приведенный ниже код:

print(avg(0, 7))
выводит верный результат:

3.5
Логические ошибки могут проявлять себя только при определенных условиях. Часто код с логической ошибкой может работать достаточно долго.

                                                                                  ОШИБКИ ВРЕМЕНИ ИСПОЛНЕНИЯ
Исключения представляют собой еще один вид ошибок, которые проявляются в зависимости от наличия обстоятельств, меняющих ход выполнения программы.
Исключения являются ошибками времени выполнения,возникающие в процессе выполнения программы и связанные с некорректностью переданных в программу данных,
недоступностью ресурсов и т.д.

Приведенный ниже код:

num1 = 10
num2 = 0

print(num1 / num2)
выводит:

ZeroDivisionError: division by zero
Деление на ноль провоцирует исключительную ситуацию, которая приводит к аварийному завершению работы и выводу ошибки на экран. ZeroDivisionError — это название исключения, а division by zero — его краткое описание.

Если мы хотим, чтобы программа работала с широким диапазоном входных данных и внешних условий, то надо учитывать исключения, программа должна их верно обрабатывать.

По умолчанию при обнаружении необработанного исключения Python немедленно останавливает выполнение программы и выводит сообщение об ошибке.

                                                                                   РАБОТА С КОДАМИ ВОЗВРАТА
В эпоху расцвета процедурного программирования синтаксис работы с исключениями был тривиален и основывался на том, что вернула функция. Если функция возвращала True — все хорошо, если же False — то произошла ошибка. При этом сразу выделились два подхода к работе с ошибками:

подход два в одном — функция возвращает False как для ожидаемой, так и для неожиданной ошибки. Такой подход как правило применялся в API общего назначения и коде пользовательских программ, когда большую часть ошибок можно было смело считать фатальными
подход разделения ошибок, при котором функция возвращает False в случае неожиданной ошибки, а ожидаемую ошибку возвращает отдельным возвращаемым значением (числовым). Такой подход применялся в более надежном коде и подразумевал разделение на ожидаемые ошибки и неожиданные
Для каждой ошибки можно придумать свой код возврата. Коды не должны совпадать с возможными обычными ответами.

Несмотря на то что язык Python полностью поддерживает работу с исключениями, как с полноценными объектами, мы все же можем встретить следы работы с кодами возврата, которые Python унаследовал от языка C.

Строковый тип данных str содержит два похожих метода find() и index(). Оба метода выполняют одну и ту же работу, а именно ищут позицию первого вхождения подстроки в заданную строку. Однако в случае если подстрока не найдена, то поведение методов отличается. Метод find() использует механизм кодов возврата, в то время как метод index() возбуждает исключение.

Приведенный ниже код:

text = 'Hello, world!'

print(text.find('w'))
print(text.find('a'))
выводит:

7
-1
Из-за того что в строке Hello, world! нет символа a, нам было возвращено значение −1. Это и есть код возврата.

Приведенный ниже код:

text = 'Hello, world!'

print(text.index('a'))
приводит к возникновению исключения:

ValueError: substring not found
При работе с кодами возврата даже простая функция для обработки пользовательских данных обрастает дополнительным кодом,
проверкой многих условий и «магическими» кодами возврата. Если функция с кодом возврата находится глубоко в стеке вызовов,
то придется сделать так, чтобы ее правильно обрабатывала вся вышестоящая цепочка функций. Каждая из них должна принимать код и возвращать свой.

                                                   Обработка исключений
Далеко не для каждой ошибки можно выполнить обработку так, чтобы программа продолжала выполняться. Однако в некоторых случаях такая обработка может быть выполнена. Собственно, о таких потенциально "отлавливаемых" ошибках, их перехвате и обработке будет идти речь в этом уроке.

Общая идея, заложенная в основу метода обработки исключений, такая: программный код, в котором теоретически может возникнуть ошибка, выделяется специальным образом – "берется на контроль". Если при выполнении этого программного кода ошибка не возникает, то ничего особенного не происходит. Если при выполнении "контролируемого" кода возникает ошибка, то выполнение кода останавливается и автоматически создается объект-исключение, содержащий описание возникшей ошибки.

С практической точки зрения мы можем думать об исключении как о некотором сообщении, которое генерируется интерпретатором Python в силу возникшей ошибки при выполнении кода или из-за некоторых других обстоятельств, близких по своей природе к ошибке выполнения кода. Хотя ошибка и исключение – это не одно и то же (исключение является
следствием ошибки), мы обычно отождествляем эти понятия.

Для обработки исключительных ситуаций в языке Python используется конструкция try-except. Существуют разные вариации использования этой конструкции.
Мы начнем с наиболее простой.

После ключевого слова try и двоеточия размещается блок программного кода, который мы подозреваем на предмет возможного возникновения ошибки. Этот код будем называть контролируемым. По завершении этого блока указывается ключевое слово except (с двоеточием), после которого идет еще один блок программного кода.
Этот код будем называть кодом обработки ошибки (исключения).

То есть шаблон такой:

try:
    # контролируемый код
except:
    # код обработки ошибки (исключения)
Если при выполнении кода в блоке try ошибка не возникла, то код обработки ошибки (исключения) в блоке except выполняться не будет.
Если при выполнении кода в блоке try возникла ошибка, то выполнение кода trу блока прекращается, и выполняется код обработки ошибки (исключения) в блоке except. После этого управление передается следующей команде после конструкции try-except.

Рассмотрим пример использования инструкции try-except. Контролируемый код содержит считывание данных от пользователя с последующей конвертацией к числовому типу int и выводом частного введенных чисел.

try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except:
    print('Вы ввели некорректные данные!')

print('Работа программы завершена!')
Результат выполнения этого программного кода зависит от того, какие значения будут введены. Рассмотрим несколько ситуаций.

Ситуация 1. На вход подаются два ненулевых целых числа, например 10 и 2. Тогда результатом выполнения кода будет:

Частное чисел равно 5.0
Работа программы завершена!
Ситуация 2. На вход подаются не числа, а строки, например abc и qwerty. Тогда результатом выполнения кода будет:

Вы ввели некорректные данные!
Работа программы завершена!
Ситуация 3. На вход подаются два целых числа, второе из которых ноль, например 10 и 0. Тогда результатом выполнения кода будет:

Вы ввели некорректные данные!
Работа программы завершена!
Обратите внимание на последнюю строчку программного кода, она находится вне конструкции try-except и будет выполняться всегда независимо от того,
произошла ошибка или нет.

Схема обработки ошибок (исключений), описанная выше, во многом проста и удобна. Но она не лишена недостатков. В первую очередь сразу бросается в глаза,
что разные ошибки (исключения) обрабатываются одинаково. То есть, какая бы ни возникла ошибка (исключение), реакция программы будет одна и та же.

Обработка нескольких исключений
Более утонченная обработка ошибок (исключительных ситуаций) подразумевает более индивидуальный подход.
Речь идет о том, чтобы обработка ошибок базировалась на типе или характере ошибки. Разумеется, это возможно.
Причем описанная выше схема обработки исключений претерпевает минимальные изменения.
В конструкции try-except после блока try указывается несколько ехсерt блоков, причем для каждого блока явно указывается тип ошибки (исключения), который обрабатывается в этом блоке. Ключевое слово, определяющее тип ошибки, указывается после ключевого слова except соответствующего блока.

То есть шаблон такой:

try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
Этот код выполняется следующим образом. Выполняются команды trу блока. Если возникла ошибка, то выполнение команд trу блока прекращается и начинается последовательный просмотр ехсерt блоков на предмет совпадения типа ошибки, которая возникла, и типа ошибки, указанного после ключевого слова в ехсерt блоке.
Как только совпадение найдено, выполняются команды соответствующего ехсерt блока, после чего управление переходит к команде после конструкции try-except.

Если при переборе ехсерt блоков совпадение по типу ошибки не найдено, выполнение кода прекращается и появляется сообщение об ошибке. Если при выполнении trу блока ошибок не было, коды в ехсерt блоках не выполняются.

Исправим приведенный выше код с учетом возможности использовать множественные блоки except, указывая тип конкретной ошибки:

try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except ValueError:
    print('Нужно было ввести числа!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')

print('Работа программы завершена!')
Как мы видим, по сравнению с предыдущим примером изменилась только та часть кода, что связана с ехсерt блоками.
Теперь мы имеем два except блока. После первого ключевого слова except указано название ValueError.
К типу ValueError относятся ошибки, возникающие при передаче в функцию аргумента с неподдерживаемым значением.
Во втором ехсерt блоке обрабатываются ошибки типа ZeroDivisionError. К этому типу относятся ошибки, возникающие при попытке выполнить деление на ноль.

Для каждого ехсерt блока предлагается свой программный код (в обоих случаях выводится сообщение с информацией о том, что произошло).
При выполнении кода в блоке try если произошла ошибка, тип этой ошибки сначала сопоставляется с типом ошибки ValueError в первом ехсерt блоке.
Если совпадение есть, то выполняется код этого блока. Если совпадения нет, проверяется совпадение типа ошибки с классом ошибки ZeroDivisionError во втором ехсерt блоке. Если есть совпадение – выполняется код данного ехсерt блока. Если же и здесь совпадения нет, выполнение программы завершается и появляется автоматически сгенерированное интерпретатором сообщение об ошибке.

Стоит также обратить внимание на следующее обстоятельство: обрабатываются в данном случае только ошибки типов ValueError и ZeroDivisionError.
Если бы теоретически возникла ошибка какого-то иного типа, то она бы перехвачена не была.

В рассмотренном выше примере мы создали для разных типов ошибок разные ехсерt блоки. Иногда приходится для нескольких типов ошибок создавать один ехсерt блок.
В этом случае после ключевого слова except в круглых скобках через запятую перечисляются те типы ошибок, для которых выполняется обработка в данном блоке.

try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except (ValueError, IndexError, KeyError):
    print('Тут обрабатываются сразу три типа ошибок!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')
except:
    print('Если не сработал ни один из предыдущих блоков except.')

print('Работа программы завершена!')
Обратите внимание также на последний блок except. Он будет обрабатывать любой тип исключения, отличный от указанных выше, причем такой блок должен быть только один, иначе возникнет ошибка (исключение) SyntaxError.

Основные типы исключений
Что касается типов исключений, наибольший интерес с практической точки зрения представляют следующие:

IndexError: возникает, когда индекс (например, для элемента списка) указан неправильно (выходит за границы допустимого диапазона)
KeyError: возникает при неверно указанном ключе словаря
NameError: возникает, если не удается найти переменную с некоторым названием
SyntaxError: возникает при наличии в исходном коде синтаксических ошибок
TypeError: возникает при несоответствии типов, когда для обработки требуется значение определенного типа, а передается значение другого типа
FileNotFoundError: возникает при открытии несуществующего файла
ValueError: возникает, когда в функцию передается аргумент с неподдерживаемым значением
ZeroDivisionError: возникает при попытке выполнить деление на ноль
Примечания
Примечание 1. Помимо "возникло исключение", в отношении исключений также часто говорят "было возбуждено исключение".

Примечание 2. Важно понимать разницу между типами исключений TypeError и ValueError.

Исключение TypeError возникает, когда встроенная функция (или операция) применяется к объекту неподходящего типа.

Приведенный ниже код:

print('beegeek' + 2022)
приводит к возникновению исключения TypeError.

Исключение ValueError возникает, когда встроенная функция (или операция) получает аргумент правильного типа, но с неподходящим значением, и ситуация не описывается более точным исключением, например, таким как IndexError.

Приведенный ниже код:

num = int('beegeek')
приводит к возникновению исключения ValueError.

Приведенный ниже код:

nums = [1, 2, 3]

print(nums[7])
приводит к возникновению исключения IndexError.

Примечание 3. О встроенных типах исключений можно почитать в документации по ссылке.

Примечание 4. При работе с исключениями бывает удобно иногда использовать оператор pass, равноценный отсутствию операции. В ходе исполнения данного оператора ничего не происходит, поэтому он может использоваться в качестве заглушки в тех местах, где это синтаксически необходимо, например, в инструкциях, где тело является обязательным, таких как def, except, with и т.д:

def do_something():
    pass  

try:
    print('beegeek')
except:
    pass

with open('beegeek.txt') as file:
    pass
Примечание 5. Обработчики исключений обрабатывают исключения не только в том случае, если они возникают непосредственно в блоке try, но и в том случае, если они возникают внутри функций, вызываемых в блоке try.

Приведенный ниже код:

def this_fails():
    num = 1 / 0

try:
    this_fails()
except ZeroDivisionError:
    print('Деление на ноль')
выводит:
Деление на ноль

                                                                                              Необязательный блок else
Помимо блоков try и except, в инструкции try-except может также использоваться необязательный блок else.

Блок else размещается после последнего ехсерt блока и содержит программный код, который выполняется только в том случае, если при выполнении кода в trу блоке ошибок (исключений) не было.

Шаблон инструкции try-except в этом случае такой:

try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
else:
    # код для случая, если ошибки (исключения) не было
Рассмотрим программный код:

try:
    num = int(input())
    print('Квадрат числа равен:', num ** 2)
except ValueError:
    print('Вы ввели некорректные данные!')
else:
    print('Ошибки не произошло!')

print('Работа программы завершена!')
Результат выполнения этого программного кода зависит от того, какое значение будет введено. Рассмотрим две ситуации.

Ситуация 1. На вход подается целое число, например 10. Тогда результатом выполнения кода будет:

Квадрат числа равен: 100
Ошибки не произошло!
Работа программы завершена!
Ситуация 2. На вход подается не число, а строка, например, abc. Тогда результатом выполнения кода будет:

Вы ввели некорректные данные!
Работа программы завершена!
Блок else в конструкции try-except подобен блоку else в конструкциях for/while. Он срабатывает если в контролируемом коде не произошло ошибок (если тело цикла завершилось штатным способом, без break).

                                                                                             Необязательный блок finally
Помимо необязательного блока else, в инструкции try-except можно также использовать необязательный блок finally.

Блок finally размещается после последнего ехсерt блока, либо после блока else, если он присутствует, и содержит программный код, который выполняется в любом случае, независимо от того, возникла ошибка (исключение) при выполнении кода trу блока или нет.

Шаблон инструкции try-except в этом случае такой:

try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
finally:
    # код, который выполняется всегда
Рассмотрим программный код:

try:
    num = int(input())
    print('Квадрат числа равен:', num ** 2)
except ValueError:
    print('Вы ввели некорректные данные!')
finally:
    print('Блок кода выполняется всегда!')

print('Работа программы завершена!')
Результат выполнения этого программного кода зависит от того, какое значение будет введено. Рассмотрим две ситуации.

Ситуация 1. На вход подается целое число, например, 10. Тогда результатом выполнения кода будет:

Квадрат числа равен: 100
Блок кода выполняется всегда!
Работа программы завершена!
Ситуация 2. На вход подается не число, а строка, например, abc. Тогда результатом выполнения кода будет:

Вы ввели некорректные данные!
Блок кода выполняется всегда!
Работа программы завершена!
   Блок finally располагается после блока else, в случае присутствия последнего.

Блок finally особенно удобен при работе с файлами, которые нужно обязательно закрывать, независимо от того, произошла ошибка (исключение) или нет.

Приведенный ниже код:

try:
    file = open('data.txt', encoding='utf-8')
    try:
        text = file.read()
    except:
        print('При чтении из файла произошла ошибка!')
    else:
        print('Чтение из файла прошло успешно!')
    finally:
        file.close()
except FileNotFoundError:
    print('Файл с указанным именем не найден!')
демонстрирует возможность использования блока finally. В этом коде файл будет закрыт в любом случае, вне зависимости от того, произошла ошибка или нет. Обратите также внимание на вложенность блоков try-except.

   Блоки try-except можно вкладывать один в другой. Python никак нас не ограничивает в количестве таких вложений.

Блок finally может также использоваться без блоков except и else. В этом случае если в блоке try возникает ошибка (исключение), то сначала выполняется блок finally, а затем ошибка (исключение) продолжает «всплывание» к обработчику более высокого уровня.

try:
    file = open('data.txt', encoding='utf-8')
    try:
        text = file.read()
    finally:
        file.close()
except FileNotFoundError:
    print('Файл с указанным именем не найден!')
except:
    print('Произошла ошибка!')
                                                                                     Общий шаблон инструкции try-except
Общий шаблон инструкции try-except, включая все блоки, имеет вид:

try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
else:
    # код для случая, если ошибки не было
finally:
    # код, который выполняется всегда
    
                                                              Работа с объектом возбужденного исключения
Если нужен доступ к сгенерированному исключению как к объекту, то используется специальный синтаксис.

Приведенный ниже код:

try:
    nums = [10, 5, 20, 25]
    print(nums[100])
except (KeyError, IndexError) as err:    # записываем сгенерированное исключение в переменную err
    print(err)
    print(type(err))
выводит:

list index out of range
<class 'IndexError'>
В данном примере в переменную err попадает объект типа IndexError.

Посмотреть все атрибуты объекта сгенерированного исключения можно с помощью встроенной функции dir().

Приведенный ниже код:

try:
    print(1 / 0)
except ZeroDivisionError as err:
    print(dir(err))
выводит:

['__cause__', '__class__', '__context__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__suppress_context__', '__traceback__', 'args', 'with_traceback']
Наибольший интерес представляет из себя атрибут args, о котором будет рассказано ниже.

В имени err нет ничего особенного. Это просто имя, которое мы выбрали для примеров. Можно использовать любое имя по своему выбору. Обычно используют имена err, exp, e.

Если при обработке всех исключений одним блоком except мы хотим получить доступ к объекту исключения, то нужно явно указать его тип.

Приведенный ниже код:

try:
    х = 1 / 0
except as err:
    print(err)
синтаксически неверен.

Для исправления кода мы пишем:

try:
    х = 1 / 0
except Exception as err:
    print(err)
Примечания
Примечание 1. Для получения информации об исключении можно воспользоваться функцией exc_infо() из модуля sys. Данная функция возвращает кортеж из трех значений: типа исключения, значения и объекта с трассировочной информацией об исключении, которое в данный момент обрабатывается.

Приведенный ниже код:

from sys import exc_info

try:
    х = 1 / 0
except Exception as err:
    print(exc_info())
выводит:

(<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero'), <traceback object at 0x000001BEEF80E840>)
Преобразовать эти значения в удобочитаемый вид позволяет модуль traceback.

Примечание 2.  типы исключений.

Тип исключения	Описание
BaseException	является классом самого верхнего уровня и базовым для всех прочих
классов исключений
Exception	базовый класс для большинства встроенных в Python исключений. Именно
его, а не BaseException, необходимо наследовать при создании пользовательского класса
исключения
AssertionError	возбуждается инструкцией assert
AttributeError	возбуждается при попытке обращения к несуществующему атрибуту объекта
EOFError	возбуждается функцией input() при достижении конца файла с вводными данными
ImportError	возбуждается, если невозможно импортировать модуль или пакет
IndexError	возбуждается при попытке получить элемент коллекции по несуществующему индексу
KeyError	возбуждается при попытке получить элемент коллекции по несуществующему ключу
MemoryError	возбуждается, если интерпретатору существенно не хватает оперативной памяти
NameError	возбуждается при попытке обратиться к необъявленной переменной
TypeError	возбуждается при несоответствии типов
ValueError	возбуждается при передаче в функцию аргумента с неподдерживаемым значением
ZeroDivisionError	возбуждается при попытке выполнить деление на ноль
NotImplementedError	возбуждается, если наследник класса не переопределил метод, который должен был переопределить

Примечание 3. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс называется потомком, наследником, дочерним или производным классом. Базовым классом для большинства встроенных в Python исключений является Exception.

                                                                     Возбуждение исключений
Для возбуждения исключения используется оператор raise. В качестве аргумента оператор raise использует экземпляр класса, унаследованного от Exception. Класс указывает на тип исключения, а аргумент, передаваемый конструктору этого исключения, обычно описывает подробности возникновения исключительной ситуации.

Если возбуждаемые пользователем исключения не перехватываются, то они распространяются вплоть до стандартного обработчика исключений и прекращают работу программы с выводом стандартного сообщения об ошибке.

Возбуждаемые пользователем исключения перехватываются тем же способом, что и исключения, которые возбуждает интерпретатор Python.

Приведенный ниже код:

try:
    raise IndexError('ошибочка')             # возбуждение исключения вручную
except Exception as err:
    print(err)
    print(type(err)) 
выводит:

ошибочка
<class 'IndexError'>
Приведем еще один пример:

def get_month_name(index):
    if not index.isdigit():
        raise TypeError('Аргумент должен быть числом.')
    if int(index) < 1 or int(index) > 12:
        raise ValueError('Аргумент должен быть целым числом от 1 до 12.')
     ...
При создании объекта исключения мы можем указать в конструкторе подробности возникновения исключительной ситуации. Конструктор любого исключения принимает переменное количество аргументов. Для того чтобы получить указанные значения, мы используем атрибут args, который является кортежем.

Приведенный ниже код:

try:
    x, y = 10, 0
    if y == 0:
        raise ZeroDivisionError('Произошло деление на ноль.')
except ZeroDivisionError as err:
    print(err)
    print(err.args)
    print(type(err.args))
выводит:

Произошло деление на ноль.
('Произошло деление на ноль.',)
<class 'tuple'>
   При печати объекта исключения автоматически происходит вызов функции str().

Оператор возбуждения исключений raise имеет несколько вариантов формата:

raise <экземпляр класса>
raise <название класса>
raise <экземпляр или название класса> from <объект исключения>
raise
В первом варианте оператора raise указывается экземпляр класса возбуждаемого исключения с аргументами при необходимости.

Пример:

raise ValueError('Oпиcaниe исключения')
Во втором варианте оператора raise указывается только название класса исключения.

Пример:

raise ValueError                       # эквивалентно: raise ValueError()
В третьем варианте оператора raise сначала указывается экземпляр класса или просто название класса, а потом объект исключения, на основании которого создается новое исключение. В этом случае объект исходного исключения сохраняется в атрибуте __cause__. При обработке вложенных исключений эти данные используются для вывода информации не только о последнем исключении, но и о первоначальном исключении.

Пример:

try:
    х = 1 / 0
except Exception as err:
   raise ZeroDivisionError('Описание исключения') from err
Повторное возбуждение исключения
В четвертом варианте оператора raise мы повторно возбуждаем и пробрасываем выше последнее перехваченное исключение.

Пример:

try:
    х = 1 / 0
except Exception as err:
    print(err)                  # каким-то образом обработали перехваченное исключение
    raise                       # пробрасываем исключение выше
Примечания
Примечание 1. Возбуждение исключения в коде похоже на return, только на его глобальную версию, завершающую все функции в порядке, обратном тому, в котором они вызывались. Если исключение будет возбуждено, но не будет перехвачено, то есть как-то обработано, вся программа так и завершится.

Примечание 2. Сам механизм исключений достаточно медленный, поэтому, например, не очень хорошей идеей будет возбуждать исключение внутри цикла, когда мы точно знаем, что их будет достаточно большое количество.

Примечание 3. В ситуации, когда мы перехватываем исключение, делаем некие действия, а затем пробрасываем его выше, нужно использовать следующий код:

try:
    х = 1 / 0
except Exception as err:
    print(err)                  # каким-то образом обработали перехваченное исключение
    raise                       # пробрасываем исключение выше
Использовать код:

try:
    х = 1 / 0
except Exception as err:
    print(err)
    raise err
не рекомендуется, так как мы получим возбуждение нового исключения, пусть даже и представляющего старый объект. Возбуждение нового исключения повлечет за собой потерю информации о месте возникновения изначального исключения.

Просто пишите raise — так будет заново возбуждено последнее перехваченное исключение с сохранением нужной информации.

Примечание 4. Как уже говорилось ранее, при создании объекта исключения мы можем указать в конструкторе подробности возникновения исключительной ситуации. Конструктор исключения принимает переменное количество аргументов.

Приведенный ниже код:

try:
    raise ValueError('Произошла ошибка')
except ValueError as e:
    print(e)
выводит:

Произошла ошибка
Примечательно то, что при передаче переменной с исключением в функцию print() происходит вывод именно тех аргументов, которые были указаны при создании объекта исключения. И если таких аргументов было передано несколько, они будут выведены все в виде кортежа.

Приведенный ниже код:

try:
    raise ValueError('Ой', 'Произошла ошибка')
except ValueError as e:
    print(e)
выводит:
('Ой', 'Произошла ошибка')
