                                                                       ОБРАБОТКА ИСКЛЮЧЕНИЙ 

Типы ошибок
Разработка программы на любом языке программирования практически всегда бывает связана с возникновением различного рода ошибок,
препятствующих получению желаемого результата.

Обычно выделяют следующие три категории ошибок:

-синтаксические – возникают из-за синтаксических погрешностей кода
-логические – проявляются вследствие логических неточностей в алгоритме
-ошибки времени выполнения, исключения – вызваны некорректными действиями пользователя или системы.

                                                                        СИНТАКСИЧЕСКИЕ ОШИБКИ
Синтаксические ошибки являются следствием несоблюдения общепринятого синтаксиса языка. Другими словами, это ошибки, связанные с неправильно набранным кодом.
Например пропуск круглой скобки, запятой или двоеточия.

В приведенном ниже коде:

print('Hello, world!'
допущена одна синтаксическая ошибка: пропущена закрывающая скобка. При попытке его запуска получим:

SyntaxError: '(' was never closed
В приведенном ниже коде:

def square(num)
    return num ** 2
допущена также синтаксическая ошибка: пропущен символ двоеточия в описании функции. При попытке его запуска получим:

    def square(num)
                   ^
SyntaxError: expected ':'
Синтаксические ошибки легко отлавливаются интерпретатором, который сразу же сообщает программисту о проблеме в написанном коде. 

                                                                            ЛОГИЧЕСКИЕ ОШИБКИ
Логические ошибки считаются более сложными в выявлении, поскольку не отлавливаются интерпретатором.
 Обычно они вызваны определенным недостатком в логике программы, из-за чего результат работы программы отличается от желаемого результата.
 Возможным решением проблемы является тестирование программы на разных примерах входных данных, для которых известен правильный результат.

В приведенном ниже коде:

def avg(a, b):
    return a + b / 2
описана функция avg(), подсчитывающая среднее значение переданных в нее аргументов.
В теле функции допущена логическая ошибка, пропущены скобки, на два должна делиться сумма чисел a и b.

Приведенный ниже код:

print(avg(6, 14))
выводит неверный результат:

13.0
Обратите внимание на то, что приведенная выше функция avg() не всегда работает неверно.

Приведенный ниже код:

print(avg(0, 7))
выводит верный результат:

3.5
Логические ошибки могут проявлять себя только при определенных условиях. Часто код с логической ошибкой может работать достаточно долго.

                                                                                  ОШИБКИ ВРЕМЕНИ ИСПОЛНЕНИЯ
Исключения представляют собой еще один вид ошибок, которые проявляются в зависимости от наличия обстоятельств, меняющих ход выполнения программы.
Исключения являются ошибками времени выполнения,возникающие в процессе выполнения программы и связанные с некорректностью переданных в программу данных,
недоступностью ресурсов и т.д.

Приведенный ниже код:

num1 = 10
num2 = 0

print(num1 / num2)
выводит:

ZeroDivisionError: division by zero
Деление на ноль провоцирует исключительную ситуацию, которая приводит к аварийному завершению работы и выводу ошибки на экран. ZeroDivisionError — это название исключения, а division by zero — его краткое описание.

Если мы хотим, чтобы программа работала с широким диапазоном входных данных и внешних условий, то надо учитывать исключения, программа должна их верно обрабатывать.

По умолчанию при обнаружении необработанного исключения Python немедленно останавливает выполнение программы и выводит сообщение об ошибке.

                                                                                   РАБОТА С КОДАМИ ВОЗВРАТА
В эпоху расцвета процедурного программирования синтаксис работы с исключениями был тривиален и основывался на том, что вернула функция. Если функция возвращала True — все хорошо, если же False — то произошла ошибка. При этом сразу выделились два подхода к работе с ошибками:

подход два в одном — функция возвращает False как для ожидаемой, так и для неожиданной ошибки. Такой подход как правило применялся в API общего назначения и коде пользовательских программ, когда большую часть ошибок можно было смело считать фатальными
подход разделения ошибок, при котором функция возвращает False в случае неожиданной ошибки, а ожидаемую ошибку возвращает отдельным возвращаемым значением (числовым). Такой подход применялся в более надежном коде и подразумевал разделение на ожидаемые ошибки и неожиданные
Для каждой ошибки можно придумать свой код возврата. Коды не должны совпадать с возможными обычными ответами.

Несмотря на то что язык Python полностью поддерживает работу с исключениями, как с полноценными объектами, мы все же можем встретить следы работы с кодами возврата, которые Python унаследовал от языка C.

Строковый тип данных str содержит два похожих метода find() и index(). Оба метода выполняют одну и ту же работу, а именно ищут позицию первого вхождения подстроки в заданную строку. Однако в случае если подстрока не найдена, то поведение методов отличается. Метод find() использует механизм кодов возврата, в то время как метод index() возбуждает исключение.

Приведенный ниже код:

text = 'Hello, world!'

print(text.find('w'))
print(text.find('a'))
выводит:

7
-1
Из-за того что в строке Hello, world! нет символа a, нам было возвращено значение −1. Это и есть код возврата.

Приведенный ниже код:

text = 'Hello, world!'

print(text.index('a'))
приводит к возникновению исключения:

ValueError: substring not found
При работе с кодами возврата даже простая функция для обработки пользовательских данных обрастает дополнительным кодом,
проверкой многих условий и «магическими» кодами возврата. Если функция с кодом возврата находится глубоко в стеке вызовов,
то придется сделать так, чтобы ее правильно обрабатывала вся вышестоящая цепочка функций. Каждая из них должна принимать код и возвращать свой.

                                                   Обработка исключений
Далеко не для каждой ошибки можно выполнить обработку так, чтобы программа продолжала выполняться. Однако в некоторых случаях такая обработка может быть выполнена. Собственно, о таких потенциально "отлавливаемых" ошибках, их перехвате и обработке будет идти речь в этом уроке.

Общая идея, заложенная в основу метода обработки исключений, такая: программный код, в котором теоретически может возникнуть ошибка, выделяется специальным образом – "берется на контроль". Если при выполнении этого программного кода ошибка не возникает, то ничего особенного не происходит. Если при выполнении "контролируемого" кода возникает ошибка, то выполнение кода останавливается и автоматически создается объект-исключение, содержащий описание возникшей ошибки.

С практической точки зрения мы можем думать об исключении как о некотором сообщении, которое генерируется интерпретатором Python в силу возникшей ошибки при выполнении кода или из-за некоторых других обстоятельств, близких по своей природе к ошибке выполнения кода. Хотя ошибка и исключение – это не одно и то же (исключение является
следствием ошибки), мы обычно отождествляем эти понятия.

Для обработки исключительных ситуаций в языке Python используется конструкция try-except. Существуют разные вариации использования этой конструкции.
Мы начнем с наиболее простой.

После ключевого слова try и двоеточия размещается блок программного кода, который мы подозреваем на предмет возможного возникновения ошибки. Этот код будем называть контролируемым. По завершении этого блока указывается ключевое слово except (с двоеточием), после которого идет еще один блок программного кода.
Этот код будем называть кодом обработки ошибки (исключения).

То есть шаблон такой:

try:
    # контролируемый код
except:
    # код обработки ошибки (исключения)
Если при выполнении кода в блоке try ошибка не возникла, то код обработки ошибки (исключения) в блоке except выполняться не будет.
Если при выполнении кода в блоке try возникла ошибка, то выполнение кода trу блока прекращается, и выполняется код обработки ошибки (исключения) в блоке except. После этого управление передается следующей команде после конструкции try-except.

Рассмотрим пример использования инструкции try-except. Контролируемый код содержит считывание данных от пользователя с последующей конвертацией к числовому типу int и выводом частного введенных чисел.

try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except:
    print('Вы ввели некорректные данные!')

print('Работа программы завершена!')
Результат выполнения этого программного кода зависит от того, какие значения будут введены. Рассмотрим несколько ситуаций.

Ситуация 1. На вход подаются два ненулевых целых числа, например 10 и 2. Тогда результатом выполнения кода будет:

Частное чисел равно 5.0
Работа программы завершена!
Ситуация 2. На вход подаются не числа, а строки, например abc и qwerty. Тогда результатом выполнения кода будет:

Вы ввели некорректные данные!
Работа программы завершена!
Ситуация 3. На вход подаются два целых числа, второе из которых ноль, например 10 и 0. Тогда результатом выполнения кода будет:

Вы ввели некорректные данные!
Работа программы завершена!
Обратите внимание на последнюю строчку программного кода, она находится вне конструкции try-except и будет выполняться всегда независимо от того,
произошла ошибка или нет.

Схема обработки ошибок (исключений), описанная выше, во многом проста и удобна. Но она не лишена недостатков. В первую очередь сразу бросается в глаза,
что разные ошибки (исключения) обрабатываются одинаково. То есть, какая бы ни возникла ошибка (исключение), реакция программы будет одна и та же.

Обработка нескольких исключений
Более утонченная обработка ошибок (исключительных ситуаций) подразумевает более индивидуальный подход.
Речь идет о том, чтобы обработка ошибок базировалась на типе или характере ошибки. Разумеется, это возможно.
Причем описанная выше схема обработки исключений претерпевает минимальные изменения.
В конструкции try-except после блока try указывается несколько ехсерt блоков, причем для каждого блока явно указывается тип ошибки (исключения), который обрабатывается в этом блоке. Ключевое слово, определяющее тип ошибки, указывается после ключевого слова except соответствующего блока.

То есть шаблон такой:

try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
Этот код выполняется следующим образом. Выполняются команды trу блока. Если возникла ошибка, то выполнение команд trу блока прекращается и начинается последовательный просмотр ехсерt блоков на предмет совпадения типа ошибки, которая возникла, и типа ошибки, указанного после ключевого слова в ехсерt блоке.
Как только совпадение найдено, выполняются команды соответствующего ехсерt блока, после чего управление переходит к команде после конструкции try-except.

Если при переборе ехсерt блоков совпадение по типу ошибки не найдено, выполнение кода прекращается и появляется сообщение об ошибке. Если при выполнении trу блока ошибок не было, коды в ехсерt блоках не выполняются.

Исправим приведенный выше код с учетом возможности использовать множественные блоки except, указывая тип конкретной ошибки:

try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except ValueError:
    print('Нужно было ввести числа!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')

print('Работа программы завершена!')
Как мы видим, по сравнению с предыдущим примером изменилась только та часть кода, что связана с ехсерt блоками.
Теперь мы имеем два except блока. После первого ключевого слова except указано название ValueError.
К типу ValueError относятся ошибки, возникающие при передаче в функцию аргумента с неподдерживаемым значением.
Во втором ехсерt блоке обрабатываются ошибки типа ZeroDivisionError. К этому типу относятся ошибки, возникающие при попытке выполнить деление на ноль.

Для каждого ехсерt блока предлагается свой программный код (в обоих случаях выводится сообщение с информацией о том, что произошло).
При выполнении кода в блоке try если произошла ошибка, тип этой ошибки сначала сопоставляется с типом ошибки ValueError в первом ехсерt блоке.
Если совпадение есть, то выполняется код этого блока. Если совпадения нет, проверяется совпадение типа ошибки с классом ошибки ZeroDivisionError во втором ехсерt блоке. Если есть совпадение – выполняется код данного ехсерt блока. Если же и здесь совпадения нет, выполнение программы завершается и появляется автоматически сгенерированное интерпретатором сообщение об ошибке.

Стоит также обратить внимание на следующее обстоятельство: обрабатываются в данном случае только ошибки типов ValueError и ZeroDivisionError.
Если бы теоретически возникла ошибка какого-то иного типа, то она бы перехвачена не была.

В рассмотренном выше примере мы создали для разных типов ошибок разные ехсерt блоки. Иногда приходится для нескольких типов ошибок создавать один ехсерt блок.
В этом случае после ключевого слова except в круглых скобках через запятую перечисляются те типы ошибок, для которых выполняется обработка в данном блоке.

try:
    num1 = int(input())
    num2 = int(input())
    print('Частное чисел равно', num1 / num2)
except (ValueError, IndexError, KeyError):
    print('Тут обрабатываются сразу три типа ошибок!')
except ZeroDivisionError:
    print('На ноль делить нельзя!')
except:
    print('Если не сработал ни один из предыдущих блоков except.')

print('Работа программы завершена!')
Обратите внимание также на последний блок except. Он будет обрабатывать любой тип исключения, отличный от указанных выше, причем такой блок должен быть только один, иначе возникнет ошибка (исключение) SyntaxError.

Основные типы исключений
Что касается типов исключений, наибольший интерес с практической точки зрения представляют следующие:

IndexError: возникает, когда индекс (например, для элемента списка) указан неправильно (выходит за границы допустимого диапазона)
KeyError: возникает при неверно указанном ключе словаря
NameError: возникает, если не удается найти переменную с некоторым названием
SyntaxError: возникает при наличии в исходном коде синтаксических ошибок
TypeError: возникает при несоответствии типов, когда для обработки требуется значение определенного типа, а передается значение другого типа
FileNotFoundError: возникает при открытии несуществующего файла
ValueError: возникает, когда в функцию передается аргумент с неподдерживаемым значением
ZeroDivisionError: возникает при попытке выполнить деление на ноль
Примечания
Примечание 1. Помимо "возникло исключение", в отношении исключений также часто говорят "было возбуждено исключение".

Примечание 2. Важно понимать разницу между типами исключений TypeError и ValueError.

Исключение TypeError возникает, когда встроенная функция (или операция) применяется к объекту неподходящего типа.

Приведенный ниже код:

print('beegeek' + 2022)
приводит к возникновению исключения TypeError.

Исключение ValueError возникает, когда встроенная функция (или операция) получает аргумент правильного типа, но с неподходящим значением, и ситуация не описывается более точным исключением, например, таким как IndexError.

Приведенный ниже код:

num = int('beegeek')
приводит к возникновению исключения ValueError.

Приведенный ниже код:

nums = [1, 2, 3]

print(nums[7])
приводит к возникновению исключения IndexError.

Примечание 3. О встроенных типах исключений можно почитать в документации по ссылке.

Примечание 4. При работе с исключениями бывает удобно иногда использовать оператор pass, равноценный отсутствию операции. В ходе исполнения данного оператора ничего не происходит, поэтому он может использоваться в качестве заглушки в тех местах, где это синтаксически необходимо, например, в инструкциях, где тело является обязательным, таких как def, except, with и т.д:

def do_something():
    pass  

try:
    print('beegeek')
except:
    pass

with open('beegeek.txt') as file:
    pass
Примечание 5. Обработчики исключений обрабатывают исключения не только в том случае, если они возникают непосредственно в блоке try, но и в том случае, если они возникают внутри функций, вызываемых в блоке try.

Приведенный ниже код:

def this_fails():
    num = 1 / 0

try:
    this_fails()
except ZeroDivisionError:
    print('Деление на ноль')
выводит:
Деление на ноль
