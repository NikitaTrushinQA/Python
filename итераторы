                                                                                                Итераторы
Итерируемые объекты
В языке Python под итерируемым объектом подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом.
К примеру, уже известные нам списки (тип list), строки (тип str), кортежи (тип tuple), множества (тип set), словари (тип dict) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Итератор — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию next(), то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция next() вернет следующий элемент и т.д.
Если же в итераторе элементов больше не осталось, то вызов функции next() приведет к возникновению исключения StopIteration.

Коллекции и последовательности
Коллекция — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

Также среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции называются последовательностями. Например, списки, строки и кортежи являются последовательностями, а множества и словари нет.

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию iter(), передав нужную коллекцию в качестве ее аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.

   Большинство функций, которые работают с итераторами, работают также и с коллекциями.

Приведенный ниже код:

numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основании списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора
выводит:

1
2
3

После того как мы получили итератор, мы можем передать его встроенной функции next(). При каждом новом вызове, функция next() возвращает очередной элемент итератора. Если же в итераторе элементов больше не осталось, то функция next() возбуждает исключение StopIteration.

Приведенный ниже код:

numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основе списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора

print(next(iterator))             # возбуждается исключение StopIteration
приводит к возникновению исключения StopIteration.

Единственное, что мы можем сделать с итератором, — передать его функции next(). Как только итератор становится пустым и порождается исключение StopIteration, он становится совершенно бесполезным.

Основная разница между последовательностями и итераторами, заключается в том, что в последовательностях элементы пронумерованы индексами, начиная от нуля. Мы можем обратиться к конкретному элементу таких объектов по индексу. В итераторах мы можем лишь последовательно запрашивать следующий элемент.

Приведенный ниже код:

numbers = [1, 2, 3, 4]            # список
letters = ('a', 'b', 'c')         # кортеж
language = 'python'               # строка

print(numbers[3])                 # обращение по индексу
print(letters[2])                 # обращение по индексу
print(language[5])                # обращение по индексу
выводит:

4
c
n
Приведенный ниже код:

letters = ('a', 'b', 'c')

iterator = iter(letters)           # создаем итератор на основе кортежа

print(iterator[1])                 # обращение по индексу
приводит к возникновению исключения:

TypeError: 'tuple_iterator' object is not subscriptable
Преимущества итераторов
Основными преимуществами использования итераторов являются:

однотипность работы с объектами разных типов
ленивые вычисления и экономия потребляемой памяти
комбинация множества итераторов для создания понятной и читабельной программы
Однотипность работы с объектами разных типов
Итераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, строки, множества, словари, объекты типа range имеют разные типы, но мы можем использовать любой из этих объектов:

в цикле for
в функциях высшего порядка map(), filter(), reduce(), reversed() и т.д.
для проверки наличия некоторого значения с помощью оператора принадлежности in
для распаковки элементов с помощью * и т.д.
Цикл for в Python работает по следующему принципу:

создает итератор на основе итерируемого объекта
запрашивает очередной элемент из итератора с помощью функции next() и передает его в выполняемый блок кода (тело цикла)
останавливается при получении исключения StopIteration
Благодаря этому, в цикл for можно передать и список, и кортеж, и строку, и объект типа range, и многие другие объекты, которые имеют свои итераторы.

По сути, приведенный ниже код:

numbers = [1, 2, 3, 4]

for num in numbers:
    print(num)
за кулисами превращается в:

numbers = [1, 2, 3, 4]

iterator = iter(numbers)           # создается итератор

while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
Ленивые вычисления и экономия потребляемой памяти
Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.

Приведенный ниже код:

numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
выводит:

0
1
2
3
4
Объекты типа range являются итерируемыми объектами. Цикл for создает на основе объекта range итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 4.

Важно понимать, что объект типа range не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся.
Размер объектов range не зависит от количества чисел, которые предполагается перебрать,ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

Приведенный ниже код:

from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
выводит (размер в байтах):

48
48
48
Все объекты range имеют один и тот же размер в памяти — 4848 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.

Приведенный ниже код:

from sys import getsizeof

numbers1 = list(range(5))                  # 5 чисел в списке
numbers2 = list(range(100000))             # 100000 чисел в списке

print(getsizeof(numbers1))
print(getsizeof(numbers2))
выводит (размер в байтах):

96
800056
Чем больше элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно.

Приведенный ниже код:

from sys import getsizeof

numbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке

print(getsizeof(numbers3))
приводит в возникновению исключения MemoryError. Python не позволяет нам создать такой большой список .

Объекты типа range являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.

Комбинация множества итераторов
У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
выводит:

1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
Обратите внимание на то, что все три объекта filter_iterator, map_iterator, enumerate_iterator являются итераторами. Они не хранят все данные в памяти, а создают и выдают их по мере того, как их запрашивают.
Другими словами, при обращении к очередному элементу enumerate_iterator произойдет последовательное обращение сначала к элементу map_iterator, а затем к

                                                                                      Примеры создания собственных итераторов
Пример 1. Создадим итератор Counter, который генерирует последовательность целых чисел от значения low до high с шагом один. Значения low и high передаются при создании итератора в конструкторе.

Реализация итератора. Определяем класс Counter с тремя методами:

__init__(): конструктор класса, вызывается единожды при создании объекта
__iter__(): метод, который возвращает ссылку на сам итератор для поддержания протокола итератора
__next__(): метод, который возвращает следующий элемент или возбуждает исключение StopIteration
class Counter:                             
    def __init__(self, low, high):         # конструктор принимает два аргумента low и high (помимо self)
        self.low = low
        self.high = high
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.low > self.high:
            raise StopIteration
        else:
            self.low += 1
            return self.low - 1
Приведенный ниже код:

counter1 = Counter(3, 10)         # создаем итератор Counter, передавая значения low=3, high=10

for i in counter1:                # неявно вызываем функцию next()
    print(i)

counter2 = Counter(100, 103)      # создаем итератор Counter, передавая значения low=100, high=103
print(next(counter2))             # явно вызываем функцию next()
print(next(counter2))             # явно вызываем функцию next()
выводит:

3
4
5
6
7
8
9
10
100
101
Напомним, что цикл for за кулисами вызывает один раз магический метод __iter__() у итерируемого объекта для получения итератора, а затем метод __next__() до тех пор, пока не будет возбуждено исключение StopIteration.

-----------------------------------------------------------------------------------------------------Функции, фильтрующие данные-------------------------------------------------------------------------------------
К этой категории относятся следующие функции:

dropwhile()
takewhile()
filterfalse()
compress()
islice()

------------------------------------------------------------------------------------------------------Функция dropwhile()-----------------------------------------------------------------------------------------
Функция dropwhile() возвращает итератор, который генерирует элементы из входного итерируемого объекта сразу же после того, как для заданного условия будет получено ложное значение.

Аргументы функции:

predicate — фильтрующая функция, возвращающая bool значение
iterable — итерируемый объект
Приведенный ниже код:

from itertools import dropwhile

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(dropwhile(lambda num: num <= 5, numbers))
print(new_numbers)

for word in dropwhile(lambda s: len(s) == 2, words):
    print(word)
выводит:

[6, 7, 8, 9, 10, 1, 2, 3]
python
C#
beegeek
is
Функция dropwhile() не выдает никаких выходных данных до тех пор, пока функция predicate не вернет ложное значение, поэтому она может иметь длительное время запуска.

Если требуется обеспечить более сложную логику фильтрации, то вместо использования лямбда функции нужно определить функцию явно.

Приведенный ниже код:

from itertools import dropwhile

def should_drop(x):
    print('Testing:', x)
    return x < 1

for i in dropwhile(should_drop, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)
выводит:

Testing: -1
Testing: 0
Testing: 1
Yielding: 1
Yielding: 2
Yielding: -2
Функция dropwhile() примерно эквивалентна следующему коду:

def dropwhile(predicate, iterable):
    iterable = iter(iterable)
    for x in iterable:
        if not predicate(x):
            yield x
            break
    for x in iterable:
        yield x
---------------------------------------------------------------------------------------------------------------------Функция takewhile()---------------------------------------------------------------------------------
Функция takewhile() возвращает итератор, который генерирует элементы из входного итерируемого объекта до тех пор пока для заданного условия не будет получено ложное значение. По сути, действия функции takewhile() противоположны действиям функции dropwhile().

Аргументы функции:

predicate — фильтрующая функция, возвращающая bool значение
iterable — итерируемый объект
Приведенный ниже код:

from itertools import takewhile

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(takewhile(lambda num: num <= 5, numbers))
print(new_numbers)

for word in takewhile(lambda s: len(s) == 2, words):
    print(word)
выводит:

[1, 1, 2, 3, 4, 4, 5]
is
an
of
Если требуется обеспечить более сложную логику фильтрации, то вместо использования лямбда функции нужно определить функцию явно.

Приведенный ниже код:

from itertools import takewhile

def should_take(x):
    print('Testing:', x)
    return x < 2

for i in takewhile(should_take, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)
выводит:

Testing: -1
Yielding: -1
Testing: 0
Yielding: 0
Testing: 1
Yielding: 1
Testing: 2
Как только функция should_take() возвращает ложное значение, функция takewhile() прекращает обработку переданного итерируемого объекта.

Функция takewhile() примерно эквивалентна следующему коду:

def takewhile(predicate, iterable):
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break
-------------------------------------------------------------------------------------------------------------------Функция filterfalse()----------------------------------------------------------------------------------------
Функция filterfalse() возвращает итератор, который генерирует элементы из входного итерируемого объекта для которых заданное условие ложно. По сути, действия функции filterfalse() противоположны действиям встроенной функции filter().

Аргументы функции:

predicate — фильтрующая функция, возвращающая bool значение
iterable — итерируемый объект
Приведенный ниже код:

from itertools import filterfalse

numbers = [1, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
words = ['is', 'an', 'of', 'python', 'C#', 'beegeek', 'is']

new_numbers = list(filterfalse(lambda num: num <= 5, numbers))
print(new_numbers)

for word in filterfalse(lambda s: len(s) == 2, words):
    print(word)
выводит:

[6, 7, 8, 9, 10]
python
beegeek
   Если predicate=None, то фильтрующая функция равнозначна функции bool()

Если требуется обеспечить более сложную логику фильтрации, то вместо использования лямбда функции нужно определить функцию явно.

Приведенный ниже код:

from itertools import filterfalse

def check_item(x):
    print('Testing:', x)
    return x < 1

for i in filterfalse(check_item, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)
выводит:

Testing: -1
Testing: 0
Testing: 1
Yielding: 1
Testing: 2
Yielding: 2
Testing: -2
Функция filterfalse() примерно эквивалентна следующему коду:

def filterfalse(predicate, iterable):
    if predicate is None:
        predicate = bool
    for x in iterable:
        if not predicate(x):
            yield x
--------------------------------------------------------------------------------------------------Функция compress()-------------------------------------------------------------------------------------------------------
Функция compress() предлагает другой способ фильтрации содержимого итерируемого объекта.
Вместо того чтобы вызывать функцию, она использует значения другого итерируемого объекта для индикации того, следует ли принять значение или игнорировать его.

Аргументы функции:

iterable — итерируемый объект
selectors — итерируемый объект, состоящий из значений True, False, который предоставляет значения, указывающие на то, какие входные значения следует брать, а какие следует игнорировать
Приведенный ниже код:

from itertools import compress

data = 'ABCDEF'
selectors = [True, False, True, False, True, False]

result = compress(data, selectors)
print(list(result))
выводит:

['A', 'C', 'E']
Обратите внимание на то, что функция compress() останавливается, когда исчерпан любой из итерируемых объектов iterable или selectors.

Приведенный ниже код:

from itertools import compress

data = 'ABCDEF'
selectors = [True, False, True]

result = compress(data, selectors)
print(list(result))
выводит:

['A', 'C']
Функция compress() примерно эквивалентна следующему коду:

def compress(iterable, selectors):
    for value, selector in zip(iterable, selectors):
        if selector:
            yield value
-
---------------------------------------------------------------------------------------------------------------------------------------Функция islice()-------------------------------------------------------------------------------------
Функция islice() возвращает итератор, который генерирует последовательность из выбранных элементов переданного итерируемого объекта.
Другими словами, функция islice() позволяет получить срез итерируемого объекта, для которого не всегда можно получить срез обычными средствами.

Аргументы функции:

iterable — итерируемый объект
start — начало среза, по умолчанию имеет значение 00
stop — конец среза (не включительно)
step — шаг среза, по умолчанию имеет значение 11
По сути, функция islice() имеет те же аргументы, что и оператор взятия среза списка: start, stop и step. При этом аргументы start и step — необязательные. Таким образом, вызывать функцию islice() можно одним из трех способов:

islice(iterable, stop)
islice(iterable, start, stop)
islice(iterable, start, stop, step)
при этом, если stop равен None, срез берется до конца.

Приведенный ниже код:

from itertools import islice

print(*islice(range(10), None))
print(*islice(range(100), 5))
print(*islice(range(100), 5, 10))
print(*islice(range(100), 0, 100, 10))
выводит:

0 1 2 3 4 5 6 7 8 9
0 1 2 3 4
5 6 7 8 9
0 10 20 30 40 50 60 70 80 90
В отличие от обычных срезов списков (строк, кортежей), функция islice() не поддерживает отрицательные значения для start, stop или step.

----------------------------------------------------------------------------------------------------------------------Функции, объединяющие и разделяющие данные-------------------------------------------------------------------------------------------------------------
К этой категории относятся следующие функции:

chain()
chain.from_iterable()
zip_longest()
tee()

----------------------------------------------------------------------------------------------------------------------------------функция chain()----------------------------------------------------------------------------------------------------
Функция chain() возвращает итератор, который последовательно генерирует элементы всех переданных итерируемых объектов.

Аргументы функции:

*iterables — итерируемые объекты
Приведенный ниже код:

from itertools import chain

chain_iter1 = chain('ABC', 'DEF')
print(*chain_iter1)

chain_iter2 = chain(enumerate('ABC'))
print(*chain_iter2)

for i in chain([1, 2, 3], ['a', 'b', 'c'], ('Timur', 29, 'Male', 'Teacher')):
    print(i, end=' ')
выводит:

A B C D E F
(0, 'A') (1, 'B') (2, 'C')
1 2 3 a b c Timur 29 Male Teacher 
Функция chain() упрощает обработку нескольких итерируемых объектов, не требуя предварительного конструирования объединенного списка.

Функция chain() примерно эквивалентна следующему коду:

def chain(*iterables):
    for it in iterables:
        for element in it:
            yield element-
------------------------------------------------------------------------------------------------------------------------Функция chain.from_iterable()--------------------------------------------------------------------
Функция chain.from_iterable() принимает в качестве аргумента итерируемый объект, содержащий другие итерируемые объекты и возвращает итератор, который генерирует элементы всех вложенных итерируемых объектов.

Аргументы функции:

iterable — итерируемый объект, содержащий другие итерируемые объекты
Приведенный ниже код:

from itertools import chain

chain_iter1 = chain.from_iterable(['ABC', 'DEF'])      # передаем список
print(*chain_iter1)

chain_iter2 = chain.from_iterable(enumerate('ABC'))
print(*chain_iter2)

for i in chain.from_iterable(['Timur', '29', 'Male', 'Teacher']):
    print(i, end=' ')
выводит:

A B C D E F
0 A 1 B 2 C
T i m u r 2 9 M a l e T e a c h e r 
Обратите внимание на то, что все вложенные в iterable объекты должны быть итерируемыми.

Приведенный ниже код:

from itertools import chain

for i in chain.from_iterable(('Timur', 29, 'Male', 'Teacher')):    # 29 - не итерируемый объект    
    print(i, end=' ')
приводит к возникновению исключения:

TypeError: 'int' object is not iterable
Функция chain.from_iterable() примерно эквивалентна следующему коду:

def from_iterable(iterables):
    for it in iterables:
        for element in it:
            yield element
------------------------------------------------------------------------------------------------------------------------------------Функция zip_longest()-------------------------------------------------------------------------
Как мы уже знаем, встроенная функция zip() возвращает итератор, объединяющий элементы нескольких итерируемых объектов в кортежи.
При этом функция zip() прекращает работу, как только исчерпывается самый короткий итерируемый объект.
Чтобы обеспечить обработку всех входных элементов, когда итерируемые объекты имеют разные длины, используется функция zip_longest().

Аргументы функции:

*iterables — итерируемые объекты
fillvalue — заполнитель, по умолчанию имеет значение None
Приведенный ниже код:

from itertools import zip_longest

print(*zip([1, 2, 3], ['a', 'b', 'c', 'd', 'e']))
print(*zip_longest([1, 2, 3], ['a', 'b', 'c', 'd', 'e']))                     # fillvalue=None
print(*zip_longest([1, 2, 3], ['a', 'b', 'c', 'd', 'e'], fillvalue='*'))
print(*zip_longest(['a', 'b', 'c', 'd', 'e'], [1, 2, 3], fillvalue=777))
выводит:

(1, 'a') (2, 'b') (3, 'c')
(1, 'a') (2, 'b') (3, 'c') (None, 'd') (None, 'e')
(1, 'a') (2, 'b') (3, 'c') ('*', 'd') ('*', 'e')
('a', 1) ('b', 2) ('c', 3) ('d', 777) ('e', 777)
-------------------------------------------------------------------------------------------------------------------------------------Функция tee()--------------------------------------------------------------------------------
Функция tee() позволяет создать несколько независимых итераторов на основе одного и того же итерируемого объекта.

Аргументы функции:

iterable — итерируемый объект
n — количество создаваемых итераторов, по умолчанию имеет значение 2
Итераторы, возвращаемые функцией tee(), могут быть использованы c целью передачи одного и того же набора данных нескольким алгоритмам для их параллельной обработки.

Приведенный ниже код:

from itertools import tee

iter1, iter2 = tee([1, 'a', 2, 'b', 3, 'c'])    # по умолчанию n=2

print(*iter1)
print(*iter2)
выводит:

1 a 2 b 3 c
1 a 2 b 3 c
Приведенный ниже код:

from itertools import tee

result = tee(range(2, 7), 5)
print(type(result))
for i in result:
    print(*i)
выводит:

<class 'tuple'>               # функция tee() возвращает кортеж с нужными итераторами
2 3 4 5 6
2 3 4 5 6
2 3 4 5 6
2 3 4 5 6
2 3 4 5 6
Семантика функции tee() аналогична семантике утилиты tee в Unix, которая повторяет значения, читаемые из входного потока, и записывает их в именованный файл или стандартный вывод.

Новые итераторы, созданные функцией tee(), разделяют данные c исходным итерируемым объектом, и поэтому после их создания исходный итерируемый объект не должен изменяться.

Приведенный ниже код:

from itertools import tee

data = (i for i in range(10))     # используем генераторное выражение

iter1, iter2 = tee(data)

print(next(data))                 # изменяем data                        

print(*iter1)
print(*iter2)
выводит:

0
1 2 3 4 5 6 7 8 9
1 2 3 4 5 6 7 8 9
Если исходный итерируемый объект является итератором, то значения, уже обработанные им ранее, не будут возвращаться вновь созданными итераторами.

Аналогичный результат получим, если в качестве итерируемого объекта передать список, а затем его изменить.

Приведенный ниже код:

from itertools import tee

data = [1, 2, 3, 4, 5]

iter1, iter2 = tee(data)

data.append(6)                      

print(*iter1)
print(*iter2)
выводит:

1 2 3 4 5 6
1 2 3 4 5 6
Для выполнения функции tee() может потребоваться значительное количество дополнительной памяти, в зависимости от того, сколько данных необходимо сохранить.

------------------------------------------------------------------------------------------------------------------Функция pairwise()----------------------------------------------------------
Функция pairwise() возвращает итератор, содержащий последовательные перекрывающиеся пары в виде кортежей, взятые из исходного итерируемого объекта.

Аргументы функции:

iterable — итерируемый объект
Приведенный ниже код:

from itertools import pairwise

print(*pairwise('ABCDEFG'))
print(*pairwise([1, 2, 3, 4, 5]))
выводит:

('A', 'B') ('B', 'C') ('C', 'D') ('D', 'E') ('E', 'F') ('F', 'G')
(1, 2) (2, 3) (3, 4) (4, 5)
Функция pairwise() примерно эквивалентна следующему коду:

def pairwise(iterable):
    a, b = tee(iterable)
    next(b, None)
    return zip(a, b)

----------------------------------------------------------------------------------------------------------Функции, группирующие данные-------------------------------------------------------------------------------
К этой категории относится единственная функция: groupby()
--------------------------------------------------------------------------------------Функция groupby()--------------------------------------------------------------------------
Функция groupby() используется для группировки смежных элементов итерируемого объекта.
Она возвращает итератор, содержащий кортежи, каждый из которых состоит из двух элементов: первый — значение, характеризующее группу, второй — итератор, содержащий элементы соответствующей группы.

Аргументы функции:

iterable — итерируемый объект
key — функция, вычисляющая значение, характеризующее группу
Если ключ key не указан или равен None, ключом по умолчанию является функция тождественности, которая возвращает элемент без изменений.

Приведенный ниже код:

from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

print(type(group_iter))
print(*group_iter, sep='\n')
выводит:

<class 'itertools.groupby'>
(1, <itertools._grouper object at 0x0000022424FCA590>)
(7, <itertools._grouper object at 0x0000022424FCA410>)
(15, <itertools._grouper object at 0x0000022424FCB2B0>)
(7, <itertools._grouper object at 0x0000022424FCBBB0>)
Как мы видим, не только сам результат вызова функции groupby() является итератором, но и вторые элементы результирующих кортежей также являются итераторами. Чтобы взглянуть на элементы, содержащиеся в данных итераторах,
мы можем воспользоваться любым известным нам способом, например, преобразованием в список.

Приведенный ниже код:

from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

for key, values in group_iter:
    print(f'{key}: {list(values)}')            # преобразуем итератор в список
выводит:

1: [1, 1, 1]
7: [7, 7, 7, 7]
15: [15]
7: [7, 7, 7]

Использование аргумента key
Как уже было сказано в начале урока, функция groupby() принимает в качестве необязательного аргумента key — функцию, которая вычисляет по элементу значение группирующего признака.

С аргументом key мы уже сталкивались много раз в прошлом, в таких функциях как min(), max(), sorted().

Приведенный ниже код:

numbers = [-81, 2, -6, -3, 9, -17, -8, -6, 7]

print(min(numbers, key=abs))                       # минимальный элемент по модулю
print(max(numbers, key=lambda num: num**2))        # элемент с максимальным квадратом
print(sorted(numbers, key=abs))                    # сортировка элементов по модулю
выводит:

2
-81
[2, -3, -6, -6, 7, -8, 9, -17, -81]
Аналогичным образом работает аргумент key у функции groupby().

Приведенный ниже код:

from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers, key=lambda num: num < 10)

for key, values in group_iter:
    print(f'{key}: {list(values)}')
выводит:

True: [1, 1, 1, 7, 7, 7, 7]
False: [15]
True: [7, 7, 7]
Первые семь чисел образуют первую группу, поскольку для всех них функция key возвращает значение True. Элемент со значением 1515 — образует вторую группу, так как для него функция key уже возвращает значение False, отличное от True. Наконец, следующие три элемента вновь образуют новую группу, так как для них функция key снова возвращает значение True, отличное от False.

Для того чтобы у нас было всего две группы, необходима предварительная сортировка по той же ключевой функции.

Приведенный ниже код:

from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

key_func = lambda num: num < 10

group_iter = groupby(sorted(numbers, key=key_func), key=key_func)

for key, values in group_iter:
    print(f'{key}: {list(values)}')
выводит:

False: [15]
True: [1, 1, 1, 7, 7, 7, 7, 7, 7, 7]
Таким образом, нужно запомнить правило: если мы хотим, чтобы все элементы для которых ключевая функция key возвращает одно и то же значение попали в одну группу, необходимо сначала отсортировать начальные данные по той же ключевой функции.

Примеры использования функции groupby()
Пример 1. Удалить подряд идущие одинаковые элементы в списке.

Решение. Будем использовать функцию groupby().

Приведенный ниже код:

from itertools import groupby

data = ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B']

result = [key for key, group in groupby(data)] 

print(result)
выводит:

['A', 'B', 'C', 'D', 'A', 'B']
Пример 2. Получить список с уникальными элементами списка.

Решение. Будем использовать функцию groupby().

Приведенный ниже код:

from itertools import groupby

data = ['A', 'A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'A', 'A', 'B', 'B', 'B']

result = [key for key, group in groupby(sorted(data))] 

print(result)
выводит:

['A', 'B', 'C', 'D']
   Для того чтобы работал приведенный выше код, нужно, чтобы элементы списка были сравнимы друг с другом.

Пример 3. Определить, какой символ встречается чаще всего в строке.

Решение. Будем использовать функцию groupby(), предварительно отсортировав данные.

Приведенный ниже код:

from itertools import groupby

data = 'aaabcdaabcccdddcccccccbrttbcc'
group_iter = groupby(sorted(data))

max_result = max(group_iter, key=lambda tpl: sum(1 for i in tpl[1]))

print('Символ встречающийся чаще всего в строке:', max_result[0])
выводит:

Символ встречающийся чаще всего в строке: c
Не забываем, что функция groupby() возвращает итератор, содержащий кортежи вида (key, group), при этом group также является итератором. Функция len() не работает с итераторами, поэтому для подсчета длины итератора мы используем выражение sum(1 for i in group).

Обратите также внимание на то, что после вызова функции max() наш итератор group_iter становится пустым. Если нам могут понадобиться данные позже, они должны быть сохранены в виде списка:

from itertools import groupby

data = 'aaabcdaabcccdddcccccccbrttbcc'
group_iter = groupby(sorted(data))

saved_data = [(key, list(group)) for key, group in group_iter]

max_result = max(saved_data, key=lambda tpl: len(tpl[1]))       # можем уже использовать len()
min_result = min(saved_data, key=lambda tpl: len(tpl[1]))

print('Символ встречающийся чаще всего в строке:', max_result[0])
print('Символ встречающийся реже всего в строке:', min_result[0])
   Функции max(), min(), в случае если максимальных/минимальных элементов несколько, возвращают первый из них.

Примечания
Примечание 1. Функция groupby() возвращает итератор, содержащий кортежи вида (key, group), при этом group также является итератором. Важным является то, что, если мы получили итератор, содержащий элементы очередной группы, это значит, что все итераторы, содержащие элементы предшествующих групп, уже пусты.

Приведенный ниже код:

from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

group1 = next(group_iter)[1]
group2 = next(group_iter)[1]
group3 = next(group_iter)[1]

print(list(group1))
print(list(group2))
print(list(group3))
выводит:

[]
[]
[15]
С другой стороны, приведенный ниже код:

from itertools import groupby

numbers = [1, 1, 1, 7, 7, 7, 7, 15, 7, 7, 7]

group_iter = groupby(numbers)

group1 = next(group_iter)[1]
print(list(group1))

group2 = next(group_iter)[1]
print(list(group2))

group3 = next(group_iter)[1]
print(list(group3))
выводит:

[1, 1, 1]
[7, 7, 7, 7]
[15]
Примечание 2. Функция sorted() работает с любым итерируемым объектом, но возвращает всегда отсортированный список.

Приведенный ниже код:

data = [1, 9, 5, 3, 4, 10, 2, 6]

print(sorted(data))
print(sorted(set(data)))
print(sorted(iter(data)))
выводит:

[1, 2, 3, 4, 5, 6, 9, 10]
[1, 2, 3, 4, 5, 6, 9, 10]
[1, 2, 3, 4, 5, 6, 9, 10]
