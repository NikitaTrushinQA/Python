                                                                                                Итераторы
Итерируемые объекты
В языке Python под итерируемым объектом подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом.
К примеру, уже известные нам списки (тип list), строки (тип str), кортежи (тип tuple), множества (тип set), словари (тип dict) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Итератор — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию next(), то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция next() вернет следующий элемент и т.д.
Если же в итераторе элементов больше не осталось, то вызов функции next() приведет к возникновению исключения StopIteration.

Коллекции и последовательности
Коллекция — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

Также среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции называются последовательностями. Например, списки, строки и кортежи являются последовательностями, а множества и словари нет.

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию iter(), передав нужную коллекцию в качестве ее аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.

   Большинство функций, которые работают с итераторами, работают также и с коллекциями.

Приведенный ниже код:

numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основании списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора
выводит:

1
2
3

После того как мы получили итератор, мы можем передать его встроенной функции next(). При каждом новом вызове, функция next() возвращает очередной элемент итератора. Если же в итераторе элементов больше не осталось, то функция next() возбуждает исключение StopIteration.

Приведенный ниже код:

numbers = [1, 2, 3]

iterator = iter(numbers)          # создаем итератор на основе списка

print(next(iterator))             # запрашиваем и печатаем первый элемент итератора
print(next(iterator))             # запрашиваем и печатаем второй элемент итератора
print(next(iterator))             # запрашиваем и печатаем третий элемент итератора

print(next(iterator))             # возбуждается исключение StopIteration
приводит к возникновению исключения StopIteration.

Единственное, что мы можем сделать с итератором, — передать его функции next(). Как только итератор становится пустым и порождается исключение StopIteration, он становится совершенно бесполезным.

Основная разница между последовательностями и итераторами, заключается в том, что в последовательностях элементы пронумерованы индексами, начиная от нуля. Мы можем обратиться к конкретному элементу таких объектов по индексу. В итераторах мы можем лишь последовательно запрашивать следующий элемент.

Приведенный ниже код:

numbers = [1, 2, 3, 4]            # список
letters = ('a', 'b', 'c')         # кортеж
language = 'python'               # строка

print(numbers[3])                 # обращение по индексу
print(letters[2])                 # обращение по индексу
print(language[5])                # обращение по индексу
выводит:

4
c
n
Приведенный ниже код:

letters = ('a', 'b', 'c')

iterator = iter(letters)           # создаем итератор на основе кортежа

print(iterator[1])                 # обращение по индексу
приводит к возникновению исключения:

TypeError: 'tuple_iterator' object is not subscriptable
Преимущества итераторов
Основными преимуществами использования итераторов являются:

однотипность работы с объектами разных типов
ленивые вычисления и экономия потребляемой памяти
комбинация множества итераторов для создания понятной и читабельной программы
Однотипность работы с объектами разных типов
Итераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, строки, множества, словари, объекты типа range имеют разные типы, но мы можем использовать любой из этих объектов:

в цикле for
в функциях высшего порядка map(), filter(), reduce(), reversed() и т.д.
для проверки наличия некоторого значения с помощью оператора принадлежности in
для распаковки элементов с помощью * и т.д.
Цикл for в Python работает по следующему принципу:

создает итератор на основе итерируемого объекта
запрашивает очередной элемент из итератора с помощью функции next() и передает его в выполняемый блок кода (тело цикла)
останавливается при получении исключения StopIteration
Благодаря этому, в цикл for можно передать и список, и кортеж, и строку, и объект типа range, и многие другие объекты, которые имеют свои итераторы.

По сути, приведенный ниже код:

numbers = [1, 2, 3, 4]

for num in numbers:
    print(num)
за кулисами превращается в:

numbers = [1, 2, 3, 4]

iterator = iter(numbers)           # создается итератор

while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
Ленивые вычисления и экономия потребляемой памяти
Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.

Приведенный ниже код:

numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
выводит:

0
1
2
3
4
Объекты типа range являются итерируемыми объектами. Цикл for создает на основе объекта range итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 4.

Важно понимать, что объект типа range не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся.
Размер объектов range не зависит от количества чисел, которые предполагается перебрать,ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

Приведенный ниже код:

from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
выводит (размер в байтах):

48
48
48
Все объекты range имеют один и тот же размер в памяти — 4848 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.

Приведенный ниже код:

from sys import getsizeof

numbers1 = list(range(5))                  # 5 чисел в списке
numbers2 = list(range(100000))             # 100000 чисел в списке

print(getsizeof(numbers1))
print(getsizeof(numbers2))
выводит (размер в байтах):

96
800056
Чем больше элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно.

Приведенный ниже код:

from sys import getsizeof

numbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке

print(getsizeof(numbers3))
приводит в возникновению исключения MemoryError. Python не позволяет нам создать такой большой список .

Объекты типа range являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.

Комбинация множества итераторов
У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
выводит:

1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
Обратите внимание на то, что все три объекта filter_iterator, map_iterator, enumerate_iterator являются итераторами. Они не хранят все данные в памяти, а создают и выдают их по мере того, как их запрашивают.
Другими словами, при обращении к очередному элементу enumerate_iterator произойдет последовательное обращение сначала к элементу map_iterator, а затем к
