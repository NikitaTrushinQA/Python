                                                                                    Функции генераторы
Функция генератор – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того, что использует выражение yield, а не return.

Когда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные.
Когда обычная функция достигает оператора return, локальные переменные уничтожаются и значение возвращается вызывающей стороне.
Последующий вызов той же функции создает новое локальное пространство имен и новый набор локальных переменных.

Функция генератор, напротив сохраняет локальные переменные от вызова к вызову. Это своего рода возобновляемая функция.

Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от 00 (включительно) до nn (не включительно).

def generate_ints(n):
    for num in range(n):
        yield num
Приведенный ниже код:

generator1 = generate_ints(5)           # создаем генератор, порождающий числа 0 1 2 3 4

print(type(generator1))

print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))

generator2 = generate_ints(3)           # создаем генератор, порождающий числа 0 1 2

for num in generator2:
    print(num)

num1, num2 = generate_ints(2)           # создаем генератор, порождающий числа 0 1

print(num1, num2)
выводит:

<class 'generator'>
0
1
2
3
4
0
1
2
0 1
По сути, функция generate_ints() просто возвращает генератор, порождающий последовательность нужных чисел. 

Генератор – это итератор, который порождает значения, переданные yield. Когда выполнение доходит до конца функции, объект генератор возбуждает исключение StopIteration в полном соответствии с протоколом итератора.

Работа с генератором происходит по стандартному сценарию работы с итератором. Мы можем:

вызывать функцию next() для получения очередного значения генератора
итерироваться с помощью цикла for по генератору
распаковывать генератор
проверять принадлежность с помощью оператора in
и т.д.
Функция генератор возвращает объект специального типа <class 'generator'>, который реализует протокол итератора, то есть является самым настоящим итератором.

Как несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий протокол итератора.

Класс GenerateInts полностью аналогичен указанной выше функции генератору:

class GenerateInts:                             
    def __init__(self, n):         # конструктор принимает верхнюю границу диапазона
        self.n = n
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.current == self.n:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
Приведенный ниже код:

iterator1 = GenerateInts(5)           # создаем итератор, содержащий числа 0 1 2 3 4

print(type(iterator1))

print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))

iterator2 = GenerateInts(3)           # создаем итератор, содержащий числа 0 1 2

for num in iterator2:
    print(num)

num1, num2 = GenerateInts(2)          # создаем итератор, содержащий числа 0 1

print(num1, num2)
выводит:

<class '__main__.GenerateInts'>
0
1
2
3
4
0
1
2
0 1
На данном примере видно, насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количества строк кода.

   Обратите внимание на стиль именования класса GenerateInts и функции генератора generate_ints().

Может показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно.

Приведенный ниже код:

def generate_1234():
    yield 1
    yield 2
    yield 3
    yield 4

print(*generate_1234())         # распаковка генератора
содержит определение функции генератора generate_1234(), которая порождает последовательность значений 1, 2, 3, 41,2,3,4 и выводит:

1 2 3 4
Функции генераторы с побочными действиями
Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:

вывод текста на экран
запись данных в файл
приостановка исполняющейся программы на некоторое время
и т.д.
Рассмотрим определение функции генератора, которая печатает текст во время выполнения.

Приведенный ниже код:

def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')

for char in generate_AB():
    print('-->', char)
выводит:

start
--> A
continue
--> B
end
Как мы уже знаем, для итерирования цикл for сначала получает итератор, то есть выполняет следующий код:

iterator = iter(generate_AB())
а затем на каждой итерации вызывает функцию next(iterator).  В теле цикла на каждой итерации печатается строка --> и значение, полученное при вызове next(iterator).

Во время первой итерации и первом вызове next(iterator) генератор, перед тем как сгенерировать значение 'A' (то есть дойти до строки yield 'A'), сначала выполняет строку print('start').

Во время второй итерации и втором вызове next(iterator) генератор, перед тем как сгенерировать значение 'B' (то есть дойти до строки yield 'B'), сначала выполняет строку print('continue').

Во время третьей итерации и третьем вызове next(iterator) генератор выполняет строку print('end') и завершает свою работу, возбуждая исключение StopIteration. Цикл for перехватывает это исключение и нормально завершается.

Ключевое слово return в теле функции генератора
До версии Python 3.3 наличие ключевого слова return внутри функции генератора приводило к возникновению ошибки:

SyntaxError: 'return' with argument inside generator
Теперь это допускается, при этом инструкция return приводит к возбуждению исключения StopIteration.

Приведенный ниже код:

def generate_ints():
    yield 1
    yield 2
    return 3
    yield 4

for num in generate_ints():
    print(num)
выводит:

1
2
Строка кода return 3 в функции генераторе generate_ints() возбуждает исключение StopIteration, которое перехватывает цикл for, после чего он завершается. Обратите внимание на то, что само значение 33 не выводится.

Особенности и ограничения функций генераторов
Основные особенности, присущие всем функциям генераторам:

любая функция, содержащая ключевое слово yield, является функцией генератором
когда вызывается функция генератор, то она не возвращает единственное значение, как это делает обыкновенная функция
функция генератор всегда возвращает объект типа generator, который поддерживает протокол итератора
Разница между yield и оператором return заключается в том, что для ключевого слова yield состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора __next__() функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.

Генератор является итератором, поэтому он обладает всеми его особенностями:

нельзя получить длину генератора функцией len()
нельзя распечатать элементы генератора функцией print() без предварительной распаковки
у генератора нельзя получить элемент по индексу
после итерации по генератору он становится пустым
Примеры использования функций генераторов
В прошлом уроке мы рассматривали примеры по созданию собственных итераторов с помощью создания соответствующих классов. Давайте перепишем их с использованием функций генераторов.

Пример 1. Реализуем функцию генератор counter(), которая возвращает генератор, порождающий последовательность целых чисел от значения low до high включительно с шагом один. Значения low и high передаются в качестве аргументов в функцию генератор.

Реализация функции генератора:

def counter(low, high):
    for num in range(low, high + 1):
        yield num
Приведенный ниже код:

counter1 = counter(3, 10)

for i in counter1:
    print(i)

counter2 = counter(100, 103)
print(next(counter2))
print(next(counter2))
выводит:

3
4
5
6
7
8
9
10
100
101
Ручная реализация соответствующего класса итератора
Пример 2. Реализуем функцию генератор even_numbers(), которая возвращает генератор, порождающий бесконечную последовательность целых четных чисел от значения begin. Значение begin передается в качестве аргумента в функцию генератор.

Реализация функции генератора:

def even_numbers(begin):
    begin += begin % 2
    while True:
        yield begin
        begin += 2
Приведенный ниже код:

evens1 = even_numbers(10)                     # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = even_numbers(101)                    # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
выводит:

10
12
14
16
18
20
102
104
106
108
Ручная реализация соответствующего класса итератора
Пример 3. Реализуем функцию генератор string_wrapper, которая возвращает генератор, порождающий последовательность символов строки text, обрамленных специальным символом symbol. Значения text  и symbol передаются в качестве аргументов в функцию генератор.

Реализация функции генератора:

def string_wrapper(text, symbol):
    for char in text:
        yield symbol + char + symbol
Приведенный ниже код:

string_wrapper1 = string_wrapper('beegeek', '~')

for char in string_wrapper1:
    print(char)
 
string_wrapper2 = string_wrapper('Python', '+')
print(next(string_wrapper2))
print(next(string_wrapper2))
print(next(string_wrapper2))

print(list(string_wrapper('stepik', '-')))
выводит:

~b~
~e~
~e~
~g~
~e~
~e~
~k~
+P+
+y+
+t+
['-s-', '-t-', '-e-', '-p-', '-i-', '-k-']
Ручная реализация соответствующего класса итератора
Пример 4. Реализуем функцию генератор factorials(), которая возвращает генератор, порождающий бесконечную последовательность факториалов всех натуральных чисел (от 11 до бесконечности). Функция генератор не принимает аргументов.

Реализация функции генератора:

def factorials():
    value = 1
    index = 1
    while True:
        yield value
        index += 1
        value *= index
Приведенный ниже код:

infinite_factorials = factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
выводит:

Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800


                                                                                                                       Конструкция yield from
Рассмотрим генераторную функциюget_data(), которая порождает последовательность чисел 0, 1, 2, 3, 4, а затем символов A, B, C:

def get_data():
    for num in range(5):
        yield num
    for char in 'ABC':
        yield char
Приведенный ниже код:

for i in get_data():
    print(i)
выводит:

0
1
2
3
4
A
B
C
Генераторную функцию get_data() можно упростить, если использовать синтаксическую конструкцию yield from <iterable>, которая появилась в Python 3.3.

Приведенный ниже код равнозначен первому определению генераторной функции get_data():

def get_data():
    yield from range(5)
    yield from 'ABC'
Таким образом, синтаксическая конструкция yield from <iterable> позволяет объединить две конструкции: yield и цикл for.

Реализуем генераторную функцию chain(*iterables), которая принимает произвольное количество итерируемых объектов и возвращает генератор, который последовательно порождает все значения сначала первого итерируемого объекта, затем второго, третьего и т.д.

Приведенный ниже код:

def chain(*iterables):
    for it in iterables:
        for value in it:
            yield value

for i in chain('AB', [1, 2], (4, 5), {'name': 'Timur', 'age': 29}):
    print(i, end=' ')
выводит:

A B 1 2 4 5 name age 
С помощью конструкции yield from <iterable> мы можем упростить тело генераторной функцииchain():

def chain(*iterables):
    for it in iterables:
        yield from it
Как мы видим, конструкция yield from полностью заменяет внутренний цикл for и код действительно смотрится несколько проще.

Объединение конструкции yield и цикла for лишь часть возможностей yield from. На самом деле конструкция yield from позволяет вкладывать один генератор в другой, таким образом создавать субгенераторы (вложенные генераторы).

Приведенный ниже код:

def generator2():
    yield 'Red'
    yield 'Blue'

def generator1():
    yield 'Green'
    yield from generator2()            # запрашиваем значение из субгенератора
    yield 'Yellow'
    yield 'Black'

for color in generator1():
    print(color, end=' ')
выводит:

Green Red Blue Yellow Black 
Когда генератор generator1() вызывает yield from generator2(), субгенератор generator2() перехватывает управление и начинает отдавать значения туда, откуда был вызван generator1(). А тем временем generator1() остается блокированным в ожидании завершения generator2().
Таким образом, эффект получается таким же, как если бы тело субгенератора было встроено в месте, где находится выражение yield from.

Конструкция yield from позволяет программисту легко управлять сразу несколькими генераторами, настраивать их взаимодействие.

Рекурсивные функции генераторы
Конструкции yield и yield from можно использовать для написания рекурсивных генераторов.

Приведенный ниже код:

def numbers(start):
    if not isinstance(start, int):
        raise TypeError('Аргументом должно быть целое число')
    yield start
    yield from numbers(start + 1)
определяет бесконечный генератор numbers(start), который порождает все целые числа со значения start.

Приведенный ниже код:

for index, number in enumerate(numbers(3)):
    if index > 5:
        break
    print(number)
выводит:

3
4
5
6
7
8

                      -----------------------------------------------------------------------------Генераторные выражения-----------------------------------------------------
Существует еще более простой, чем генераторные функции, содержащие оператор yield, способ создания итераторов – генераторные выражения. Они подходят, когда код тела генераторной функции можно записать в одно выражение.

Синтаксис генераторных выражений подобен синтаксису генераторов списков, но в отличие от них, в генераторных выражениях используются круглые скобки, а не квадратные.

   В Python существуют генераторы словарей и множеств, в которых используются фигурные скобки.

Напомним, как выглядят генераторы списков.

Приведенный ниже код:

from sys import getsizeof

numbers = [1, 9, 8, 7, 90, -56, -34, 56, 100, 90, 2, 8]

even_numbers = [num for num in numbers if num % 2 == 0]

print(type(even_numbers))
print(even_numbers)
print(getsizeof(even_numbers))
выводит:

<class 'list'>
[8, 90, -56, -34, 56, 100, 90, 2, 8]
184
Результат выражения, стоящего до for, в данном случае num, добавляется на каждой итерации цикла в итоговый список. Выполнение выражения генератора списка сразу заполняет список, который целиком хранится в памяти.

В случае генераторных выражений создается генератор, у которого очередной элемент будет вычисляться только при вызове встроенной функции next() (явно или неявно).

Приведенный ниже код:

from sys import getsizeof

numbers = [1, 9, 8, 7, 90, -56, -34, 56, 100, 90, 2, 8]

even_numbers = (num for num in numbers if num % 2 == 0)         # используем круглые скобки

print(type(even_numbers))
print(even_numbers)
print(getsizeof(even_numbers))
выводит:

<class 'generator'>
<generator object <genexpr> at 0x0000020E9C767300>
104
Обратите внимание на то, что переменная even_numbers имеет уже знакомый нам тип generator, то есть является генератором, который в полной мере реализует протокол итератора. Для того чтобы посмотреть содержимое генератора even_numbers,
мы должны проитерироваться по нему любым известным нам способом (явный вызов функции next(), цикл for, распаковка и т.д.).

Приведенный ниже код:

squares = (i ** 2 for i in range(1, 7))         # создаем генератор с помощью генераторного выражения
capitals = (s.upper() for s in 'abc')           # создаем генератор с помощью генераторного выражения
stars = ('*' for i in range(5))                 # создаем генератор с помощью генераторного выражения

for num in squares:
    print(num)

print(next(capitals))

print(*stars, end=' ')
выводит:

1
4
9
16
25
36
A
* * * * * 
В отличие от генераторных выражений, генераторные функции более универсальны не только из-за произвольного количества кода в их теле. В них вы можете передавать разные значения аргументов.
А значит, одна и та же функция может использоваться для создания нескольких разных генераторов.

Особенности генераторных выражений
1) Генераторные выражения нельзя писать без скобок – это синтаксическая ошибка.

Приведенный ниже код:

squares = i*i for i in range(10)
print(*squares)
приводит к синтаксической ошибке SyntaxError: invalid syntax.

2) При передаче генераторного выражения в функцию в качестве единственного аргумента скобки можно опускать 🧐.

Приведенный ниже код:

print(sum(i*i for i in range(10)))          # передача без скобок
print(sum((i*i for i in range(10))))        # передача со скобками
выводит:

285
285
3) Согласно PEP8 – то, что указано в скобках, можно переносить. Значит, генераторные выражения можно записывать так, чтобы их было удобно читать.

Приведенный ниже код:

even_squares = (
                i ** 2
                for i in range(10)
                if i % 2 == 0
               )
равнозначен:

even_squares = (i ** 2 for i in range(10) if i % 2 == 0)
Ограничения генераторных выражений
Генераторное выражение является итератором, поэтому оно обладает всеми его особенностями:

1) Нельзя получить длину генераторного выражения с помощью встроенной функции len().

Приведенный ниже код:

squares = (i*i for i in range(10))
print(len(squares))
приводит к возбуждению исключения:

TypeError: object of type 'generator' has no len()
2) Нельзя распечатать элементы генераторного выражения с помощью функции print(), без предварительной распаковки.

Приведенный ниже код:

squares = (i*i for i in range(10))
print(squares)
print(*squares)
выводит:

<generator object <genexpr> at 0x0000022B9D967370>
0 1 4 9 16 25 36 49 64 81
3) Генераторные выражения не поддерживают получение элемента по индексу.

Приведенный ниже код:

squares = (i*i for i in range(10))
print(squares[7])
приводит к возбуждению исключения:

TypeError: 'generator' object is not subscriptable
4) К генераторному выражению нельзя применить обычные операции среза.

Приведенный ниже код:

squares = (i*i for i in range(10))
print(squares[1:6])
приводит к возбуждению исключения:

TypeError: 'generator' object is not subscriptable
5) После использования генераторного выражения, оно остается пустым.

Приведенный ниже код:

squares = (i*i for i in range(10))

first, second = next(squares), next(squares)

nums1 = list(squares)
nums2 = list(squares)

print(first)
print(second)
print(nums1)
print(nums2)
выводит:

0
1
[4, 9, 16, 25, 36, 49, 64, 81]
[]
Генераторные выражения VS функции map(), filter()
Генераторные выражения могут использоваться в качестве альтернативы использования функций map(), filter(), которые преобразуют и фильтруют данные.
И генераторные выражения, и функции map(), filter() возвращают ленивые объекты, поддерживающие протокол итератора и не потребляющие много памяти.

Приведенный ниже код:

fruits = ['apple', 'apricot', 'avocado', 'pineapple', 'banana', 'bergamot', 'durian', 'grapefruit']

fruits_filter = filter(lambda s: len(s) > 7, fruits)
fruits_map = map(lambda s: s.upper(), fruits)
fruits_filter_map = map(lambda s: s.upper(), filter(lambda s: len(s) > 7, fruits))

print(*fruits_filter)
print(*fruits_map)
print(*fruits_filter_map)

print(type(fruits_filter))
print(type(fruits_map))
выводит:

pineapple bergamot grapefruit
APPLE APRICOT AVOCADO PINEAPPLE BANANA BERGAMOT DURIAN GRAPEFRUIT
PINEAPPLE BERGAMOT GRAPEFRUIT
<class 'filter'>
<class 'map'>
Альтернативный код с использованием генераторных выражений:

fruits = ['apple', 'apricot', 'avocado', 'pineapple', 'banana', 'bergamot', 'durian', 'grapefruit']

fruits_filter = (s for s in fruits if len(s) > 7)
fruits_map = (s.upper() for s in fruits)
fruits_filter_map = (s.upper() for s in fruits if len(s) > 7)

print(*fruits_filter)
print(*fruits_map)
print(*fruits_filter_map)

print(type(fruits_filter))
print(type(fruits_map))
выводит:

pineapple bergamot grapefruit
APPLE APRICOT AVOCADO PINEAPPLE BANANA BERGAMOT DURIAN GRAPEFRUIT
PINEAPPLE BERGAMOT GRAPEFRUIT
<class 'generator'>
<class 'generator'>
Несложно заметить, что генераторные выражения выглядят намного понятнее, лаконичнее и читабельнее, чем их соответствующие аналоги map(), filter() с лямбда функциями.

Сравнение занимаемой памяти
Генераторные выражения занимают немного больше памяти, чем соответствующие аналоги map(), filter() с лямбда функциями.

from sys import getsizeof

range_object = range(1000000)
list_object = list(range_object)
filter_object = filter(lambda num: True, range_object)
map_object = map(lambda num: num, range_object)
generator_object = (num for num in range_object)

print(getsizeof(range_object))
print(getsizeof(list_object))
print(getsizeof(filter_object))
print(getsizeof(map_object))
print(getsizeof(generator_object))
выводит:

48
8000056
48
48
104
Заметим, что увеличив размер диапазона range до 22 млн, увеличится размер лишь списка. При этом размеры остальных объектов останутся неизменными.

Генераторные выражения VS генераторные функции
Генераторные выражения и генераторные функции являются, как правило, взаимозаменяемыми.

Приведенная ниже генераторная функция:

def do_something(elements):
    for item in elements:
        yield some_operation(item)
может быть записана в виде функции, возвращающей генератор с помощью генераторного выражения:

def do_something(elements):
    return (some_operation(item) for item in elements)
Рассмотрим генераторную функцию trim_line_endings(), которая принимает в качестве аргумента файловый объект (открытый текстовый файл) и возвращает генератор, порождающий последовательность строк переданного файла без символа \n:

def trim_line_endings(lines):
    for line in lines:
        yield line.rstrip('\n')
Данная функция может быть в виде функции, возвращающей генератор с помощью генераторного выражения:

def trim_line_endings(lines):
    return (line.rstrip('\n') for line in lines)
Примечания
Примечание 1. Генераторные выражения более компактны, но менее универсальны, чем полные генераторные функции.

Примечание 2. Обратите внимание, если обрабатывается большая структура данных (список, словарь и т.д.) без использования генератора, то она сразу вся загружается в память, что может занять значительную часть памяти,
а в некоторых случаях оперативной памяти может не хватить, тогда будет возбуждено исключение MemoryError. В случае использования генераторного выражения (генераторной функции) такого не происходит, так как элементы создаются и обрабатываются по одному.
