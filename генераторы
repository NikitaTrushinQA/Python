                                                                                    Функции генераторы
Функция генератор – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того, что использует выражение yield, а не return.

Когда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные.
Когда обычная функция достигает оператора return, локальные переменные уничтожаются и значение возвращается вызывающей стороне.
Последующий вызов той же функции создает новое локальное пространство имен и новый набор локальных переменных.

Функция генератор, напротив сохраняет локальные переменные от вызова к вызову. Это своего рода возобновляемая функция.

Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от 00 (включительно) до nn (не включительно).

def generate_ints(n):
    for num in range(n):
        yield num
Приведенный ниже код:

generator1 = generate_ints(5)           # создаем генератор, порождающий числа 0 1 2 3 4

print(type(generator1))

print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))

generator2 = generate_ints(3)           # создаем генератор, порождающий числа 0 1 2

for num in generator2:
    print(num)

num1, num2 = generate_ints(2)           # создаем генератор, порождающий числа 0 1

print(num1, num2)
выводит:

<class 'generator'>
0
1
2
3
4
0
1
2
0 1
По сути, функция generate_ints() просто возвращает генератор, порождающий последовательность нужных чисел. 

Генератор – это итератор, который порождает значения, переданные yield. Когда выполнение доходит до конца функции, объект генератор возбуждает исключение StopIteration в полном соответствии с протоколом итератора.

Работа с генератором происходит по стандартному сценарию работы с итератором. Мы можем:

вызывать функцию next() для получения очередного значения генератора
итерироваться с помощью цикла for по генератору
распаковывать генератор
проверять принадлежность с помощью оператора in
и т.д.
Функция генератор возвращает объект специального типа <class 'generator'>, который реализует протокол итератора, то есть является самым настоящим итератором.

Как несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий протокол итератора.

Класс GenerateInts полностью аналогичен указанной выше функции генератору:

class GenerateInts:                             
    def __init__(self, n):         # конструктор принимает верхнюю границу диапазона
        self.n = n
        self.current = 0
    
    def __iter__(self):
        return self
    
    def __next__(self): 
        if self.current == self.n:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1
Приведенный ниже код:

iterator1 = GenerateInts(5)           # создаем итератор, содержащий числа 0 1 2 3 4

print(type(iterator1))

print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))

iterator2 = GenerateInts(3)           # создаем итератор, содержащий числа 0 1 2

for num in iterator2:
    print(num)

num1, num2 = GenerateInts(2)          # создаем итератор, содержащий числа 0 1

print(num1, num2)
выводит:

<class '__main__.GenerateInts'>
0
1
2
3
4
0
1
2
0 1
На данном примере видно, насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количества строк кода.

   Обратите внимание на стиль именования класса GenerateInts и функции генератора generate_ints().

Может показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно.

Приведенный ниже код:

def generate_1234():
    yield 1
    yield 2
    yield 3
    yield 4

print(*generate_1234())         # распаковка генератора
содержит определение функции генератора generate_1234(), которая порождает последовательность значений 1, 2, 3, 41,2,3,4 и выводит:

1 2 3 4
Функции генераторы с побочными действиями
Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:

вывод текста на экран
запись данных в файл
приостановка исполняющейся программы на некоторое время
и т.д.
Рассмотрим определение функции генератора, которая печатает текст во время выполнения.

Приведенный ниже код:

def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')

for char in generate_AB():
    print('-->', char)
выводит:

start
--> A
continue
--> B
end
Как мы уже знаем, для итерирования цикл for сначала получает итератор, то есть выполняет следующий код:

iterator = iter(generate_AB())
а затем на каждой итерации вызывает функцию next(iterator).  В теле цикла на каждой итерации печатается строка --> и значение, полученное при вызове next(iterator).

Во время первой итерации и первом вызове next(iterator) генератор, перед тем как сгенерировать значение 'A' (то есть дойти до строки yield 'A'), сначала выполняет строку print('start').

Во время второй итерации и втором вызове next(iterator) генератор, перед тем как сгенерировать значение 'B' (то есть дойти до строки yield 'B'), сначала выполняет строку print('continue').

Во время третьей итерации и третьем вызове next(iterator) генератор выполняет строку print('end') и завершает свою работу, возбуждая исключение StopIteration. Цикл for перехватывает это исключение и нормально завершается.

Ключевое слово return в теле функции генератора
До версии Python 3.3 наличие ключевого слова return внутри функции генератора приводило к возникновению ошибки:

SyntaxError: 'return' with argument inside generator
Теперь это допускается, при этом инструкция return приводит к возбуждению исключения StopIteration.

Приведенный ниже код:

def generate_ints():
    yield 1
    yield 2
    return 3
    yield 4

for num in generate_ints():
    print(num)
выводит:

1
2
Строка кода return 3 в функции генераторе generate_ints() возбуждает исключение StopIteration, которое перехватывает цикл for, после чего он завершается. Обратите внимание на то, что само значение 33 не выводится.

Особенности и ограничения функций генераторов
Основные особенности, присущие всем функциям генераторам:

любая функция, содержащая ключевое слово yield, является функцией генератором
когда вызывается функция генератор, то она не возвращает единственное значение, как это делает обыкновенная функция
функция генератор всегда возвращает объект типа generator, который поддерживает протокол итератора
Разница между yield и оператором return заключается в том, что для ключевого слова yield состояние выполнения генератора приостанавливается и локальные переменные сохраняются. При следующем вызове метода генератора __next__() функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.

Генератор является итератором, поэтому он обладает всеми его особенностями:

нельзя получить длину генератора функцией len()
нельзя распечатать элементы генератора функцией print() без предварительной распаковки
у генератора нельзя получить элемент по индексу
после итерации по генератору он становится пустым
Примеры использования функций генераторов
В прошлом уроке мы рассматривали примеры по созданию собственных итераторов с помощью создания соответствующих классов. Давайте перепишем их с использованием функций генераторов.

Пример 1. Реализуем функцию генератор counter(), которая возвращает генератор, порождающий последовательность целых чисел от значения low до high включительно с шагом один. Значения low и high передаются в качестве аргументов в функцию генератор.

Реализация функции генератора:

def counter(low, high):
    for num in range(low, high + 1):
        yield num
Приведенный ниже код:

counter1 = counter(3, 10)

for i in counter1:
    print(i)

counter2 = counter(100, 103)
print(next(counter2))
print(next(counter2))
выводит:

3
4
5
6
7
8
9
10
100
101
Ручная реализация соответствующего класса итератора
Пример 2. Реализуем функцию генератор even_numbers(), которая возвращает генератор, порождающий бесконечную последовательность целых четных чисел от значения begin. Значение begin передается в качестве аргумента в функцию генератор.

Реализация функции генератора:

def even_numbers(begin):
    begin += begin % 2
    while True:
        yield begin
        begin += 2
Приведенный ниже код:

evens1 = even_numbers(10)                     # все четные числа от 10 до бесконечности

for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)

evens2 = even_numbers(101)                    # все четные числа от 102 до бесконечности

print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
выводит:

10
12
14
16
18
20
102
104
106
108
Ручная реализация соответствующего класса итератора
Пример 3. Реализуем функцию генератор string_wrapper, которая возвращает генератор, порождающий последовательность символов строки text, обрамленных специальным символом symbol. Значения text  и symbol передаются в качестве аргументов в функцию генератор.

Реализация функции генератора:

def string_wrapper(text, symbol):
    for char in text:
        yield symbol + char + symbol
Приведенный ниже код:

string_wrapper1 = string_wrapper('beegeek', '~')

for char in string_wrapper1:
    print(char)
 
string_wrapper2 = string_wrapper('Python', '+')
print(next(string_wrapper2))
print(next(string_wrapper2))
print(next(string_wrapper2))

print(list(string_wrapper('stepik', '-')))
выводит:

~b~
~e~
~e~
~g~
~e~
~e~
~k~
+P+
+y+
+t+
['-s-', '-t-', '-e-', '-p-', '-i-', '-k-']
Ручная реализация соответствующего класса итератора
Пример 4. Реализуем функцию генератор factorials(), которая возвращает генератор, порождающий бесконечную последовательность факториалов всех натуральных чисел (от 11 до бесконечности). Функция генератор не принимает аргументов.

Реализация функции генератора:

def factorials():
    value = 1
    index = 1
    while True:
        yield value
        index += 1
        value *= index
Приведенный ниже код:

infinite_factorials = factorials()

for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
выводит:

Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800


                                                                                                                       Конструкция yield from
Рассмотрим генераторную функциюget_data(), которая порождает последовательность чисел 0, 1, 2, 3, 4, а затем символов A, B, C:

def get_data():
    for num in range(5):
        yield num
    for char in 'ABC':
        yield char
Приведенный ниже код:

for i in get_data():
    print(i)
выводит:

0
1
2
3
4
A
B
C
Генераторную функцию get_data() можно упростить, если использовать синтаксическую конструкцию yield from <iterable>, которая появилась в Python 3.3.

Приведенный ниже код равнозначен первому определению генераторной функции get_data():

def get_data():
    yield from range(5)
    yield from 'ABC'
Таким образом, синтаксическая конструкция yield from <iterable> позволяет объединить две конструкции: yield и цикл for.

Реализуем генераторную функцию chain(*iterables), которая принимает произвольное количество итерируемых объектов и возвращает генератор, который последовательно порождает все значения сначала первого итерируемого объекта, затем второго, третьего и т.д.

Приведенный ниже код:

def chain(*iterables):
    for it in iterables:
        for value in it:
            yield value

for i in chain('AB', [1, 2], (4, 5), {'name': 'Timur', 'age': 29}):
    print(i, end=' ')
выводит:

A B 1 2 4 5 name age 
С помощью конструкции yield from <iterable> мы можем упростить тело генераторной функцииchain():

def chain(*iterables):
    for it in iterables:
        yield from it
Как мы видим, конструкция yield from полностью заменяет внутренний цикл for и код действительно смотрится несколько проще.

Объединение конструкции yield и цикла for лишь часть возможностей yield from. На самом деле конструкция yield from позволяет вкладывать один генератор в другой, таким образом создавать субгенераторы (вложенные генераторы).

Приведенный ниже код:

def generator2():
    yield 'Red'
    yield 'Blue'

def generator1():
    yield 'Green'
    yield from generator2()            # запрашиваем значение из субгенератора
    yield 'Yellow'
    yield 'Black'

for color in generator1():
    print(color, end=' ')
выводит:

Green Red Blue Yellow Black 
Когда генератор generator1() вызывает yield from generator2(), субгенератор generator2() перехватывает управление и начинает отдавать значения туда, откуда был вызван generator1(). А тем временем generator1() остается блокированным в ожидании завершения generator2().
Таким образом, эффект получается таким же, как если бы тело субгенератора было встроено в месте, где находится выражение yield from.

Конструкция yield from позволяет программисту легко управлять сразу несколькими генераторами, настраивать их взаимодействие.

Рекурсивные функции генераторы
Конструкции yield и yield from можно использовать для написания рекурсивных генераторов.

Приведенный ниже код:

def numbers(start):
    if not isinstance(start, int):
        raise TypeError('Аргументом должно быть целое число')
    yield start
    yield from numbers(start + 1)
определяет бесконечный генератор numbers(start), который порождает все целые числа со значения start.

Приведенный ниже код:

for index, number in enumerate(numbers(3)):
    if index > 5:
        break
    print(number)
выводит:

3
4
5
6
7
8
