-----------------------------------------------------------------------------------------Вложенные функции---------------------------------------------------------------------------------------------
Python позволяет определять функции внутри других функций. Их называют вложенными функциями или внутренними функциями.

def speak(text):
    def whisper(t):                      # объявляем вложенную функцию
        return t.lower() + '...'
    return whisper(text)                 # вызываем вложенную функцию и возвращаем ее результат

print(speak('Hello, World'))         
определяет вложенную функцию whisper() внутри функции speak() и выводит:

hello, world...
Каждый раз, когда мы вызываем функцию speak(), она определяет новую внутреннюю функцию whisper(), а затем вызывает ее. При этом функция whisper() не существует вне родительской функции speak().

Приведенный ниже код:

whisper('Hello')
приводит к возникновению ошибки:

NameError: name 'whisper' is not defined
Ровно как и приведенный ниже код:

speak.whisper('Hello')
приводит к возникновению ошибки:

AttributeError: 'function' object has no attribute 'whisper'
Если нам нужно получить доступ к вложенной функции whisper() извне, то мы можем вернуть ее (вложенную функцию) вызывающей стороне родительской функции.

Функция высшего порядка get_speak_func() определяет две вложенные функции whisper() и yell().
В зависимости от аргумента volume, переданного родительской функции get_speak_func(), она выбирает и возвращает вызывающей стороне одну из вложенных функций:

def get_speak_func(volume):
    def whisper(text):
        return text.lower() + '...'
    def yell(text):
        return text.upper() + '!'

    if volume > 0.5:
        return yell
    else:
        return whisper
    Функции высшего порядка – это функции, которые принимают и/или возвращают другие функции.

Обратите внимание на то, что функция get_speak_func() на самом деле не вызывает одну из своих вложенных функций — она просто выбирает подходящую функцию на основе аргумента volume,
а затем возвращает объект этой функции.

Приведенный ниже код:

whisper = get_speak_func(0.3)     # функция whisper()
yell = get_speak_func(0.7)        # функция yell()

print(whisper('Hello'))           # говорим шепотом
print(yell('Hello'))              # кричим
выводит:

hello...
HELLO!
Таким образом, функции не только могут принимать поведение через аргументы, но также могут возвращать поведение.

Замыкания
Вложенные функции могут захватывать и переносить с собой часть состояния родительской функции.

Перепишем немного функцию get_speak_func(), чтобы новая версия сразу принимала два аргумента volume и text:

def get_speak_func(text, volume):
    def whisper():
        return text.lower() + '...'
    def yell():
        return text.upper() + '!'
    
    if volume > 0.5:
        return yell
    else:
        return whisper
Приведенный ниже код:

yell = get_speak_func('Hello, World', 0.7)

print(yell())
выводит:

HELLO, WORLD!
Теперь вложенные функции whisper() и yell() не имеют параметра text. Они его получают и используют через родительскую функцию get_speak_func().
Функции, которые делают это, называются замыканиями. Замыкание запоминает значения из включающей его области, даже если поток программы больше не находится в этой области.

Таким образом, замыкание — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения.
Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции.
Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.

def closure():
    count = 0
    def inner():
        nonlocal count
        count += 1
        print(count)
    return inner

start = closure()
another = closure()             # другое замыкание, со своими локальными значениями

start()                         # выводит 1
start()                         # выводит 2

another()                       # выводит 1

start()                         # выводит 3
Замыкания очень полезны при решении многих задач. С их помощью функции могут не только возвращать поведение, но и предварительно настраивать это поведение.

Рассмотрим несколько примеров, в которых используются замыкания.

Пример 1. В этом примере функция greeting_creator() служит фабрикой для создания и настройки функции приветствия.
Обратите внимание на то, что вложенная функция greet() может обращаться к аргументу greeting_word своей родительской функции greeting_creator().

def greeting_creator(greeting_word):
    def greet(name):
        return f'{greeting_word}, {name}'

    return greet
Приведенный ниже код:

say_hi = greeting_creator('Hi')
say_hello = greeting_creator('Hello')

print(say_hi('Timur'))
print(say_hello('Soslan'))
выводит:

Hi, Timur
Hello, Soslan
Пример 2. В этом примере функции make_adder() и multiplier_of() служат фабриками для создания и настройки функций «сумматора» и «мультипликатора».
Обратите внимание на то, что вложенные функции add() и mult() могут обращаться к аргументу n своих родительских функций make_adder() и multiplier_of().

def make_adder(n):
    def add(x):
        return x + n
    return add

def multiplier_of(n):
    def mult(x):
        return x * n
    return mult
Приведенный ниже код:

plus_3 = make_adder(3)
plus_5 = make_adder(5)
multiply_3 = multiplier_of(3)
multiply_5 = multiplier_of(5)

print(plus_3(10), plus_3(100))
print(plus_5(10), plus_5(100))
print(multiply_3(10), multiply_3(100))
print(multiply_5(10), multiply_5(100))
выводит:

13 103
15 105
30 300
50 500
Имейте в виду, что вложенные функции, которые возвращает родительская функция, могут быть анонимными. Приведенный выше код можно переписать в виде:

def make_adder(n):
    return lambda x: x + n

def multiplier_of(n):
    return lambda x: x * n
Пример 3. В этом примере функция line_generator() служит фабрикой для создания и настройки линейной функции вида y = kx + by=kx+b.
Обратите внимание на то, что вложенная функция func() может обращаться к аргументам k и b своей родительской функции line_generator().

def line_generator(k, b):
    def func(x):
        return k * x + b
    return func
Приведенный ниже код:

line_func_1 = line_generator(2, 5)        # получаем функцию y = 2*x + 5
line_func_2 = line_generator(-6, 9)       # получаем функцию y = -6*x + 9

print(line_func_1(10))                    # печатаем значение 2*10 + 5
print(line_func_2(4))                     # печатаем значение -6*4 + 9
выводит:

25
-15
Обратите внимание на то, что во всех предыдущих примерах наши вложенные функции (замыкания) использовали нелокальные переменные, которые являлись параметрическими для родительской функции.
Вложенные функции могут обращаться ко всем локальным переменным родительской функции, независимо от того, были они определены во внешней функции или пришли из аргументов внешней функции.

   Параметрические переменные тоже считаются локальными переменными.

Приведенный ниже код:

def f(x):
    z = 2
    def g(y):
        return z*x + y    # обращение к локальной переменной z и параметрической переменной x
    return g

h = f(5)
print(h(1))
выводит:

11
Нелокальные переменные
При поиске переменной с указанным именем приоритет (правило разрешения имен) следующий:

сначала ищем локальную переменную
если не нашли локальную, ищем нелокальную
если не нашли нелокальную, ищем глобальную
и в самом конце — встроенную в язык
Промежуточная область видимости, которая доступна вложенным функциям, называется нелокальной.
Если вложенность функций больше двух уровней, нелокальная переменная ищет в «ближайшей» области видимости, т. е. в функции вложенностью на один меньше.
Если не находит, поиск переходит в самую ближнюю из внешних областей видимости, затем в чуть более далекую — и так далее, пока не найдется нужное имя. Фактически интерпретатор ищет там, «где поближе».

Ключевое слово nonlocal
Как мы уже знаем, вложенная функция видит переменные в родительской функции, которые называются нелокальными или свободными переменными.

Рассмотрим следующий код:

def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
Такой код приводит к возникновению ошибки:

UnboundLocalError: local variable 'num' referenced before assignment
Дело в том, что вложенная функция не просто обращается (получает значение) к переменной num, но и пытается его изменить!
Внутренняя функция видит переменные в объемлющей функции, но, если она хочет такую переменную изменить, должна объявить ее nonlocal.

Приведенный ниже код:

def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        nonlocal num
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
выводит значение:

15
Атрибут __closure__
Все функции содержат специальный атрибут __closure__, который представляет из себя кортеж, содержащий данные, связанные с вложенными областями видимости, то есть с нелокальными переменными.

Приведенный ниже код:

def outer_function(arg):
    num = 5
    name = 'Timur'
    numbers = [1, 2, 3]
    def inner_function():      # определяем вложенную функцию
        print(arg)
        print(num)
        print(numbers)
    return inner_function      # возвращаем вложенную функцию
        
inner = outer_function('python')

for var in inner.__closure__:
    print(var.cell_contents)
выводит:

python
5
[1, 2, 3]
Обратите внимание на то, что кортеж __closure__ содержит внутри себя специальный тип данных. Для получение самого значения захваченной переменной нужно использовать атрибут cell_contents.

Когда использовать замыкания
Концепция замыканий, то есть функций, захватывающих нелокальные переменные, находят много применений при написании кода. Замыкания хороши для:

воздержания от жестко закодированных констант
воздержания от использования глобальных переменных
воздержания от создания ненужных типов данных (классов)
замыкания нужны для реализации декораторов, о которых мы поговорим чуть позже
Сокрытие данных основное преимущество замыканий.

Примечания
Примечание 1. Отличная статья про то, каким образом ищутся имена в программах Python доступна по ссылке.

Примечание 2. Прочитать подробнее про замыкания можно на википедии по ссылке.

Примечание 3. Вложенные (внутренние) функции позволяют избавиться от глобальных переменных.
Такая техника позволяет сделать внешнюю для функции переменную, но при этом спрятанную от посторонних глаз, в отличие от глобальной.
Такие переменные нужны в первую очередь для того, чтобы хранить какие-то данные, относящиеся к функции, между вызовами функции. Локальные переменные стираются при выходе из функции, глобальные — сохраняются, но видны всему свету, а нелокальные — идеальное сочетание закрытости и «сохраняемости».

Примечание 4. Если функция использует глобальные переменные, это тоже замыкание. Но чаще всего замыканием называют все-таки функцию, которая использует нелокальные переменные.
Такая функция как бы «таскает за собой» свои внешние переменные, но никому их не показывает.
