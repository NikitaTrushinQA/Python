-----------------------------------------------------------------------------------Мемоизация--------------------------------------------
Для решения проблемы повторного вычисления чисел Фибоначчи можно использовать механизм мемоизации.

Мемоизация – это способ оптимизации, при котором сохраняется результат выполнения функции, и этот результат используется при следующем вызове.

Перепишем функцию fib() с использованием мемоизации:

cache = {1: 1, 2: 1}                # ключ - номер числа, значение - число Фибоначчи 

def fib(n):
    result = cache.get(n)
    if result is None:
        result = fib(n - 2) + fib(n - 1)
        cache[n] = result
    return result
При такой реализации функции fib() сначала происходит проверка на наличие уже вычисленного элемента, и если он найден, то сразу возвращается его значение.

Приведенная выше реализация функции fib() хороша с точки зрения производительности, поскольку теперь мы не вычисляем много раз одно и то же число Фибоначчи.
Но её недостатком является то, что она использует глобальную переменную cache.

Как мы уже знаем, устранить такой недостаток можно с помощью вложенных функций:

def fib(n):
    ​cache = {1: 1, 2: 1}
    def fib_rec(n):
        result = cache.get(n)
        if result is None:
            result = fib_rec(n - 2) + fib_rec(n - 1)
            cache[n] = result
        return result
    return fib_rec(n)


----------------------------------------------------Рекурсивный обход коллекций-------------------------------------
Рекурсия является незаменимым помощником при работе с вложенными структурами данных. Рассмотрим несколько задач.

Задача 1. Дан список, элементами которого могут быть только строки или аналогичные списки, содержащие строки и вложенные списки.
Необходимо вывести все строки из данного списка и из всех вложенных, разделив пробелом.

Решение. Реализуем рекурсивную функцию get_all_str(), которая принимает в качестве аргумента указанный список и выводит его содержимое
в соответствии с условием задачи.

Итак, для начала определимся с базовым случаем. Он простой: если элемент является строкой, вернем ее саму.

В противном случае нам нужно с помощью цикла for пройтись по всем элементам списка, чтобы понять, есть ли среди них вложенные списки.
И если есть, то мы используем рекурсию: вызываем нашу же функцию и передаем ей в качестве аргумента новый список.

Рекурсивная реализация функции get_all_str():

def get_all_str(data):
    if type(data) == str:
        print(data, end=' ')            # базовый случай
    if type(data) == list:
        for i in data:
            get_all_str(i)              # рекурсивный случай
Приведенный ниже код:

numbers = ['1', ['2', '3', ['4'], ['5', ['6', '7']]]]

get_all_str(numbers)
выводит:

1 2 3 4 5 6 7 
Задача 2. Дан словарь произвольной вложенности, то есть значениями в словаре могут быть другие словари. 
Необходимо определить значение, которое соответствует заданному ключу, и вернуть его.
При этом гарантируется, что такой ключ имеется в словаре, причем он единственный. 

Решение. Реализуем рекурсивную функцию find_key(), которая принимает два аргумента в следующем порядке:

data — словарь произвольной вложенности
key — ключ, значение которого нужно вернуть
Итак, для начала определимся с базовым случаем. Он простой: если ключ есть в словаре, вернем его значение.

В противном случае нам нужно с помощью цикла for пройтись по всем ключам и значениям словаря, чтобы понять, есть ли среди значений вложенные словари. 
И если значением является вложенный словарь, то мы используем рекурсию: вызываем нашу же функцию и передаем ей в качестве аргумента новый словарь. 

 Рекурсивная реализация функции find_key():

def find_key(data, key):
    if key in data:
        return data[key]                # базовый случай
    
    for v in data.values():
        if type(v) == dict:
            value = find_key(v, key)    # рекурсивный случай
            if value is not None:
                return value 
Приведенный ниже код:

info = {'name': 'Alyson', 
        'surname': 'Hannigan', 
        'birthday': {'day': 24, 'month': 'March', 'year': 1974},
        'family': {'parents': {'mother': 'Emilie Posner', 'father': 'Alan Hannigan'}}}

print(find_key(info, 'year'))
print(find_key(info, 'father'))
выводит:

1974
Alan Hannigan

--------------------------------------------------------Настройка глубины рекурсии в Python-------------------------------------------
По умолчанию Python имеет ограничение на максимальную глубину рекурсивных вызовов.
Это ограничение не позволяет бесконечной рекурсии вызывать переполнение стека.

Получить значение по умолчанию для максимальной глубины рекурсии можно с помощью функции getrecursionlimit() из модуля sys.

Приведенный ниже код:

from sys import getrecursionlimit

limit = getrecursionlimit()
print(limit)
выводит:
1000

Мы также можем явно установить значение максимальной глубины рекурсии. Для этого используется функция setrecursionlimit() из модуля sys.

Приведенный ниже код:

import sys

limit = sys.getrecursionlimit()
print(limit)

sys.setrecursionlimit(6000)
new_limit = sys.getrecursionlimit()
print(new_limit)
выводит:

1000
6000
